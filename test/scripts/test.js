/**
 * common.js: loads each requirejs-compatible script file (except tests) and
 * configures requirejs to load libraries as shims
 *
 * This file is automatically generated as part of the build process.
 * Do not attempt manual changes
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

require.config({
  shim: {
    'qunit': {
      exports: 'QUnit',
      /**
       * disable QUnit autoload/autostart for requirejs optimizer compatibility
       */
      init: function() {
        QUnit.config.autoload = false;
        QUnit.config.autostart = false;
      }
    }
  },
  paths: {
    'core': '../../core/scripts/'
  }
});

define("config", function(){});

/**
 * config.js: sets up the shared configuration of the projects
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

require.config({
  shim: {
    'lib/modernizr': {
      deps: ['lib/Blob'],
      exports: 'Modernizr'
    },
    'lib/typeahead': {
      deps: ['jquery']
    },
    'lib/Blob': {
      exports: 'Blob'
    }
  },
  paths: {
    /**
     * All paths are relative to the baseUrl, not this config file, hence the
     * '../../'
     *
     * Unfortunately, they cannot be auto-generated within the script due to its
     * use as r.js config file. Since this is a shared file, the target/build
     * folders need to share the same parent directory, i.e. the project root.
     */
    'lib': '../../lib',
    'ui': '../../legacy/scripts/ui',
    'timemachine' : '../../legacy/scripts/timemachine',
    'jquery': '../../lib/jquery',
    'filesaver': '../../lib/FileSaver'
  }
});

define("core/config", function(){});

/* Blob.js
 * A Blob implementation.
 * 2014-07-24
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/dsamarin
 * License: MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob

			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array

			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		// Polyfill URL
		if (!real_URL.createObjectURL) {
			URL = view.URL = function(uri) {
				var
					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
					, uri_origin
				;
				uri_info.href = uri;
				if (!("origin" in uri_info)) {
					if (uri_info.protocol.toLowerCase() === "data:") {
						uri_info.origin = null;
					} else {
						uri_origin = uri.match(origin);
						uri_info.origin = uri_origin && uri_origin[1];
					}
				}
				return uri_info;
			};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				var
					  str = ""
					, buf = new Uint8Array(data)
					, i = 0
					, buf_len = buf.length
				;
				for (; i < buf_len; i++) {
					str += String.fromCharCode(buf[i]);
				}
				bb.push(str);
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		FB_proto.close = function() {
			this.size = 0;
			delete this.data;
		};
		return FakeBlobBuilder;
	}(view));

	view.Blob = function(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				if (Uint8Array && blobParts[i] instanceof Uint8Array) {
					builder.append(blobParts[i].buffer);
				}
				else {
					builder.append(blobParts[i]);
				}
			}
		}
		var blob = builder.getBlob(type);
		if (!blob.slice && blob.webkitSlice) {
			blob.slice = blob.webkitSlice;
		}
		return blob;
	};

	var getPrototypeOf = Object.getPrototypeOf || function(object) {
		return object.__proto__;
	};
	view.Blob.prototype = getPrototypeOf(new view.Blob());
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

define("lib/Blob", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Blob;
    };
}(this)));

/*!

 diff v2.2.1

Software License Agreement (BSD License)

Copyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>

All rights reserved.

Redistribution and use of this software in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of Kevin Decker nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
@license
*/
!function(a,b){"object"==typeof exports&&"object"==typeof module?module.exports=b():"function"==typeof define&&define.amd?define('lib/diff',[],b):"object"==typeof exports?exports.JsDiff=b():a.JsDiff=b()}(this,function(){return function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={exports:{},id:d,loaded:!1};return a[d].call(e.exports,e,e.exports,b),e.loaded=!0,e.exports}var c={};return b.m=a,b.c=c,b.p="",b(0)}([function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}b.__esModule=!0;var e=c(1),f=d(e),g=c(2),h=c(3),i=c(5),j=c(6),k=c(7),l=c(8),m=c(9),n=c(10),o=c(12),p=c(13),q=c(14);b.Diff=f["default"],b.diffChars=g.diffChars,b.diffWords=h.diffWords,b.diffWordsWithSpace=h.diffWordsWithSpace,b.diffLines=i.diffLines,b.diffTrimmedLines=i.diffTrimmedLines,b.diffSentences=j.diffSentences,b.diffCss=k.diffCss,b.diffJson=l.diffJson,b.structuredPatch=o.structuredPatch,b.createTwoFilesPatch=o.createTwoFilesPatch,b.createPatch=o.createPatch,b.applyPatch=m.applyPatch,b.applyPatches=m.applyPatches,b.parsePatch=n.parsePatch,b.convertChangesToDMP=p.convertChangesToDMP,b.convertChangesToXML=q.convertChangesToXML,b.canonicalize=l.canonicalize},function(a,b){"use strict";function c(){}function d(a,b,c,d,e){for(var f=0,g=b.length,h=0,i=0;g>f;f++){var j=b[f];if(j.removed){if(j.value=d.slice(i,i+j.count).join(""),i+=j.count,f&&b[f-1].added){var k=b[f-1];b[f-1]=b[f],b[f]=k}}else{if(!j.added&&e){var l=c.slice(h,h+j.count);l=l.map(function(a,b){var c=d[i+b];return c.length>a.length?c:a}),j.value=l.join("")}else j.value=c.slice(h,h+j.count).join("");h+=j.count,j.added||(i+=j.count)}}var m=b[g-1];return(m.added||m.removed)&&a.equals("",m.value)&&(b[g-2].value+=m.value,b.pop()),b}function e(a){return{newPos:a.newPos,components:a.components.slice(0)}}b.__esModule=!0,b["default"]=c,c.prototype={diff:function(a,b){function c(a){return h?(setTimeout(function(){h(void 0,a)},0),!0):a}function f(){for(var f=-1*l;l>=f;f+=2){var g=void 0,h=n[f-1],m=n[f+1],o=(m?m.newPos:0)-f;h&&(n[f-1]=void 0);var p=h&&h.newPos+1<j,q=m&&o>=0&&k>o;if(p||q){if(!p||q&&h.newPos<m.newPos?(g=e(m),i.pushComponent(g.components,void 0,!0)):(g=h,g.newPos++,i.pushComponent(g.components,!0,void 0)),o=i.extractCommon(g,b,a,f),g.newPos+1>=j&&o+1>=k)return c(d(i,g.components,b,a,i.useLongestToken));n[f]=g}else n[f]=void 0}l++}var g=arguments.length<=2||void 0===arguments[2]?{}:arguments[2],h=g.callback;"function"==typeof g&&(h=g,g={}),this.options=g;var i=this;a=this.castInput(a),b=this.castInput(b),a=this.removeEmpty(this.tokenize(a)),b=this.removeEmpty(this.tokenize(b));var j=b.length,k=a.length,l=1,m=j+k,n=[{newPos:-1,components:[]}],o=this.extractCommon(n[0],b,a,0);if(n[0].newPos+1>=j&&o+1>=k)return c([{value:b.join(""),count:b.length}]);if(h)!function q(){setTimeout(function(){return l>m?h():void(f()||q())},0)}();else for(;m>=l;){var p=f();if(p)return p}},pushComponent:function(a,b,c){var d=a[a.length-1];d&&d.added===b&&d.removed===c?a[a.length-1]={count:d.count+1,added:b,removed:c}:a.push({count:1,added:b,removed:c})},extractCommon:function(a,b,c,d){for(var e=b.length,f=c.length,g=a.newPos,h=g-d,i=0;e>g+1&&f>h+1&&this.equals(b[g+1],c[h+1]);)g++,h++,i++;return i&&a.components.push({count:i}),a.newPos=g,h},equals:function(a,b){return a===b},removeEmpty:function(a){for(var b=[],c=0;c<a.length;c++)a[c]&&b.push(a[c]);return b},castInput:function(a){return a},tokenize:function(a){return a.split("")}},a.exports=b["default"]},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){return h.diff(a,b,c)}b.__esModule=!0,b.diffChars=e;var f=c(1),g=d(f),h=new g["default"];b.characterDiff=h},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){var d=i.generateOptions(c,{ignoreWhitespace:!0});return l.diff(a,b,d)}function f(a,b,c){return l.diff(a,b,c)}b.__esModule=!0,b.diffWords=e,b.diffWordsWithSpace=f;var g=c(1),h=d(g),i=c(4),j=/^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/,k=/\S/,l=new h["default"];b.wordDiff=l,l.equals=function(a,b){return a===b||this.options.ignoreWhitespace&&!k.test(a)&&!k.test(b)},l.tokenize=function(a){for(var b=a.split(/(\s+|\b)/),c=0;c<b.length-1;c++)!b[c+1]&&b[c+2]&&j.test(b[c])&&j.test(b[c+2])&&(b[c]+=b[c+2],b.splice(c+1,2),c--);return b}},function(a,b){"use strict";function c(a,b){if("function"==typeof a)b.callback=a;else if(a)for(var c in a)a.hasOwnProperty(c)&&(b[c]=a[c]);return b}b.__esModule=!0,b.generateOptions=c},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){return j.diff(a,b,c)}function f(a,b,c){var d=i.generateOptions(c,{ignoreWhitespace:!0});return j.diff(a,b,d)}b.__esModule=!0,b.diffLines=e,b.diffTrimmedLines=f;var g=c(1),h=d(g),i=c(4),j=new h["default"];b.lineDiff=j,j.tokenize=function(a){var b=[],c=a.split(/(\n|\r\n)/);c[c.length-1]||c.pop();for(var d=0;d<c.length;d++){var e=c[d];d%2&&!this.options.newlineIsToken?b[b.length-1]+=e:(this.options.ignoreWhitespace&&(e=e.trim()),b.push(e))}return b}},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){return h.diff(a,b,c)}b.__esModule=!0,b.diffSentences=e;var f=c(1),g=d(f),h=new g["default"];b.sentenceDiff=h,h.tokenize=function(a){return a.split(/(\S.+?[.!?])(?=\s+|$)/)}},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){return h.diff(a,b,c)}b.__esModule=!0,b.diffCss=e;var f=c(1),g=d(f),h=new g["default"];b.cssDiff=h,h.tokenize=function(a){return a.split(/([{}:;,]|\s+)/)}},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b,c){return k.diff(a,b,c)}function f(a,b,c){b=b||[],c=c||[];var d=void 0;for(d=0;d<b.length;d+=1)if(b[d]===a)return c[d];var e=void 0;if("[object Array]"===j.call(a)){for(b.push(a),e=new Array(a.length),c.push(e),d=0;d<a.length;d+=1)e[d]=f(a[d],b,c);b.pop(),c.pop()}else if("object"==typeof a&&null!==a){b.push(a),e={},c.push(e);var g=[],h=void 0;for(h in a)a.hasOwnProperty(h)&&g.push(h);for(g.sort(),d=0;d<g.length;d+=1)h=g[d],e[h]=f(a[h],b,c);b.pop(),c.pop()}else e=a;return e}b.__esModule=!0,b.diffJson=e,b.canonicalize=f;var g=c(1),h=d(g),i=c(5),j=Object.prototype.toString,k=new h["default"];b.jsonDiff=k,k.useLongestToken=!0,k.tokenize=i.lineDiff.tokenize,k.castInput=function(a){return"string"==typeof a?a:JSON.stringify(f(a),void 0,"  ")},k.equals=function(a,b){return h["default"].prototype.equals(a.replace(/,([\r\n])/g,"$1"),b.replace(/,([\r\n])/g,"$1"))}},function(a,b,c){"use strict";function d(a){return a&&a.__esModule?a:{"default":a}}function e(a,b){function c(a,b){for(var c=0;c<a.lines.length;c++){var d=a.lines[c],f=d[0],g=d.substr(1);if(" "===f||"-"===f){if(!h(b+1,e[b],f,g)&&(j++,j>k))return!1;b++}}return!0}var d=arguments.length<=2||void 0===arguments[2]?{}:arguments[2];if("string"==typeof b&&(b=g.parsePatch(b)),Array.isArray(b)){if(b.length>1)throw new Error("applyPatch only works with a single input.");b=b[0]}for(var e=a.split("\n"),f=b.hunks,h=d.compareLine||function(a,b,c,d){return b===d},j=0,k=d.fuzzFactor||0,l=0,m=0,n=void 0,o=void 0,p=0;p<f.length;p++){for(var q=f[p],r=e.length-q.oldLines,s=0,t=m+q.oldStart-1,u=i["default"](t,l,r);void 0!==s;s=u())if(c(q,t+s)){q.offset=m+=s;break}if(void 0===s)return!1;l=q.offset+q.oldStart+q.oldLines}for(var p=0;p<f.length;p++)for(var q=f[p],t=q.offset+q.newStart-1,v=0;v<q.lines.length;v++){var w=q.lines[v],x=w[0],y=w.substr(1);if(" "===x)t++;else if("-"===x)e.splice(t,1);else if("+"===x)e.splice(t,0,y),t++;else if("\\"===x){var z=q.lines[v-1]?q.lines[v-1][0]:null;"+"===z?n=!0:"-"===z&&(o=!0)}}if(n)for(;!e[e.length-1];)e.pop();else o&&e.push("");return e.join("\n")}function f(a,b){function c(){var f=a[d++];return f?void b.loadFile(f,function(a,d){if(a)return b.complete(a);var g=e(d,f,b);b.patched(f,g),setTimeout(c,0)}):b.complete()}"string"==typeof a&&(a=g.parsePatch(a));var d=0;c()}b.__esModule=!0,b.applyPatch=e,b.applyPatches=f;var g=c(10),h=c(11),i=d(h)},function(a,b){"use strict";function c(a){function b(){var a={};for(g.push(a);h<f.length;){var b=f[h];if(/^(\-\-\-|\+\+\+|@@)\s/.test(b))break;var i=/^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(b);i&&(a.index=i[1]),h++}for(c(a),c(a),a.hunks=[];h<f.length;){var b=f[h];if(/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(b))break;if(/^@@/.test(b))a.hunks.push(d());else{if(b&&e.strict)throw new Error("Unknown line "+(h+1)+" "+JSON.stringify(b));h++}}}function c(a){var b=/^(\-\-\-|\+\+\+)\s+(\S+)\s?(.+?)\s*$/.exec(f[h]);if(b){var c="---"===b[1]?"old":"new";a[c+"FileName"]=b[2],a[c+"Header"]=b[3],h++}}function d(){for(var a=h,b=f[h++],c=b.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/),d={oldStart:+c[1],oldLines:+c[2]||1,newStart:+c[3],newLines:+c[4]||1,lines:[]},g=0,i=0;h<f.length;h++){var j=f[h][0];if("+"!==j&&"-"!==j&&" "!==j&&"\\"!==j)break;d.lines.push(f[h]),"+"===j?g++:"-"===j?i++:" "===j&&(g++,i++)}if(g||1!==d.newLines||(d.newLines=0),i||1!==d.oldLines||(d.oldLines=0),e.strict){if(g!==d.newLines)throw new Error("Added line count did not match for hunk at line "+(a+1));if(i!==d.oldLines)throw new Error("Removed line count did not match for hunk at line "+(a+1))}return d}for(var e=arguments.length<=1||void 0===arguments[1]?{}:arguments[1],f=a.split("\n"),g=[],h=0;h<f.length;)b();return g}b.__esModule=!0,b.parsePatch=c},function(a,b){"use strict";b.__esModule=!0,b["default"]=function(a,b,c){var d=!0,e=!1,f=!1,g=1;return function(){for(var h=!0;h;){if(h=!1,d&&!f){if(e?g++:d=!1,c>=a+g)return g;f=!0}if(e);else{if(f||(d=!0),a-g>=b)return-g++;e=!0,h=!0}}}},a.exports=b["default"]},function(a,b,c){"use strict";function d(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}return Array.from(a)}function e(a,b,c,e,f,g,i){function j(a){return a.map(function(a){return" "+a})}i||(i={context:4});var k=h.diffLines(c,e);k.push({value:"",lines:[]});for(var l=[],m=0,n=0,o=[],p=1,q=1,r=function(a){var b=k[a],f=b.lines||b.value.replace(/\n$/,"").split("\n");if(b.lines=f,b.added||b.removed){var g;if(!m){var h=k[a-1];m=p,n=q,h&&(o=i.context>0?j(h.lines.slice(-i.context)):[],m-=o.length,n-=o.length)}(g=o).push.apply(g,d(f.map(function(a){return(b.added?"+":"-")+a}))),b.added?q+=f.length:p+=f.length}else{if(m)if(f.length<=2*i.context&&a<k.length-2){var r;(r=o).push.apply(r,d(j(f)))}else{var s,t=Math.min(f.length,i.context);(s=o).push.apply(s,d(j(f.slice(0,t))));var u={oldStart:m,oldLines:p-m+t,newStart:n,newLines:q-n+t,lines:o};if(a>=k.length-2&&f.length<=i.context){var v=/\n$/.test(c),w=/\n$/.test(e);0!=f.length||v?v&&w||o.push("\\ No newline at end of file"):o.splice(u.oldLines,0,"\\ No newline at end of file")}l.push(u),m=0,n=0,o=[]}p+=f.length,q+=f.length}},s=0;s<k.length;s++)r(s);return{oldFileName:a,newFileName:b,oldHeader:f,newHeader:g,hunks:l}}function f(a,b,c,d,f,g,h){var i=e(a,b,c,d,f,g,h),j=[];a==b&&j.push("Index: "+a),j.push("==================================================================="),j.push("--- "+i.oldFileName+("undefined"==typeof i.oldHeader?"":"	"+i.oldHeader)),j.push("+++ "+i.newFileName+("undefined"==typeof i.newHeader?"":"	"+i.newHeader));for(var k=0;k<i.hunks.length;k++){var l=i.hunks[k];j.push("@@ -"+l.oldStart+","+l.oldLines+" +"+l.newStart+","+l.newLines+" @@"),j.push.apply(j,l.lines)}return j.join("\n")+"\n"}function g(a,b,c,d,e,g){return f(a,a,b,c,d,e,g)}b.__esModule=!0,b.structuredPatch=e,b.createTwoFilesPatch=f,b.createPatch=g;var h=c(5)},function(a,b){"use strict";function c(a){for(var b=[],c=void 0,d=void 0,e=0;e<a.length;e++)c=a[e],d=c.added?1:c.removed?-1:0,b.push([d,c.value]);return b}b.__esModule=!0,b.convertChangesToDMP=c},function(a,b){"use strict";function c(a){for(var b=[],c=0;c<a.length;c++){var e=a[c];e.added?b.push("<ins>"):e.removed&&b.push("<del>"),b.push(d(e.value)),e.added?b.push("</ins>"):e.removed&&b.push("</del>")}return b.join("")}function d(a){var b=a;return b=b.replace(/&/g,"&amp;"),b=b.replace(/</g,"&lt;"),b=b.replace(/>/g,"&gt;"),b=b.replace(/"/g,"&quot;")}b.__esModule=!0,b.convertChangesToXML=c}])});
!function(a,b){if("object"==typeof exports)module.exports=b(require,exports,module);else if("function"==typeof define&&define.amd)define('lib/extend',["require","exports","module"],b);else{var c=function(b){return a[b]},d=a,e={exports:d};a.extend=b(c,d,e)}}(this,function(a,b,c){function d(a,b){"use strict";function c(){}return c.prototype=b.prototype,a.prototype=new c,a.prototype.constructor=a,a.superclass=b.prototype,a.superconstructor=b,a}return d.isSubclass=function(a,b){"use strict";if("function"==typeof b&&"function"==typeof a)for(var c=a;c=c.superconstructor;)if(c===b)return!0;return!1},c.exports=d,d});
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(view){"use strict";if(typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var doc=view.document,get_URL=function(){return view.URL||view.webkitURL||view},save_link=doc.createElementNS("http://www.w3.org/1999/xhtml","a"),can_use_save_link="download"in save_link,click=function(node){var event=new MouseEvent("click");node.dispatchEvent(event)},is_safari=/Version\/[\d\.]+.*Safari/.test(navigator.userAgent),webkit_req_fs=view.webkitRequestFileSystem,req_fs=view.requestFileSystem||webkit_req_fs||view.mozRequestFileSystem,throw_outside=function(ex){(view.setImmediate||view.setTimeout)(function(){throw ex},0)},force_saveable_type="application/octet-stream",fs_min_size=0,arbitrary_revoke_timeout=500,revoke=function(file){var revoker=function(){if(typeof file==="string"){get_URL().revokeObjectURL(file)}else{file.remove()}};if(view.chrome){revoker()}else{setTimeout(revoker,arbitrary_revoke_timeout)}},dispatch=function(filesaver,event_types,event){event_types=[].concat(event_types);var i=event_types.length;while(i--){var listener=filesaver["on"+event_types[i]];if(typeof listener==="function"){try{listener.call(filesaver,event||filesaver)}catch(ex){throw_outside(ex)}}}},auto_bom=function(blob){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)){return new Blob(["\ufeff",blob],{type:blob.type})}return blob},FileSaver=function(blob,name,no_auto_bom){if(!no_auto_bom){blob=auto_bom(blob)}var filesaver=this,type=blob.type,blob_changed=false,object_url,target_view,dispatch_all=function(){dispatch(filesaver,"writestart progress write writeend".split(" "))},fs_error=function(){if(target_view&&is_safari&&typeof FileReader!=="undefined"){var reader=new FileReader;reader.onloadend=function(){var base64Data=reader.result;target_view.location.href="data:attachment/file"+base64Data.slice(base64Data.search(/[,;]/));filesaver.readyState=filesaver.DONE;dispatch_all()};reader.readAsDataURL(blob);filesaver.readyState=filesaver.INIT;return}if(blob_changed||!object_url){object_url=get_URL().createObjectURL(blob)}if(target_view){target_view.location.href=object_url}else{var new_tab=view.open(object_url,"_blank");if(new_tab==undefined&&is_safari){view.location.href=object_url}}filesaver.readyState=filesaver.DONE;dispatch_all();revoke(object_url)},abortable=function(func){return function(){if(filesaver.readyState!==filesaver.DONE){return func.apply(this,arguments)}}},create_if_not_found={create:true,exclusive:false},slice;filesaver.readyState=filesaver.INIT;if(!name){name="download"}if(can_use_save_link){object_url=get_URL().createObjectURL(blob);setTimeout(function(){save_link.href=object_url;save_link.download=name;click(save_link);dispatch_all();revoke(object_url);filesaver.readyState=filesaver.DONE});return}if(view.chrome&&type&&type!==force_saveable_type){slice=blob.slice||blob.webkitSlice;blob=slice.call(blob,0,blob.size,force_saveable_type);blob_changed=true}if(webkit_req_fs&&name!=="download"){name+=".download"}if(type===force_saveable_type||webkit_req_fs){target_view=view}if(!req_fs){fs_error();return}fs_min_size+=blob.size;req_fs(view.TEMPORARY,fs_min_size,abortable(function(fs){fs.root.getDirectory("saved",create_if_not_found,abortable(function(dir){var save=function(){dir.getFile(name,create_if_not_found,abortable(function(file){file.createWriter(abortable(function(writer){writer.onwriteend=function(event){target_view.location.href=file.toURL();filesaver.readyState=filesaver.DONE;dispatch(filesaver,"writeend",event);revoke(file)};writer.onerror=function(){var error=writer.error;if(error.code!==error.ABORT_ERR){fs_error()}};"writestart progress write abort".split(" ").forEach(function(event){writer["on"+event]=filesaver["on"+event]});writer.write(blob);filesaver.abort=function(){writer.abort();filesaver.readyState=filesaver.DONE};filesaver.readyState=filesaver.WRITING}),fs_error)}),fs_error)};dir.getFile(name,{create:false},abortable(function(file){file.remove();save()}),abortable(function(ex){if(ex.code===ex.NOT_FOUND_ERR){save()}else{fs_error()}}))}),fs_error)}),fs_error)},FS_proto=FileSaver.prototype,saveAs=function(blob,name,no_auto_bom){return new FileSaver(blob,name,no_auto_bom)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(blob,name,no_auto_bom){if(!no_auto_bom){blob=auto_bom(blob)}return navigator.msSaveOrOpenBlob(blob,name||"download")}}FS_proto.abort=function(){var filesaver=this;filesaver.readyState=filesaver.DONE;dispatch(filesaver,"abort")};FS_proto.readyState=FS_proto.INIT=0;FS_proto.WRITING=1;FS_proto.DONE=2;FS_proto.error=FS_proto.onwritestart=FS_proto.onprogress=FS_proto.onwrite=FS_proto.onabort=FS_proto.onerror=FS_proto.onwriteend=null;return saveAs}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!=null){define('lib/FileSaver',[],function(){return saveAs})}
;
/*! jQuery v1.12.0 | (c) jQuery Foundation | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=a.document,e=c.slice,f=c.concat,g=c.push,h=c.indexOf,i={},j=i.toString,k=i.hasOwnProperty,l={},m="1.12.0",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return e.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:e.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a){return n.each(this,a)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(e.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:g,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(e=arguments[h]))for(d in e)a=g[d],c=e[d],g!==c&&(j&&c&&(n.isPlainObject(c)||(b=n.isArray(c)))?(b?(b=!1,f=a&&n.isArray(a)?a:[]):f=a&&n.isPlainObject(a)?a:{},g[d]=n.extend(j,f,c)):void 0!==c&&(g[d]=c));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray||function(a){return"array"===n.type(a)},isWindow:function(a){return null!=a&&a==a.window},isNumeric:function(a){var b=a&&a.toString();return!n.isArray(a)&&b-parseFloat(b)+1>=0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},isPlainObject:function(a){var b;if(!a||"object"!==n.type(a)||a.nodeType||n.isWindow(a))return!1;try{if(a.constructor&&!k.call(a,"constructor")&&!k.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}if(!l.ownFirst)for(b in a)return k.call(a,b);for(b in a);return void 0===b||k.call(a,b)},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?i[j.call(a)]||"object":typeof a},globalEval:function(b){b&&n.trim(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b){var c,d=0;if(s(a)){for(c=a.length;c>d;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):g.call(c,a)),c},inArray:function(a,b,c){var d;if(b){if(h)return h.call(b,a,c);for(d=b.length,c=c?0>c?Math.max(0,d+c):c:0;d>c;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,b){var c=+b.length,d=0,e=a.length;while(c>d)a[e++]=b[d++];if(c!==c)while(void 0!==b[d])a[e++]=b[d++];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,g=0,h=[];if(s(a))for(d=a.length;d>g;g++)e=b(a[g],g,c),null!=e&&h.push(e);else for(g in a)e=b(a[g],g,c),null!=e&&h.push(e);return f.apply([],h)},guid:1,proxy:function(a,b){var c,d,f;return"string"==typeof b&&(f=a[b],b=a,a=f),n.isFunction(a)?(c=e.call(arguments,2),d=function(){return a.apply(b||this,c.concat(e.call(arguments)))},d.guid=a.guid=a.guid||n.guid++,d):void 0},now:function(){return+new Date},support:l}),"function"==typeof Symbol&&(n.fn[Symbol.iterator]=c[Symbol.iterator]),n.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){i["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=!!a&&"length"in a&&a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ga(),z=ga(),A=ga(),B=function(a,b){return a===b&&(l=!0),0},C=1<<31,D={}.hasOwnProperty,E=[],F=E.pop,G=E.push,H=E.push,I=E.slice,J=function(a,b){for(var c=0,d=a.length;d>c;c++)if(a[c]===b)return c;return-1},K="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",L="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",N="\\["+L+"*("+M+")(?:"+L+"*([*^$|!~]?=)"+L+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+M+"))|)"+L+"*\\]",O=":("+M+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+N+")*)|.*)\\)|)",P=new RegExp(L+"+","g"),Q=new RegExp("^"+L+"+|((?:^|[^\\\\])(?:\\\\.)*)"+L+"+$","g"),R=new RegExp("^"+L+"*,"+L+"*"),S=new RegExp("^"+L+"*([>+~]|"+L+")"+L+"*"),T=new RegExp("="+L+"*([^\\]'\"]*?)"+L+"*\\]","g"),U=new RegExp(O),V=new RegExp("^"+M+"$"),W={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),TAG:new RegExp("^("+M+"|[*])"),ATTR:new RegExp("^"+N),PSEUDO:new RegExp("^"+O),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+L+"*(even|odd|(([+-]|)(\\d*)n|)"+L+"*(?:([+-]|)"+L+"*(\\d+)|))"+L+"*\\)|)","i"),bool:new RegExp("^(?:"+K+")$","i"),needsContext:new RegExp("^"+L+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+L+"*((?:-\\d)?\\d*)"+L+"*\\)|)(?=[^-]|$)","i")},X=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,$=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,_=/[+~]/,aa=/'|\\/g,ba=new RegExp("\\\\([\\da-f]{1,6}"+L+"?|("+L+")|.)","ig"),ca=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},da=function(){m()};try{H.apply(E=I.call(v.childNodes),v.childNodes),E[v.childNodes.length].nodeType}catch(ea){H={apply:E.length?function(a,b){G.apply(a,I.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fa(a,b,d,e){var f,h,j,k,l,o,r,s,w=b&&b.ownerDocument,x=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==x&&9!==x&&11!==x)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==x&&(o=$.exec(a)))if(f=o[1]){if(9===x){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(w&&(j=w.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(o[2])return H.apply(d,b.getElementsByTagName(a)),d;if((f=o[3])&&c.getElementsByClassName&&b.getElementsByClassName)return H.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==x)w=b,s=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(aa,"\\$&"):b.setAttribute("id",k=u),r=g(a),h=r.length,l=V.test(k)?"#"+k:"[id='"+k+"']";while(h--)r[h]=l+" "+qa(r[h]);s=r.join(","),w=_.test(a)&&oa(b.parentNode)||b}if(s)try{return H.apply(d,w.querySelectorAll(s)),d}catch(y){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(Q,"$1"),b,d,e)}function ga(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ha(a){return a[u]=!0,a}function ia(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ja(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function ka(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||C)-(~a.sourceIndex||C);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function la(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function na(a){return ha(function(b){return b=+b,ha(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function oa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=fa.support={},f=fa.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fa.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ia(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ia(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Z.test(n.getElementsByClassName),c.getById=ia(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}},d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(ba,ca);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return"undefined"!=typeof b.getElementsByClassName&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=Z.test(n.querySelectorAll))&&(ia(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+L+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+L+"*(?:value|"+K+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ia(function(a){var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+L+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Z.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ia(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",O)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Z.test(o.compareDocumentPosition),t=b||Z.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?J(k,a)-J(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?J(k,a)-J(k,b):0;if(e===f)return ka(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?ka(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},fa.matches=function(a,b){return fa(a,null,null,b)},fa.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(T,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fa(b,n,null,[a]).length>0},fa.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fa.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&D.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fa.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fa.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fa.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fa.selectors={cacheLength:50,createPseudo:ha,match:W,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(ba,ca),a[3]=(a[3]||a[4]||a[5]||"").replace(ba,ca),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fa.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fa.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return W.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&U.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(ba,ca).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+L+")"+a+"("+L+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fa.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(P," ")+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fa.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ha(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=J(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ha(function(a){var b=[],c=[],d=h(a.replace(Q,"$1"));return d[u]?ha(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ha(function(a){return function(b){return fa(a,b).length>0}}),contains:ha(function(a){return a=a.replace(ba,ca),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ha(function(a){return V.test(a||"")||fa.error("unsupported lang: "+a),a=a.replace(ba,ca).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Y.test(a.nodeName)},input:function(a){return X.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:na(function(){return[0]}),last:na(function(a,b){return[b-1]}),eq:na(function(a,b,c){return[0>c?c+b:c]}),even:na(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:na(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:na(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:na(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=la(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=ma(b);function pa(){}pa.prototype=d.filters=d.pseudos,d.setFilters=new pa,g=fa.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=R.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=S.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(Q," ")}),h=h.slice(c.length));for(g in d.filter)!(e=W[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fa.error(a):z(a,i).slice(0)};function qa(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function ra(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j,k=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(j=b[u]||(b[u]={}),i=j[b.uniqueID]||(j[b.uniqueID]={}),(h=i[d])&&h[0]===w&&h[1]===f)return k[2]=h[2];if(i[d]=k,k[2]=a(b,c,g))return!0}}}function sa(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function ta(a,b,c){for(var d=0,e=b.length;e>d;d++)fa(a,b[d],c);return c}function ua(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function va(a,b,c,d,e,f){return d&&!d[u]&&(d=va(d)),e&&!e[u]&&(e=va(e,f)),ha(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||ta(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ua(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ua(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?J(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ua(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):H.apply(g,r)})}function wa(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ra(function(a){return a===b},h,!0),l=ra(function(a){return J(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];f>i;i++)if(c=d.relative[a[i].type])m=[ra(sa(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return va(i>1&&sa(m),i>1&&qa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(Q,"$1"),c,e>i&&wa(a.slice(i,e)),f>e&&wa(a=a.slice(e)),f>e&&qa(a))}m.push(c)}return sa(m)}function xa(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=F.call(i));u=ua(u)}H.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&fa.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ha(f):f}return h=fa.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wa(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xa(e,d)),f.selector=a}return f},i=fa.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(ba,ca),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=W.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(ba,ca),_.test(j[0].type)&&oa(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qa(j),!a)return H.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,!b||_.test(a)&&oa(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ia(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ia(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ja("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ia(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ja("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ia(function(a){return null==a.getAttribute("disabled")})||ja(K,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fa}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.uniqueSort=n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},v=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},w=n.expr.match.needsContext,x=/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,y=/^.[^:#\[\.,]*$/;function z(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(y.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return n.inArray(a,b)>-1!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=[],d=this,e=d.length;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;e>b;b++)if(n.contains(d[b],this))return!0}));for(b=0;e>b;b++)n.find(a,d[b],c);return c=this.pushStack(e>1?n.unique(c):c),c.selector=this.selector?this.selector+" "+a:a,c},filter:function(a){return this.pushStack(z(this,a||[],!1))},not:function(a){return this.pushStack(z(this,a||[],!0))},is:function(a){return!!z(this,"string"==typeof a&&w.test(a)?n(a):a||[],!1).length}});var A,B=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=n.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||A,"string"==typeof a){if(e="<"===a.charAt(0)&&">"===a.charAt(a.length-1)&&a.length>=3?[null,a,null]:B.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),x.test(e[1])&&n.isPlainObject(b))for(e in b)n.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}if(f=d.getElementById(e[2]),f&&f.parentNode){if(f.id!==e[2])return A.find(a);this.length=1,this[0]=f}return this.context=d,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof c.ready?c.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};C.prototype=n.fn,A=n(d);var D=/^(?:parents|prev(?:Until|All))/,E={children:!0,contents:!0,next:!0,prev:!0};n.fn.extend({has:function(a){var b,c=n(a,this),d=c.length;return this.filter(function(){for(b=0;d>b;b++)if(n.contains(this,c[b]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=w.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?n.inArray(this[0],n(a)):n.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.uniqueSort(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function F(a,b){do a=a[b];while(a&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return u(a,"parentNode")},parentsUntil:function(a,b,c){return u(a,"parentNode",c)},next:function(a){return F(a,"nextSibling")},prev:function(a){return F(a,"previousSibling")},nextAll:function(a){return u(a,"nextSibling")},prevAll:function(a){return u(a,"previousSibling")},nextUntil:function(a,b,c){return u(a,"nextSibling",c)},prevUntil:function(a,b,c){return u(a,"previousSibling",c)},siblings:function(a){return v((a.parentNode||{}).firstChild,a)},children:function(a){return v(a.firstChild)},contents:function(a){return n.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(E[a]||(e=n.uniqueSort(e)),D.test(a)&&(e=e.reverse())),this.pushStack(e)}});var G=/\S+/g;function H(a){var b={};return n.each(a.match(G)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?H(a):n.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){n.each(b,function(b,c){n.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==n.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return n.each(arguments,function(a,b){var c;while((c=n.inArray(b,f,c))>-1)f.splice(c,1),h>=c&&h--}),this},has:function(a){return a?n.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=!0,c||j.disable(),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().progress(c.notify).done(c.resolve).fail(c.reject):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=e.call(arguments),d=c.length,f=1!==d||a&&n.isFunction(a.promise)?d:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?e.call(arguments):d,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(d>1)for(i=new Array(d),j=new Array(d),k=new Array(d);d>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().progress(h(b,j,i)).done(h(b,k,c)).fail(g.reject):--f;return f||g.resolveWith(k,c),g.promise()}});var I;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(I.resolveWith(d,[n]),n.fn.triggerHandler&&(n(d).triggerHandler("ready"),n(d).off("ready"))))}});function J(){d.addEventListener?(d.removeEventListener("DOMContentLoaded",K),a.removeEventListener("load",K)):(d.detachEvent("onreadystatechange",K),a.detachEvent("onload",K))}function K(){(d.addEventListener||"load"===a.event.type||"complete"===d.readyState)&&(J(),n.ready())}n.ready.promise=function(b){if(!I)if(I=n.Deferred(),"complete"===d.readyState)a.setTimeout(n.ready);else if(d.addEventListener)d.addEventListener("DOMContentLoaded",K),a.addEventListener("load",K);else{d.attachEvent("onreadystatechange",K),a.attachEvent("onload",K);var c=!1;try{c=null==a.frameElement&&d.documentElement}catch(e){}c&&c.doScroll&&!function f(){if(!n.isReady){try{c.doScroll("left")}catch(b){return a.setTimeout(f,50)}J(),n.ready()}}()}return I.promise(b)},n.ready.promise();var L;for(L in n(l))break;l.ownFirst="0"===L,l.inlineBlockNeedsLayout=!1,n(function(){var a,b,c,e;c=d.getElementsByTagName("body")[0],c&&c.style&&(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1",l.inlineBlockNeedsLayout=a=3===b.offsetWidth,a&&(c.style.zoom=1)),c.removeChild(e))}),function(){var a=d.createElement("div");l.deleteExpando=!0;try{delete a.test}catch(b){l.deleteExpando=!1}a=null}();var M=function(a){var b=n.noData[(a.nodeName+" ").toLowerCase()],c=+a.nodeType||1;return 1!==c&&9!==c?!1:!b||b!==!0&&a.getAttribute("classid")===b},N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){if(void 0===c&&1===a.nodeType){var d="data-"+b.replace(O,"-$1").toLowerCase();if(c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}n.data(a,b,c)}else c=void 0}return c}function Q(a){var b;for(b in a)if(("data"!==b||!n.isEmptyObject(a[b]))&&"toJSON"!==b)return!1;
return!0}function R(a,b,d,e){if(M(a)){var f,g,h=n.expando,i=a.nodeType,j=i?n.cache:a,k=i?a[h]:a[h]&&h;if(k&&j[k]&&(e||j[k].data)||void 0!==d||"string"!=typeof b)return k||(k=i?a[h]=c.pop()||n.guid++:h),j[k]||(j[k]=i?{}:{toJSON:n.noop}),("object"==typeof b||"function"==typeof b)&&(e?j[k]=n.extend(j[k],b):j[k].data=n.extend(j[k].data,b)),g=j[k],e||(g.data||(g.data={}),g=g.data),void 0!==d&&(g[n.camelCase(b)]=d),"string"==typeof b?(f=g[b],null==f&&(f=g[n.camelCase(b)])):f=g,f}}function S(a,b,c){if(M(a)){var d,e,f=a.nodeType,g=f?n.cache:a,h=f?a[n.expando]:n.expando;if(g[h]){if(b&&(d=c?g[h]:g[h].data)){n.isArray(b)?b=b.concat(n.map(b,n.camelCase)):b in d?b=[b]:(b=n.camelCase(b),b=b in d?[b]:b.split(" ")),e=b.length;while(e--)delete d[b[e]];if(c?!Q(d):!n.isEmptyObject(d))return}(c||(delete g[h].data,Q(g[h])))&&(f?n.cleanData([a],!0):l.deleteExpando||g!=g.window?delete g[h]:g[h]=void 0)}}}n.extend({cache:{},noData:{"applet ":!0,"embed ":!0,"object ":"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"},hasData:function(a){return a=a.nodeType?n.cache[a[n.expando]]:a[n.expando],!!a&&!Q(a)},data:function(a,b,c){return R(a,b,c)},removeData:function(a,b){return S(a,b)},_data:function(a,b,c){return R(a,b,c,!0)},_removeData:function(a,b){return S(a,b,!0)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=n.data(f),1===f.nodeType&&!n._data(f,"parsedAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));n._data(f,"parsedAttrs",!0)}return e}return"object"==typeof a?this.each(function(){n.data(this,a)}):arguments.length>1?this.each(function(){n.data(this,a,b)}):f?P(f,a,n.data(f,a)):void 0},removeData:function(a){return this.each(function(){n.removeData(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=n._data(a,b),c&&(!d||n.isArray(c)?d=n._data(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return n._data(a,c)||n._data(a,c,{empty:n.Callbacks("once memory").add(function(){n._removeData(a,b+"queue"),n._removeData(a,c)})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=n._data(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}}),function(){var a;l.shrinkWrapBlocks=function(){if(null!=a)return a;a=!1;var b,c,e;return c=d.getElementsByTagName("body")[0],c&&c.style?(b=d.createElement("div"),e=d.createElement("div"),e.style.cssText="position:absolute;border:0;width:0;height:0;top:0;left:-9999px",c.appendChild(e).appendChild(b),"undefined"!=typeof b.style.zoom&&(b.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1",b.appendChild(d.createElement("div")).style.width="5px",a=3!==b.offsetWidth),c.removeChild(e),a):void 0}}();var T=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,U=new RegExp("^(?:([+-])=|)("+T+")([a-z%]*)$","i"),V=["Top","Right","Bottom","Left"],W=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)};function X(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return n.css(a,b,"")},i=h(),j=c&&c[3]||(n.cssNumber[b]?"":"px"),k=(n.cssNumber[b]||"px"!==j&&+i)&&U.exec(n.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,n.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var Y=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)Y(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},Z=/^(?:checkbox|radio)$/i,$=/<([\w:-]+)/,_=/^$|\/(?:java|ecma)script/i,aa=/^\s+/,ba="abbr|article|aside|audio|bdi|canvas|data|datalist|details|dialog|figcaption|figure|footer|header|hgroup|main|mark|meter|nav|output|picture|progress|section|summary|template|time|video";function ca(a){var b=ba.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}!function(){var a=d.createElement("div"),b=d.createDocumentFragment(),c=d.createElement("input");a.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",l.leadingWhitespace=3===a.firstChild.nodeType,l.tbody=!a.getElementsByTagName("tbody").length,l.htmlSerialize=!!a.getElementsByTagName("link").length,l.html5Clone="<:nav></:nav>"!==d.createElement("nav").cloneNode(!0).outerHTML,c.type="checkbox",c.checked=!0,b.appendChild(c),l.appendChecked=c.checked,a.innerHTML="<textarea>x</textarea>",l.noCloneChecked=!!a.cloneNode(!0).lastChild.defaultValue,b.appendChild(a),c=d.createElement("input"),c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),a.appendChild(c),l.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,l.noCloneEvent=!!a.addEventListener,a[n.expando]=1,l.attributes=!a.getAttribute(n.expando)}();var da={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:l.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]};da.optgroup=da.option,da.tbody=da.tfoot=da.colgroup=da.caption=da.thead,da.th=da.td;function ea(a,b){var c,d,e=0,f="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):void 0;if(!f)for(f=[],c=a.childNodes||a;null!=(d=c[e]);e++)!b||n.nodeName(d,b)?f.push(d):n.merge(f,ea(d,b));return void 0===b||b&&n.nodeName(a,b)?n.merge([a],f):f}function fa(a,b){for(var c,d=0;null!=(c=a[d]);d++)n._data(c,"globalEval",!b||n._data(b[d],"globalEval"))}var ga=/<|&#?\w+;/,ha=/<tbody/i;function ia(a){Z.test(a.type)&&(a.defaultChecked=a.checked)}function ja(a,b,c,d,e){for(var f,g,h,i,j,k,m,o=a.length,p=ca(b),q=[],r=0;o>r;r++)if(g=a[r],g||0===g)if("object"===n.type(g))n.merge(q,g.nodeType?[g]:g);else if(ga.test(g)){i=i||p.appendChild(b.createElement("div")),j=($.exec(g)||["",""])[1].toLowerCase(),m=da[j]||da._default,i.innerHTML=m[1]+n.htmlPrefilter(g)+m[2],f=m[0];while(f--)i=i.lastChild;if(!l.leadingWhitespace&&aa.test(g)&&q.push(b.createTextNode(aa.exec(g)[0])),!l.tbody){g="table"!==j||ha.test(g)?"<table>"!==m[1]||ha.test(g)?0:i:i.firstChild,f=g&&g.childNodes.length;while(f--)n.nodeName(k=g.childNodes[f],"tbody")&&!k.childNodes.length&&g.removeChild(k)}n.merge(q,i.childNodes),i.textContent="";while(i.firstChild)i.removeChild(i.firstChild);i=p.lastChild}else q.push(b.createTextNode(g));i&&p.removeChild(i),l.appendChecked||n.grep(ea(q,"input"),ia),r=0;while(g=q[r++])if(d&&n.inArray(g,d)>-1)e&&e.push(g);else if(h=n.contains(g.ownerDocument,g),i=ea(p.appendChild(g),"script"),h&&fa(i),c){f=0;while(g=i[f++])_.test(g.type||"")&&c.push(g)}return i=null,p}!function(){var b,c,e=d.createElement("div");for(b in{submit:!0,change:!0,focusin:!0})c="on"+b,(l[b]=c in a)||(e.setAttribute(c,"t"),l[b]=e.attributes[c].expando===!1);e=null}();var ka=/^(?:input|select|textarea)$/i,la=/^key/,ma=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,na=/^(?:focusinfocus|focusoutblur)$/,oa=/^([^.]*)(?:\.(.+)|)/;function pa(){return!0}function qa(){return!1}function ra(){try{return d.activeElement}catch(a){}}function sa(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)sa(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=qa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return n().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=n.guid++)),a.each(function(){n.event.add(this,b,e,d,c)})}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n._data(a);if(r){c.handler&&(i=c,c=i.handler,e=i.selector),c.guid||(c.guid=n.guid++),(g=r.events)||(g=r.events={}),(k=r.handle)||(k=r.handle=function(a){return"undefined"==typeof n||a&&n.event.triggered===a.type?void 0:n.event.dispatch.apply(k.elem,arguments)},k.elem=a),b=(b||"").match(G)||[""],h=b.length;while(h--)f=oa.exec(b[h])||[],o=q=f[1],p=(f[2]||"").split(".").sort(),o&&(j=n.event.special[o]||{},o=(e?j.delegateType:j.bindType)||o,j=n.event.special[o]||{},l=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},i),(m=g[o])||(m=g[o]=[],m.delegateCount=0,j.setup&&j.setup.call(a,d,p,k)!==!1||(a.addEventListener?a.addEventListener(o,k,!1):a.attachEvent&&a.attachEvent("on"+o,k))),j.add&&(j.add.call(a,l),l.handler.guid||(l.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,l):m.push(l),n.event.global[o]=!0);a=null}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=n.hasData(a)&&n._data(a);if(r&&(k=r.events)){b=(b||"").match(G)||[""],j=b.length;while(j--)if(h=oa.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=k[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),i=f=m.length;while(f--)g=m[f],!e&&q!==g.origType||c&&c.guid!==g.guid||h&&!h.test(g.namespace)||d&&d!==g.selector&&("**"!==d||!g.selector)||(m.splice(f,1),g.selector&&m.delegateCount--,l.remove&&l.remove.call(a,g));i&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete k[o])}else for(o in k)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(k)&&(delete r.handle,n._removeData(a,"events"))}},trigger:function(b,c,e,f){var g,h,i,j,l,m,o,p=[e||d],q=k.call(b,"type")?b.type:b,r=k.call(b,"namespace")?b.namespace.split("."):[];if(i=m=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!na.test(q+n.event.triggered)&&(q.indexOf(".")>-1&&(r=q.split("."),q=r.shift(),r.sort()),h=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=r.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:n.makeArray(c,[b]),l=n.event.special[q]||{},f||!l.trigger||l.trigger.apply(e,c)!==!1)){if(!f&&!l.noBubble&&!n.isWindow(e)){for(j=l.delegateType||q,na.test(j+q)||(i=i.parentNode);i;i=i.parentNode)p.push(i),m=i;m===(e.ownerDocument||d)&&p.push(m.defaultView||m.parentWindow||a)}o=0;while((i=p[o++])&&!b.isPropagationStopped())b.type=o>1?j:l.bindType||q,g=(n._data(i,"events")||{})[b.type]&&n._data(i,"handle"),g&&g.apply(i,c),g=h&&i[h],g&&g.apply&&M(i)&&(b.result=g.apply(i,c),b.result===!1&&b.preventDefault());if(b.type=q,!f&&!b.isDefaultPrevented()&&(!l._default||l._default.apply(p.pop(),c)===!1)&&M(e)&&h&&e[q]&&!n.isWindow(e)){m=e[h],m&&(e[h]=null),n.event.triggered=q;try{e[q]()}catch(s){}n.event.triggered=void 0,m&&(e[h]=m)}return b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,d,f,g,h=[],i=e.call(arguments),j=(n._data(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.rnamespace||a.rnamespace.test(g.namespace))&&(a.handleObj=g,a.data=g.data,d=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==d&&(a.result=d)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&("click"!==a.type||isNaN(a.button)||a.button<1))for(;i!=this;i=i.parentNode||this)if(1===i.nodeType&&(i.disabled!==!0||"click"!==a.type)){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>-1:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},fix:function(a){if(a[n.expando])return a;var b,c,e,f=a.type,g=a,h=this.fixHooks[f];h||(this.fixHooks[f]=h=ma.test(f)?this.mouseHooks:la.test(f)?this.keyHooks:{}),e=h.props?this.props.concat(h.props):this.props,a=new n.Event(g),b=e.length;while(b--)c=e[b],a[c]=g[c];return a.target||(a.target=g.srcElement||d),3===a.target.nodeType&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,h.filter?h.filter(a,g):a},props:"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,e,f,g=b.button,h=b.fromElement;return null==a.pageX&&null!=b.clientX&&(e=a.target.ownerDocument||d,f=e.documentElement,c=e.body,a.pageX=b.clientX+(f&&f.scrollLeft||c&&c.scrollLeft||0)-(f&&f.clientLeft||c&&c.clientLeft||0),a.pageY=b.clientY+(f&&f.scrollTop||c&&c.scrollTop||0)-(f&&f.clientTop||c&&c.clientTop||0)),!a.relatedTarget&&h&&(a.relatedTarget=h===a.target?b.toElement:h),a.which||void 0===g||(a.which=1&g?1:2&g?3:4&g?2:0),a}},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==ra()&&this.focus)try{return this.focus(),!1}catch(a){}},delegateType:"focusin"},blur:{trigger:function(){return this===ra()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return n.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c){var d=n.extend(new n.Event,c,{type:a,isSimulated:!0});n.event.trigger(d,null,b),d.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=d.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)}:function(a,b,c){var d="on"+b;a.detachEvent&&("undefined"==typeof a[d]&&(a[d]=null),a.detachEvent(d,c))},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?pa:qa):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={constructor:n.Event,isDefaultPrevented:qa,isPropagationStopped:qa,isImmediatePropagationStopped:qa,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=pa,a&&(a.preventDefault?a.preventDefault():a.returnValue=!1)},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=pa,a&&!this.isSimulated&&(a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0)},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=pa,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),l.submit||(n.event.special.submit={setup:function(){return n.nodeName(this,"form")?!1:void n.event.add(this,"click._submit keypress._submit",function(a){var b=a.target,c=n.nodeName(b,"input")||n.nodeName(b,"button")?n.prop(b,"form"):void 0;c&&!n._data(c,"submit")&&(n.event.add(c,"submit._submit",function(a){a._submitBubble=!0}),n._data(c,"submit",!0))})},postDispatch:function(a){a._submitBubble&&(delete a._submitBubble,this.parentNode&&!a.isTrigger&&n.event.simulate("submit",this.parentNode,a))},teardown:function(){return n.nodeName(this,"form")?!1:void n.event.remove(this,"._submit")}}),l.change||(n.event.special.change={setup:function(){return ka.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(n.event.add(this,"propertychange._change",function(a){"checked"===a.originalEvent.propertyName&&(this._justChanged=!0)}),n.event.add(this,"click._change",function(a){this._justChanged&&!a.isTrigger&&(this._justChanged=!1),n.event.simulate("change",this,a)})),!1):void n.event.add(this,"beforeactivate._change",function(a){var b=a.target;ka.test(b.nodeName)&&!n._data(b,"change")&&(n.event.add(b,"change._change",function(a){!this.parentNode||a.isSimulated||a.isTrigger||n.event.simulate("change",this.parentNode,a)}),n._data(b,"change",!0))})},handle:function(a){var b=a.target;return this!==b||a.isSimulated||a.isTrigger||"radio"!==b.type&&"checkbox"!==b.type?a.handleObj.handler.apply(this,arguments):void 0},teardown:function(){return n.event.remove(this,"._change"),!ka.test(this.nodeName)}}),l.focusin||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a))};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=n._data(d,b);e||d.addEventListener(a,c,!0),n._data(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=n._data(d,b)-1;e?n._data(d,b,e):(d.removeEventListener(a,c,!0),n._removeData(d,b))}}}),n.fn.extend({on:function(a,b,c,d){return sa(this,a,b,c,d)},one:function(a,b,c,d){return sa(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=qa),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ta=/ jQuery\d+="(?:null|\d+)"/g,ua=new RegExp("<(?:"+ba+")[\\s/>]","i"),va=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,wa=/<script|<style|<link/i,xa=/checked\s*(?:[^=]|=\s*.checked.)/i,ya=/^true\/(.*)/,za=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,Aa=ca(d),Ba=Aa.appendChild(d.createElement("div"));function Ca(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function Da(a){return a.type=(null!==n.find.attr(a,"type"))+"/"+a.type,a}function Ea(a){var b=ya.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Fa(a,b){if(1===b.nodeType&&n.hasData(a)){var c,d,e,f=n._data(a),g=n._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;e>d;d++)n.event.add(b,c,h[c][d])}g.data&&(g.data=n.extend({},g.data))}}function Ga(a,b){var c,d,e;if(1===b.nodeType){if(c=b.nodeName.toLowerCase(),!l.noCloneEvent&&b[n.expando]){e=n._data(b);for(d in e.events)n.removeEvent(b,d,e.handle);b.removeAttribute(n.expando)}"script"===c&&b.text!==a.text?(Da(b).text=a.text,Ea(b)):"object"===c?(b.parentNode&&(b.outerHTML=a.outerHTML),l.html5Clone&&a.innerHTML&&!n.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):"input"===c&&Z.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):"option"===c?b.defaultSelected=b.selected=a.defaultSelected:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}}function Ha(a,b,c,d){b=f.apply([],b);var e,g,h,i,j,k,m=0,o=a.length,p=o-1,q=b[0],r=n.isFunction(q);if(r||o>1&&"string"==typeof q&&!l.checkClone&&xa.test(q))return a.each(function(e){var f=a.eq(e);r&&(b[0]=q.call(this,e,f.html())),Ha(f,b,c,d)});if(o&&(k=ja(b,a[0].ownerDocument,!1,a,d),e=k.firstChild,1===k.childNodes.length&&(k=e),e||d)){for(i=n.map(ea(k,"script"),Da),h=i.length;o>m;m++)g=k,m!==p&&(g=n.clone(g,!0,!0),h&&n.merge(i,ea(g,"script"))),c.call(a[m],g,m);if(h)for(j=i[i.length-1].ownerDocument,n.map(i,Ea),m=0;h>m;m++)g=i[m],_.test(g.type||"")&&!n._data(g,"globalEval")&&n.contains(j,g)&&(g.src?n._evalUrl&&n._evalUrl(g.src):n.globalEval((g.text||g.textContent||g.innerHTML||"").replace(za,"")));k=e=null}return a}function Ia(a,b,c){for(var d,e=b?n.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||n.cleanData(ea(d)),d.parentNode&&(c&&n.contains(d.ownerDocument,d)&&fa(ea(d,"script")),d.parentNode.removeChild(d));return a}n.extend({htmlPrefilter:function(a){return a.replace(va,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h,i=n.contains(a.ownerDocument,a);if(l.html5Clone||n.isXMLDoc(a)||!ua.test("<"+a.nodeName+">")?f=a.cloneNode(!0):(Ba.innerHTML=a.outerHTML,Ba.removeChild(f=Ba.firstChild)),!(l.noCloneEvent&&l.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(d=ea(f),h=ea(a),g=0;null!=(e=h[g]);++g)d[g]&&Ga(e,d[g]);if(b)if(c)for(h=h||ea(a),d=d||ea(f),g=0;null!=(e=h[g]);g++)Fa(e,d[g]);else Fa(a,f);return d=ea(f,"script"),d.length>0&&fa(d,!i&&ea(a,"script")),d=h=e=null,f},cleanData:function(a,b){for(var d,e,f,g,h=0,i=n.expando,j=n.cache,k=l.attributes,m=n.event.special;null!=(d=a[h]);h++)if((b||M(d))&&(f=d[i],g=f&&j[f])){if(g.events)for(e in g.events)m[e]?n.event.remove(d,e):n.removeEvent(d,e,g.handle);j[f]&&(delete j[f],k||"undefined"==typeof d.removeAttribute?d[i]=void 0:d.removeAttribute(i),c.push(f))}}}),n.fn.extend({domManip:Ha,detach:function(a){return Ia(this,a,!0)},remove:function(a){return Ia(this,a)},text:function(a){return Y(this,function(a){return void 0===a?n.text(this):this.empty().append((this[0]&&this[0].ownerDocument||d).createTextNode(a))},null,a,arguments.length)},append:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.appendChild(a)}})},prepend:function(){return Ha(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ca(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ha(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++){1===a.nodeType&&n.cleanData(ea(a,!1));while(a.firstChild)a.removeChild(a.firstChild);a.options&&n.nodeName(a,"select")&&(a.options.length=0)}return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return Y(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a)return 1===b.nodeType?b.innerHTML.replace(ta,""):void 0;if("string"==typeof a&&!wa.test(a)&&(l.htmlSerialize||!ua.test(a))&&(l.leadingWhitespace||!aa.test(a))&&!da[($.exec(a)||["",""])[1].toLowerCase()]){a=n.htmlPrefilter(a);try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ea(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ha(this,arguments,function(b){var c=this.parentNode;n.inArray(this,a)<0&&(n.cleanData(ea(this)),c&&c.replaceChild(b,this))},a)}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=0,e=[],f=n(a),h=f.length-1;h>=d;d++)c=d===h?this:this.clone(!0),n(f[d])[b](c),g.apply(e,c.get());return this.pushStack(e)}});var Ja,Ka={HTML:"block",BODY:"block"};function La(a,b){var c=n(b.createElement(a)).appendTo(b.body),d=n.css(c[0],"display");return c.detach(),d}function Ma(a){var b=d,c=Ka[a];return c||(c=La(a,b),"none"!==c&&c||(Ja=(Ja||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=(Ja[0].contentWindow||Ja[0].contentDocument).document,b.write(),b.close(),c=La(a,b),Ja.detach()),Ka[a]=c),c}var Na=/^margin/,Oa=new RegExp("^("+T+")(?!px)[a-z%]+$","i"),Pa=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e},Qa=d.documentElement;!function(){var b,c,e,f,g,h,i=d.createElement("div"),j=d.createElement("div");if(j.style){j.style.cssText="float:left;opacity:.5",l.opacity="0.5"===j.style.opacity,l.cssFloat=!!j.style.cssFloat,j.style.backgroundClip="content-box",j.cloneNode(!0).style.backgroundClip="",l.clearCloneStyle="content-box"===j.style.backgroundClip,i=d.createElement("div"),i.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",j.innerHTML="",i.appendChild(j),l.boxSizing=""===j.style.boxSizing||""===j.style.MozBoxSizing||""===j.style.WebkitBoxSizing,n.extend(l,{reliableHiddenOffsets:function(){return null==b&&k(),f},boxSizingReliable:function(){return null==b&&k(),e},pixelMarginRight:function(){return null==b&&k(),c},pixelPosition:function(){return null==b&&k(),b},reliableMarginRight:function(){return null==b&&k(),g},reliableMarginLeft:function(){return null==b&&k(),h}});function k(){var k,l,m=d.documentElement;m.appendChild(i),j.style.cssText="-webkit-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",b=e=h=!1,c=g=!0,a.getComputedStyle&&(l=a.getComputedStyle(j),b="1%"!==(l||{}).top,h="2px"===(l||{}).marginLeft,e="4px"===(l||{width:"4px"}).width,j.style.marginRight="50%",c="4px"===(l||{marginRight:"4px"}).marginRight,k=j.appendChild(d.createElement("div")),k.style.cssText=j.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",k.style.marginRight=k.style.width="0",j.style.width="1px",g=!parseFloat((a.getComputedStyle(k)||{}).marginRight),j.removeChild(k)),j.style.display="none",f=0===j.getClientRects().length,f&&(j.style.display="",j.innerHTML="<table><tr><td></td><td>t</td></tr></table>",k=j.getElementsByTagName("td"),k[0].style.cssText="margin:0;border:0;padding:0;display:none",f=0===k[0].offsetHeight,f&&(k[0].style.display="",k[1].style.display="none",f=0===k[0].offsetHeight)),m.removeChild(i)}}}();var Ra,Sa,Ta=/^(top|right|bottom|left)$/;a.getComputedStyle?(Ra=function(b){var c=b.ownerDocument.defaultView;return c.opener||(c=a),c.getComputedStyle(b)},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c.getPropertyValue(b)||c[b]:void 0,c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),!l.pixelMarginRight()&&Oa.test(g)&&Na.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0===g?g:g+""}):Qa.currentStyle&&(Ra=function(a){return a.currentStyle},Sa=function(a,b,c){var d,e,f,g,h=a.style;return c=c||Ra(a),g=c?c[b]:void 0,null==g&&h&&h[b]&&(g=h[b]),Oa.test(g)&&!Ta.test(b)&&(d=h.left,e=a.runtimeStyle,f=e&&e.left,f&&(e.left=a.currentStyle.left),h.left="fontSize"===b?"1em":g,g=h.pixelLeft+"px",h.left=d,f&&(e.left=f)),void 0===g?g:g+""||"auto"});function Ua(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Va=/alpha\([^)]*\)/i,Wa=/opacity\s*=\s*([^)]*)/i,Xa=/^(none|table(?!-c[ea]).+)/,Ya=new RegExp("^("+T+")(.*)$","i"),Za={position:"absolute",visibility:"hidden",display:"block"},$a={letterSpacing:"0",fontWeight:"400"},_a=["Webkit","O","Moz","ms"],ab=d.createElement("div").style;function bb(a){if(a in ab)return a;var b=a.charAt(0).toUpperCase()+a.slice(1),c=_a.length;while(c--)if(a=_a[c]+b,a in ab)return a}function cb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=n._data(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&W(d)&&(f[g]=n._data(d,"olddisplay",Ma(d.nodeName)))):(e=W(d),(c&&"none"!==c||!e)&&n._data(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}function db(a,b,c){var d=Ya.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function eb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+V[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+V[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+V[f]+"Width",!0,e))):(g+=n.css(a,"padding"+V[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+V[f]+"Width",!0,e)));return g}function fb(b,c,e){var f=!0,g="width"===c?b.offsetWidth:b.offsetHeight,h=Ra(b),i=l.boxSizing&&"border-box"===n.css(b,"boxSizing",!1,h);if(d.msFullscreenElement&&a.top!==a&&b.getClientRects().length&&(g=Math.round(100*b.getBoundingClientRect()[c])),0>=g||null==g){if(g=Sa(b,c,h),(0>g||null==g)&&(g=b.style[c]),Oa.test(g))return g;f=i&&(l.boxSizingReliable()||g===b.style[c]),g=parseFloat(g)||0}return g+eb(b,c,e||(i?"border":"content"),f,h)+"px"}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Sa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":l.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;if(b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],void 0===c)return g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b];if(f=typeof c,"string"===f&&(e=U.exec(c))&&e[1]&&(c=X(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(n.cssNumber[h]?"":"px")),l.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),!(g&&"set"in g&&void 0===(c=g.set(a,c,d)))))try{i[b]=c}catch(j){}}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=bb(h)||h),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(f=g.get(a,!0,c)),void 0===f&&(f=Sa(a,b,d)),"normal"===f&&b in $a&&(f=$a[b]),""===c||c?(e=parseFloat(f),c===!0||isFinite(e)?e||0:f):f}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?Xa.test(n.css(a,"display"))&&0===a.offsetWidth?Pa(a,Za,function(){return fb(a,b,d)}):fb(a,b,d):void 0},set:function(a,c,d){var e=d&&Ra(a);return db(a,c,d?eb(a,b,d,l.boxSizing&&"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),l.opacity||(n.cssHooks.opacity={get:function(a,b){return Wa.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=n.isNumeric(b)?"alpha(opacity="+100*b+")":"",f=d&&d.filter||c.filter||"";c.zoom=1,(b>=1||""===b)&&""===n.trim(f.replace(Va,""))&&c.removeAttribute&&(c.removeAttribute("filter"),""===b||d&&!d.filter)||(c.filter=Va.test(f)?f.replace(Va,e):f+" "+e)}}),n.cssHooks.marginRight=Ua(l.reliableMarginRight,function(a,b){return b?Pa(a,{display:"inline-block"},Sa,[a,"marginRight"]):void 0}),n.cssHooks.marginLeft=Ua(l.reliableMarginLeft,function(a,b){return b?(parseFloat(Sa(a,"marginLeft"))||(n.contains(a.ownerDocument,a)?a.getBoundingClientRect().left-Pa(a,{
marginLeft:0},function(){return a.getBoundingClientRect().left}):0))+"px":void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+V[d]+b]=f[d]||f[d-2]||f[0];return e}},Na.test(a)||(n.cssHooks[a+b].set=db)}),n.fn.extend({css:function(a,b){return Y(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=Ra(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return cb(this,!0)},hide:function(){return cb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){W(this)?n(this).show():n(this).hide()})}});function gb(a,b,c,d,e){return new gb.prototype.init(a,b,c,d,e)}n.Tween=gb,gb.prototype={constructor:gb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||n.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=gb.propHooks[this.prop];return a&&a.get?a.get(this):gb.propHooks._default.get(this)},run:function(a){var b,c=gb.propHooks[this.prop];return this.options.duration?this.pos=b=n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):gb.propHooks._default.set(this),this}},gb.prototype.init.prototype=gb.prototype,gb.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[n.cssProps[a.prop]]&&!n.cssHooks[a.prop]?a.elem[a.prop]=a.now:n.style(a.elem,a.prop,a.now+a.unit)}}},gb.propHooks.scrollTop=gb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},n.fx=gb.prototype.init,n.fx.step={};var hb,ib,jb=/^(?:toggle|show|hide)$/,kb=/queueHooks$/;function lb(){return a.setTimeout(function(){hb=void 0}),hb=n.now()}function mb(a,b){var c,d={height:a},e=0;for(b=b?1:0;4>e;e+=2-b)c=V[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function nb(a,b,c){for(var d,e=(qb.tweeners[b]||[]).concat(qb.tweeners["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function ob(a,b,c){var d,e,f,g,h,i,j,k,m=this,o={},p=a.style,q=a.nodeType&&W(a),r=n._data(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,m.always(function(){m.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[p.overflow,p.overflowX,p.overflowY],j=n.css(a,"display"),k="none"===j?n._data(a,"olddisplay")||Ma(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(l.inlineBlockNeedsLayout&&"inline"!==Ma(a.nodeName)?p.zoom=1:p.display="inline-block")),c.overflow&&(p.overflow="hidden",l.shrinkWrapBlocks()||m.always(function(){p.overflow=c.overflow[0],p.overflowX=c.overflow[1],p.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],jb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(q?"hide":"show")){if("show"!==e||!r||void 0===r[d])continue;q=!0}o[d]=r&&r[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(o))"inline"===("none"===j?Ma(a.nodeName):j)&&(p.display=j);else{r?"hidden"in r&&(q=r.hidden):r=n._data(a,"fxshow",{}),f&&(r.hidden=!q),q?n(a).show():m.done(function(){n(a).hide()}),m.done(function(){var b;n._removeData(a,"fxshow");for(b in o)n.style(a,b,o[b])});for(d in o)g=nb(q?r[d]:0,d,m),d in r||(r[d]=g.start,q&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function pb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function qb(a,b,c){var d,e,f=0,g=qb.prefilters.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=hb||lb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{},easing:n.easing._default},c),originalProperties:b,originalOptions:c,startTime:hb||lb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(pb(k,j.opts.specialEasing);g>f;f++)if(d=qb.prefilters[f].call(j,a,k,j.opts))return n.isFunction(d.stop)&&(n._queueHooks(j.elem,j.opts.queue).stop=n.proxy(d.stop,d)),d;return n.map(k,nb,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(qb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return X(c.elem,a,U.exec(b),c),c}]},tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.match(G);for(var c,d=0,e=a.length;e>d;d++)c=a[d],qb.tweeners[c]=qb.tweeners[c]||[],qb.tweeners[c].unshift(b)},prefilters:[ob],prefilter:function(a,b){b?qb.prefilters.unshift(a):qb.prefilters.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(W).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=qb(this,n.extend({},a),f);(e||n._data(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=n._data(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&kb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=n._data(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(mb(b,!0),a,d,e)}}),n.each({slideDown:mb("show"),slideUp:mb("hide"),slideToggle:mb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=n.timers,c=0;for(hb=n.now();c<b.length;c++)a=b[c],a()||b[c]!==a||b.splice(c--,1);b.length||n.fx.stop(),hb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){ib||(ib=a.setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){a.clearInterval(ib),ib=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(b,c){return b=n.fx?n.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a,b=d.createElement("input"),c=d.createElement("div"),e=d.createElement("select"),f=e.appendChild(d.createElement("option"));c=d.createElement("div"),c.setAttribute("className","t"),c.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",a=c.getElementsByTagName("a")[0],b.setAttribute("type","checkbox"),c.appendChild(b),a=c.getElementsByTagName("a")[0],a.style.cssText="top:1px",l.getSetAttribute="t"!==c.className,l.style=/top/.test(a.getAttribute("style")),l.hrefNormalized="/a"===a.getAttribute("href"),l.checkOn=!!b.value,l.optSelected=f.selected,l.enctype=!!d.createElement("form").enctype,e.disabled=!0,l.optDisabled=!f.disabled,b=d.createElement("input"),b.setAttribute("value",""),l.input=""===b.getAttribute("value"),b.value="t",b.setAttribute("type","radio"),l.radioValue="t"===b.value}();var rb=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],(c.selected||i===e)&&(l.optDisabled?!c.disabled:null===c.getAttribute("disabled"))&&(!c.parentNode.disabled||!n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)if(d=e[g],n.inArray(n.valHooks.option.get(d),f)>=0)try{d.selected=c=!0}catch(h){d.scrollHeight}else d.selected=!1;return c||(a.selectedIndex=-1),e}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>-1:void 0}},l.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb,tb,ub=n.expr.attrHandle,vb=/^(?:checked|selected)$/i,wb=l.getSetAttribute,xb=l.input;n.fn.extend({attr:function(a,b){return Y(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),e=n.attrHooks[b]||(n.expr.match.bool.test(b)?tb:sb)),void 0!==c?null===c?void n.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=n.find.attr(a,b),null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!l.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(G);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)?xb&&wb||!vb.test(c)?a[d]=!1:a[n.camelCase("default-"+c)]=a[d]=!1:n.attr(a,c,""),a.removeAttribute(wb?c:d)}}),tb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):xb&&wb||!vb.test(c)?a.setAttribute(!wb&&n.propFix[c]||c,c):a[n.camelCase("default-"+c)]=a[c]=!0,c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=ub[b]||n.find.attr;xb&&wb||!vb.test(b)?ub[b]=function(a,b,d){var e,f;return d||(f=ub[b],ub[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,ub[b]=f),e}:ub[b]=function(a,b,c){return c?void 0:a[n.camelCase("default-"+b)]?b.toLowerCase():null}}),xb&&wb||(n.attrHooks.value={set:function(a,b,c){return n.nodeName(a,"input")?void(a.defaultValue=b):sb&&sb.set(a,b,c)}}),wb||(sb={set:function(a,b,c){var d=a.getAttributeNode(c);return d||a.setAttributeNode(d=a.ownerDocument.createAttribute(c)),d.value=b+="","value"===c||b===a.getAttribute(c)?b:void 0}},ub.id=ub.name=ub.coords=function(a,b,c){var d;return c?void 0:(d=a.getAttributeNode(b))&&""!==d.value?d.value:null},n.valHooks.button={get:function(a,b){var c=a.getAttributeNode(b);return c&&c.specified?c.value:void 0},set:sb.set},n.attrHooks.contenteditable={set:function(a,b,c){sb.set(a,""===b?!1:b,c)}},n.each(["width","height"],function(a,b){n.attrHooks[b]={set:function(a,c){return""===c?(a.setAttribute(b,"auto"),c):void 0}}})),l.style||(n.attrHooks.style={get:function(a){return a.style.cssText||void 0},set:function(a,b){return a.style.cssText=b+""}});var yb=/^(?:input|select|textarea|button|object)$/i,zb=/^(?:a|area)$/i;n.fn.extend({prop:function(a,b){return Y(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return a=n.propFix[a]||a,this.each(function(){try{this[a]=void 0,delete this[a]}catch(b){}})}}),n.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&n.isXMLDoc(a)||(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=n.find.attr(a,"tabindex");return b?parseInt(b,10):yb.test(a.nodeName)||zb.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),l.hrefNormalized||n.each(["href","src"],function(a,b){n.propHooks[b]={get:function(a){return a.getAttribute(b,4)}}}),l.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this}),l.enctype||(n.propFix.enctype="encoding");var Ab=/[\t\r\n\f]/g;function Bb(a){return n.attr(a,"class")||""}n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,Bb(this)))});if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Bb(c),d=1===c.nodeType&&(" "+e+" ").replace(Ab," ")){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,Bb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(G)||[];while(c=this[i++])if(e=Bb(c),d=1===c.nodeType&&(" "+e+" ").replace(Ab," ")){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=n.trim(d),e!==h&&n.attr(c,"class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):n.isFunction(a)?this.each(function(c){n(this).toggleClass(a.call(this,c,Bb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=n(this),f=a.match(G)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(void 0===a||"boolean"===c)&&(b=Bb(this),b&&n._data(this,"__className__",b),n.attr(this,"class",b||a===!1?"":n._data(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+Bb(c)+" ").replace(Ab," ").indexOf(b)>-1)return!0;return!1}}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var Cb=a.location,Db=n.now(),Eb=/\?/,Fb=/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;n.parseJSON=function(b){if(a.JSON&&a.JSON.parse)return a.JSON.parse(b+"");var c,d=null,e=n.trim(b+"");return e&&!n.trim(e.replace(Fb,function(a,b,e,f){return c&&b&&(d=0),0===d?a:(c=e||b,d+=!f-!e,"")}))?Function("return "+e)():n.error("Invalid JSON: "+b)},n.parseXML=function(b){var c,d;if(!b||"string"!=typeof b)return null;try{a.DOMParser?(d=new a.DOMParser,c=d.parseFromString(b,"text/xml")):(c=new a.ActiveXObject("Microsoft.XMLDOM"),c.async="false",c.loadXML(b))}catch(e){c=void 0}return c&&c.documentElement&&!c.getElementsByTagName("parsererror").length||n.error("Invalid XML: "+b),c};var Gb=/#.*$/,Hb=/([?&])_=[^&]*/,Ib=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Jb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Kb=/^(?:GET|HEAD)$/,Lb=/^\/\//,Mb=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,Nb={},Ob={},Pb="*/".concat("*"),Qb=Cb.href,Rb=Mb.exec(Qb.toLowerCase())||[];function Sb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(G)||[];if(n.isFunction(c))while(d=f[e++])"+"===d.charAt(0)?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Tb(a,b,c,d){var e={},f=a===Ob;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ub(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(d in b)void 0!==b[d]&&((e[d]?a:c||(c={}))[d]=b[d]);return c&&n.extend(!0,a,c),a}function Vb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===e&&(e=a.mimeType||b.getResponseHeader("Content-Type"));if(e)for(g in h)if(h[g]&&h[g].test(e)){i.unshift(g);break}if(i[0]in c)f=i[0];else{for(g in c){if(!i[0]||a.converters[g+" "+i[0]]){f=g;break}d||(d=g)}f=f||d}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function Wb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Qb,type:"GET",isLocal:Jb.test(Rb[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Pb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ub(Ub(a,n.ajaxSettings),b):Ub(n.ajaxSettings,a)},ajaxPrefilter:Sb(Nb),ajaxTransport:Sb(Ob),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var d,e,f,g,h,i,j,k,l=n.ajaxSetup({},c),m=l.context||l,o=l.context&&(m.nodeType||m.jquery)?n(m):n.event,p=n.Deferred(),q=n.Callbacks("once memory"),r=l.statusCode||{},s={},t={},u=0,v="canceled",w={readyState:0,getResponseHeader:function(a){var b;if(2===u){if(!k){k={};while(b=Ib.exec(g))k[b[1].toLowerCase()]=b[2]}b=k[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===u?g:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return u||(a=t[c]=t[c]||a,s[a]=b),this},overrideMimeType:function(a){return u||(l.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>u)for(b in a)r[b]=[r[b],a[b]];else w.always(a[w.status]);return this},abort:function(a){var b=a||v;return j&&j.abort(b),y(0,b),this}};if(p.promise(w).complete=q.add,w.success=w.done,w.error=w.fail,l.url=((b||l.url||Qb)+"").replace(Gb,"").replace(Lb,Rb[1]+"//"),l.type=c.method||c.type||l.method||l.type,l.dataTypes=n.trim(l.dataType||"*").toLowerCase().match(G)||[""],null==l.crossDomain&&(d=Mb.exec(l.url.toLowerCase()),l.crossDomain=!(!d||d[1]===Rb[1]&&d[2]===Rb[2]&&(d[3]||("http:"===d[1]?"80":"443"))===(Rb[3]||("http:"===Rb[1]?"80":"443")))),l.data&&l.processData&&"string"!=typeof l.data&&(l.data=n.param(l.data,l.traditional)),Tb(Nb,l,c,w),2===u)return w;i=n.event&&l.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),l.type=l.type.toUpperCase(),l.hasContent=!Kb.test(l.type),f=l.url,l.hasContent||(l.data&&(f=l.url+=(Eb.test(f)?"&":"?")+l.data,delete l.data),l.cache===!1&&(l.url=Hb.test(f)?f.replace(Hb,"$1_="+Db++):f+(Eb.test(f)?"&":"?")+"_="+Db++)),l.ifModified&&(n.lastModified[f]&&w.setRequestHeader("If-Modified-Since",n.lastModified[f]),n.etag[f]&&w.setRequestHeader("If-None-Match",n.etag[f])),(l.data&&l.hasContent&&l.contentType!==!1||c.contentType)&&w.setRequestHeader("Content-Type",l.contentType),w.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+("*"!==l.dataTypes[0]?", "+Pb+"; q=0.01":""):l.accepts["*"]);for(e in l.headers)w.setRequestHeader(e,l.headers[e]);if(l.beforeSend&&(l.beforeSend.call(m,w,l)===!1||2===u))return w.abort();v="abort";for(e in{success:1,error:1,complete:1})w[e](l[e]);if(j=Tb(Ob,l,c,w)){if(w.readyState=1,i&&o.trigger("ajaxSend",[w,l]),2===u)return w;l.async&&l.timeout>0&&(h=a.setTimeout(function(){w.abort("timeout")},l.timeout));try{u=1,j.send(s,y)}catch(x){if(!(2>u))throw x;y(-1,x)}}else y(-1,"No Transport");function y(b,c,d,e){var k,s,t,v,x,y=c;2!==u&&(u=2,h&&a.clearTimeout(h),j=void 0,g=e||"",w.readyState=b>0?4:0,k=b>=200&&300>b||304===b,d&&(v=Vb(l,w,d)),v=Wb(l,v,w,k),k?(l.ifModified&&(x=w.getResponseHeader("Last-Modified"),x&&(n.lastModified[f]=x),x=w.getResponseHeader("etag"),x&&(n.etag[f]=x)),204===b||"HEAD"===l.type?y="nocontent":304===b?y="notmodified":(y=v.state,s=v.data,t=v.error,k=!t)):(t=y,(b||!y)&&(y="error",0>b&&(b=0))),w.status=b,w.statusText=(c||y)+"",k?p.resolveWith(m,[s,y,w]):p.rejectWith(m,[w,y,t]),w.statusCode(r),r=void 0,i&&o.trigger(k?"ajaxSuccess":"ajaxError",[w,l,k?s:t]),q.fireWith(m,[w,y]),i&&(o.trigger("ajaxComplete",[w,l]),--n.active||n.event.trigger("ajaxStop")))}return w},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax(n.extend({url:a,type:b,dataType:e,data:c,success:d},n.isPlainObject(a)&&a))}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){if(n.isFunction(a))return this.each(function(b){n(this).wrapAll(a.call(this,b))});if(this[0]){var b=n(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&1===a.firstChild.nodeType)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return n.isFunction(a)?this.each(function(b){n(this).wrapInner(a.call(this,b))}):this.each(function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}});function Xb(a){return a.style&&a.style.display||n.css(a,"display")}function Yb(a){while(a&&1===a.nodeType){if("none"===Xb(a)||"hidden"===a.type)return!0;a=a.parentNode}return!1}n.expr.filters.hidden=function(a){return l.reliableHiddenOffsets()?a.offsetWidth<=0&&a.offsetHeight<=0&&!a.getClientRects().length:Yb(a)},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var Zb=/%20/g,$b=/\[\]$/,_b=/\r?\n/g,ac=/^(?:submit|button|image|reset|file)$/i,bc=/^(?:input|select|textarea|keygen)/i;function cc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||$b.test(a)?d(a,e):cc(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)cc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)cc(c,a[c],b,e);return d.join("&").replace(Zb,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&bc.test(this.nodeName)&&!ac.test(a)&&(this.checked||!Z.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(_b,"\r\n")}}):{name:b.name,value:c.replace(_b,"\r\n")}}).get()}}),n.ajaxSettings.xhr=void 0!==a.ActiveXObject?function(){return this.isLocal?hc():d.documentMode>8?gc():/^(get|post|head|put|delete|options)$/i.test(this.type)&&gc()||hc()}:gc;var dc=0,ec={},fc=n.ajaxSettings.xhr();a.attachEvent&&a.attachEvent("onunload",function(){for(var a in ec)ec[a](void 0,!0)}),l.cors=!!fc&&"withCredentials"in fc,fc=l.ajax=!!fc,fc&&n.ajaxTransport(function(b){if(!b.crossDomain||l.cors){var c;return{send:function(d,e){var f,g=b.xhr(),h=++dc;if(g.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(f in b.xhrFields)g[f]=b.xhrFields[f];b.mimeType&&g.overrideMimeType&&g.overrideMimeType(b.mimeType),b.crossDomain||d["X-Requested-With"]||(d["X-Requested-With"]="XMLHttpRequest");for(f in d)void 0!==d[f]&&g.setRequestHeader(f,d[f]+"");g.send(b.hasContent&&b.data||null),c=function(a,d){var f,i,j;if(c&&(d||4===g.readyState))if(delete ec[h],c=void 0,g.onreadystatechange=n.noop,d)4!==g.readyState&&g.abort();else{j={},f=g.status,"string"==typeof g.responseText&&(j.text=g.responseText);try{i=g.statusText}catch(k){i=""}f||!b.isLocal||b.crossDomain?1223===f&&(f=204):f=j.text?200:404}j&&e(f,i,j,g.getAllResponseHeaders())},b.async?4===g.readyState?a.setTimeout(c):g.onreadystatechange=ec[h]=c:c()},abort:function(){c&&c(void 0,!0)}}}});function gc(){try{return new a.XMLHttpRequest}catch(b){}}function hc(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}n.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c=d.head||n("head")[0]||d.documentElement;return{send:function(e,f){b=d.createElement("script"),b.async=!0,a.scriptCharset&&(b.charset=a.scriptCharset),b.src=a.url,b.onload=b.onreadystatechange=function(a,c){(c||!b.readyState||/loaded|complete/.test(b.readyState))&&(b.onload=b.onreadystatechange=null,b.parentNode&&b.parentNode.removeChild(b),b=null,c||f(200,"success"))},c.insertBefore(b,c.firstChild)},abort:function(){b&&b.onload(void 0,!0)}}}});var ic=[],jc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=ic.pop()||n.expando+"_"+Db++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(jc.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&jc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(jc,"$1"+e):b.jsonp!==!1&&(b.url+=(Eb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?n(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,ic.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),l.createHTMLDocument=function(){if(!d.implementation.createHTMLDocument)return!1;var a=d.implementation.createHTMLDocument("");return a.body.innerHTML="<form></form><form></form>",2===a.body.childNodes.length}(),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||(l.createHTMLDocument?d.implementation.createHTMLDocument(""):d);var e=x.exec(a),f=!c&&[];return e?[b.createElement(e[1])]:(e=ja([a],b,f),f&&f.length&&n(f).remove(),n.merge([],e.childNodes))};var kc=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&kc)return kc.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=n.trim(a.slice(h,a.length)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(g,f||[a.responseText,b,a])})}),this},n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};function lc(a){return n.isWindow(a)?a:9===a.nodeType?a.defaultView||a.parentWindow:!1}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&n.inArray("auto",[f,i])>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,n.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d={top:0,left:0},e=this[0],f=e&&e.ownerDocument;if(f)return b=f.documentElement,n.contains(b,e)?("undefined"!=typeof e.getBoundingClientRect&&(d=e.getBoundingClientRect()),c=lc(f),{top:d.top+(c.pageYOffset||b.scrollTop)-(b.clientTop||0),left:d.left+(c.pageXOffset||b.scrollLeft)-(b.clientLeft||0)}):d},position:function(){if(this[0]){var a,b,c={top:0,left:0},d=this[0];return"fixed"===n.css(d,"position")?b=d.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(c=a.offset()),c.top+=n.css(a[0],"borderTopWidth",!0)-a.scrollTop(),c.left+=n.css(a[0],"borderLeftWidth",!0)-a.scrollLeft()),{top:b.top-c.top-n.css(d,"marginTop",!0),left:b.left-c.left-n.css(d,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Qa})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c=/Y/.test(b);n.fn[a]=function(d){return Y(this,function(a,d,e){var f=lc(a);return void 0===e?f?b in f?f[b]:f.document.documentElement[d]:a[d]:void(f?f.scrollTo(c?n(f).scrollLeft():e,c?e:n(f).scrollTop()):a[d]=e)},a,d,arguments.length,null)}}),n.each(["top","left"],function(a,b){
n.cssHooks[b]=Ua(l.pixelPosition,function(a,c){return c?(c=Sa(a,b),Oa.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return Y(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var mc=a.jQuery,nc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=nc),b&&a.jQuery===n&&(a.jQuery=mc),n},b||(a.jQuery=a.$=n),n});

define("lib/jquery", function(){});

/* Modernizr 2.8.2 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-hashchange-inputtypes-localstorage-postmessage-webworkers-shiv-cssclasses-hasevent-a_download-file_api-json-load
 */
;window.Modernizr=function(a,b,c){function w(a){j.cssText=a}function x(a,b){return w(prefixes.join(a+";")+(b||""))}function y(a,b){return typeof a===b}function z(a,b){return!!~(""+a).indexOf(b)}function A(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:y(f,"function")?f.bind(d||b):f}return!1}function B(){e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:e=k.value!=l)),o[a[d]]=!!e;return o}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.8.2",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n={},o={},p={},q=[],r=q.slice,s,t=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=y(e[d],"function"),y(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),u={}.hasOwnProperty,v;!y(u,"undefined")&&!y(u.call,"undefined")?v=function(a,b){return u.call(a,b)}:v=function(a,b){return b in a&&y(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=r.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(r.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(r.call(arguments)))};return e}),n.postmessage=function(){return!!a.postMessage},n.hashchange=function(){return t("hashchange",a)&&(b.documentMode===c||b.documentMode>7)},n.localstorage=function(){try{return localStorage.setItem(h,h),localStorage.removeItem(h),!0}catch(a){return!1}},n.webworkers=function(){return!!a.Worker};for(var C in n)v(n,C)&&(s=C.toLowerCase(),e[s]=n[C](),q.push((e[s]?"":"no-")+s));return e.input||B(),e.addTest=function(a,b){if(typeof a=="object")for(var d in a)v(a,d)&&e.addTest(d,a[d]);else{a=a.toLowerCase();if(e[a]!==c)return e;b=typeof b=="function"?b():b,typeof f!="undefined"&&f&&(g.className+=" "+(b?"":"no-")+a),e[a]=b}return e},w(""),i=k=null,function(a,b){function l(a,b){var c=a.createElement("p"),d=a.getElementsByTagName("head")[0]||a.documentElement;return c.innerHTML="x<style>"+b+"</style>",d.insertBefore(c.lastChild,d.firstChild)}function m(){var a=s.elements;return typeof a=="string"?a.split(" "):a}function n(a){var b=j[a[h]];return b||(b={},i++,a[h]=i,j[i]=b),b}function o(a,c,d){c||(c=b);if(k)return c.createElement(a);d||(d=n(c));var g;return d.cache[a]?g=d.cache[a].cloneNode():f.test(a)?g=(d.cache[a]=d.createElem(a)).cloneNode():g=d.createElem(a),g.canHaveChildren&&!e.test(a)&&!g.tagUrn?d.frag.appendChild(g):g}function p(a,c){a||(a=b);if(k)return a.createDocumentFragment();c=c||n(a);var d=c.frag.cloneNode(),e=0,f=m(),g=f.length;for(;e<g;e++)d.createElement(f[e]);return d}function q(a,b){b.cache||(b.cache={},b.createElem=a.createElement,b.createFrag=a.createDocumentFragment,b.frag=b.createFrag()),a.createElement=function(c){return s.shivMethods?o(c,a,b):b.createElem(c)},a.createDocumentFragment=Function("h,f","return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&("+m().join().replace(/[\w\-]+/g,function(a){return b.createElem(a),b.frag.createElement(a),'c("'+a+'")'})+");return n}")(s,b.frag)}function r(a){a||(a=b);var c=n(a);return s.shivCSS&&!g&&!c.hasCSS&&(c.hasCSS=!!l(a,"article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")),k||q(a,c),a}var c="3.7.0",d=a.html5||{},e=/^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,f=/^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,g,h="_html5shiv",i=0,j={},k;(function(){try{var a=b.createElement("a");a.innerHTML="<xyz></xyz>",g="hidden"in a,k=a.childNodes.length==1||function(){b.createElement("a");var a=b.createDocumentFragment();return typeof a.cloneNode=="undefined"||typeof a.createDocumentFragment=="undefined"||typeof a.createElement=="undefined"}()}catch(c){g=!0,k=!0}})();var s={elements:d.elements||"abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",version:c,shivCSS:d.shivCSS!==!1,supportsUnknownElements:k,shivMethods:d.shivMethods!==!1,type:"default",shivDocument:r,createElement:o,createDocumentFragment:p};a.html5=s,r(b)}(this,b),e._version=d,e.hasEvent=t,g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+q.join(" "):""),e}(this,this.document),function(a,b,c){function d(a){return"[object Function]"==o.call(a)}function e(a){return"string"==typeof a}function f(){}function g(a){return!a||"loaded"==a||"complete"==a||"uninitialized"==a}function h(){var a=p.shift();q=1,a?a.t?m(function(){("c"==a.t?B.injectCss:B.injectJs)(a.s,0,a.a,a.x,a.e,1)},0):(a(),h()):q=0}function i(a,c,d,e,f,i,j){function k(b){if(!o&&g(l.readyState)&&(u.r=o=1,!q&&h(),l.onload=l.onreadystatechange=null,b)){"img"!=a&&m(function(){t.removeChild(l)},50);for(var d in y[c])y[c].hasOwnProperty(d)&&y[c][d].onload()}}var j=j||B.errorTimeout,l=b.createElement(a),o=0,r=0,u={t:d,s:c,e:f,a:i,x:j};1===y[c]&&(r=1,y[c]=[]),"object"==a?l.data=c:(l.src=c,l.type=a),l.width=l.height="0",l.onerror=l.onload=l.onreadystatechange=function(){k.call(this,r)},p.splice(e,0,u),"img"!=a&&(r||2===y[c]?(t.insertBefore(l,s?null:n),m(k,j)):y[c].push(l))}function j(a,b,c,d,f){return q=0,b=b||"j",e(a)?i("c"==b?v:u,a,b,this.i++,c,d,f):(p.splice(this.i++,0,a),1==p.length&&h()),this}function k(){var a=B;return a.loader={load:j,i:0},a}var l=b.documentElement,m=a.setTimeout,n=b.getElementsByTagName("script")[0],o={}.toString,p=[],q=0,r="MozAppearance"in l.style,s=r&&!!b.createRange().compareNode,t=s?l:n.parentNode,l=a.opera&&"[object Opera]"==o.call(a.opera),l=!!b.attachEvent&&!l,u=r?"object":l?"script":"img",v=l?"script":u,w=Array.isArray||function(a){return"[object Array]"==o.call(a)},x=[],y={},z={timeout:function(a,b){return b.length&&(a.timeout=b[0]),a}},A,B;B=function(a){function b(a){var a=a.split("!"),b=x.length,c=a.pop(),d=a.length,c={url:c,origUrl:c,prefixes:a},e,f,g;for(f=0;f<d;f++)g=a[f].split("="),(e=z[g.shift()])&&(c=e(c,g));for(f=0;f<b;f++)c=x[f](c);return c}function g(a,e,f,g,h){var i=b(a),j=i.autoCallback;i.url.split(".").pop().split("?").shift(),i.bypass||(e&&(e=d(e)?e:e[a]||e[g]||e[a.split("/").pop().split("?")[0]]),i.instead?i.instead(a,e,f,g,h):(y[i.url]?i.noexec=!0:y[i.url]=1,f.load(i.url,i.forceCSS||!i.forceJS&&"css"==i.url.split(".").pop().split("?").shift()?"c":c,i.noexec,i.attrs,i.timeout),(d(e)||d(j))&&f.load(function(){k(),e&&e(i.origUrl,h,g),j&&j(i.origUrl,h,g),y[i.url]=2})))}function h(a,b){function c(a,c){if(a){if(e(a))c||(j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}),g(a,j,b,0,h);else if(Object(a)===a)for(n in m=function(){var b=0,c;for(c in a)a.hasOwnProperty(c)&&b++;return b}(),a)a.hasOwnProperty(n)&&(!c&&!--m&&(d(j)?j=function(){var a=[].slice.call(arguments);k.apply(this,a),l()}:j[n]=function(a){return function(){var b=[].slice.call(arguments);a&&a.apply(this,b),l()}}(k[n])),g(a[n],j,b,n,h))}else!c&&l()}var h=!!a.test,i=a.load||a.both,j=a.callback||f,k=j,l=a.complete||f,m,n;c(h?a.yep:a.nope,!!i),i&&c(i)}var i,j,l=this.yepnope.loader;if(e(a))g(a,0,l,0);else if(w(a))for(i=0;i<a.length;i++)j=a[i],e(j)?g(j,0,l,0):w(j)?B(j):Object(j)===j&&h(j,l);else Object(a)===a&&h(a,l)},B.addPrefix=function(a,b){z[a]=b},B.addFilter=function(a){x.push(a)},B.errorTimeout=1e4,null==b.readyState&&b.addEventListener&&(b.readyState="loading",b.addEventListener("DOMContentLoaded",A=function(){b.removeEventListener("DOMContentLoaded",A,0),b.readyState="complete"},0)),a.yepnope=k(),a.yepnope.executeStack=h,a.yepnope.injectJs=function(a,c,d,e,i,j){var k=b.createElement("script"),l,o,e=e||B.errorTimeout;k.src=a;for(o in d)k.setAttribute(o,d[o]);c=j?h:c||f,k.onreadystatechange=k.onload=function(){!l&&g(k.readyState)&&(l=1,c(),k.onload=k.onreadystatechange=null)},m(function(){l||(l=1,c(1))},e),i?k.onload():n.parentNode.insertBefore(k,n)},a.yepnope.injectCss=function(a,c,d,e,g,i){var e=b.createElement("link"),j,c=i?h:c||f;e.href=a,e.rel="stylesheet",e.type="text/css";for(j in d)e.setAttribute(j,d[j]);g||(n.parentNode.insertBefore(e,n),m(c,0))}}(this,document),Modernizr.load=function(){yepnope.apply(window,[].slice.call(arguments,0))},Modernizr.addTest("adownload","download"in document.createElement("a")),Modernizr.addTest("filereader",function(){return!!(window.File&&window.FileList&&window.FileReader)}),Modernizr.addTest("json",!!window.JSON&&!!JSON.parse);
define("lib/modernizr", ["lib/Blob"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Modernizr;
    };
}(this)));

/*!
 * typeahead.js 0.10.5
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT
 */

!function(a){var b=function(){"use strict";return{isMsie:function(){return/(msie|trident)/i.test(navigator.userAgent)?navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2]:!1},isBlankString:function(a){return!a||/^\s*$/.test(a)},escapeRegExChars:function(a){return a.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g,"\\$&")},isString:function(a){return"string"==typeof a},isNumber:function(a){return"number"==typeof a},isArray:a.isArray,isFunction:a.isFunction,isObject:a.isPlainObject,isUndefined:function(a){return"undefined"==typeof a},toStr:function(a){return b.isUndefined(a)||null===a?"":a+""},bind:a.proxy,each:function(b,c){function d(a,b){return c(b,a)}a.each(b,d)},map:a.map,filter:a.grep,every:function(b,c){var d=!0;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?void 0:!1}),!!d):d},some:function(b,c){var d=!1;return b?(a.each(b,function(a,e){return(d=c.call(null,e,a,b))?!1:void 0}),!!d):d},mixin:a.extend,getUniqueId:function(){var a=0;return function(){return a++}}(),templatify:function(b){function c(){return String(b)}return a.isFunction(b)?b:c},defer:function(a){setTimeout(a,0)},debounce:function(a,b,c){var d,e;return function(){var f,g,h=this,i=arguments;return f=function(){d=null,c||(e=a.apply(h,i))},g=c&&!d,clearTimeout(d),d=setTimeout(f,b),g&&(e=a.apply(h,i)),e}},throttle:function(a,b){var c,d,e,f,g,h;return g=0,h=function(){g=new Date,e=null,f=a.apply(c,d)},function(){var i=new Date,j=b-(i-g);return c=this,d=arguments,0>=j?(clearTimeout(e),e=null,g=i,f=a.apply(c,d)):e||(e=setTimeout(h,j)),f}},noop:function(){}}}(),c="0.10.5",d=function(){"use strict";function a(a){return a=b.toStr(a),a?a.split(/\s+/):[]}function c(a){return a=b.toStr(a),a?a.split(/\W+/):[]}function d(a){return function(){var c=[].slice.call(arguments,0);return function(d){var e=[];return b.each(c,function(c){e=e.concat(a(b.toStr(d[c])))}),e}}}return{nonword:c,whitespace:a,obj:{nonword:d(c),whitespace:d(a)}}}(),e=function(){"use strict";function c(c){this.maxSize=b.isNumber(c)?c:100,this.reset(),this.maxSize<=0&&(this.set=this.get=a.noop)}function d(){this.head=this.tail=null}function e(a,b){this.key=a,this.val=b,this.prev=this.next=null}return b.mixin(c.prototype,{set:function(a,b){var c,d=this.list.tail;this.size>=this.maxSize&&(this.list.remove(d),delete this.hash[d.key]),(c=this.hash[a])?(c.val=b,this.list.moveToFront(c)):(c=new e(a,b),this.list.add(c),this.hash[a]=c,this.size++)},get:function(a){var b=this.hash[a];return b?(this.list.moveToFront(b),b.val):void 0},reset:function(){this.size=0,this.hash={},this.list=new d}}),b.mixin(d.prototype,{add:function(a){this.head&&(a.next=this.head,this.head.prev=a),this.head=a,this.tail=this.tail||a},remove:function(a){a.prev?a.prev.next=a.next:this.head=a.next,a.next?a.next.prev=a.prev:this.tail=a.prev},moveToFront:function(a){this.remove(a),this.add(a)}}),c}(),f=function(){"use strict";function a(a){this.prefix=["__",a,"__"].join(""),this.ttlKey="__ttl__",this.keyMatcher=new RegExp("^"+b.escapeRegExChars(this.prefix))}function c(){return(new Date).getTime()}function d(a){return JSON.stringify(b.isUndefined(a)?null:a)}function e(a){return JSON.parse(a)}var f,g;try{f=window.localStorage,f.setItem("~~~","!"),f.removeItem("~~~")}catch(h){f=null}return g=f&&window.JSON?{_prefix:function(a){return this.prefix+a},_ttlKey:function(a){return this._prefix(a)+this.ttlKey},get:function(a){return this.isExpired(a)&&this.remove(a),e(f.getItem(this._prefix(a)))},set:function(a,e,g){return b.isNumber(g)?f.setItem(this._ttlKey(a),d(c()+g)):f.removeItem(this._ttlKey(a)),f.setItem(this._prefix(a),d(e))},remove:function(a){return f.removeItem(this._ttlKey(a)),f.removeItem(this._prefix(a)),this},clear:function(){var a,b,c=[],d=f.length;for(a=0;d>a;a++)(b=f.key(a)).match(this.keyMatcher)&&c.push(b.replace(this.keyMatcher,""));for(a=c.length;a--;)this.remove(c[a]);return this},isExpired:function(a){var d=e(f.getItem(this._ttlKey(a)));return b.isNumber(d)&&c()>d?!0:!1}}:{get:b.noop,set:b.noop,remove:b.noop,clear:b.noop,isExpired:b.noop},b.mixin(a.prototype,g),a}(),g=function(){"use strict";function c(b){b=b||{},this.cancelled=!1,this.lastUrl=null,this._send=b.transport?d(b.transport):a.ajax,this._get=b.rateLimiter?b.rateLimiter(this._get):this._get,this._cache=b.cache===!1?new e(0):i}function d(c){return function(d,e){function f(a){b.defer(function(){h.resolve(a)})}function g(a){b.defer(function(){h.reject(a)})}var h=a.Deferred();return c(d,e,f,g),h}}var f=0,g={},h=6,i=new e(10);return c.setMaxPendingRequests=function(a){h=a},c.resetCache=function(){i.reset()},b.mixin(c.prototype,{_get:function(a,b,c){function d(b){c&&c(null,b),k._cache.set(a,b)}function e(){c&&c(!0)}function i(){f--,delete g[a],k.onDeckRequestArgs&&(k._get.apply(k,k.onDeckRequestArgs),k.onDeckRequestArgs=null)}var j,k=this;this.cancelled||a!==this.lastUrl||((j=g[a])?j.done(d).fail(e):h>f?(f++,g[a]=this._send(a,b).done(d).fail(e).always(i)):this.onDeckRequestArgs=[].slice.call(arguments,0))},get:function(a,c,d){var e;return b.isFunction(c)&&(d=c,c={}),this.cancelled=!1,this.lastUrl=a,(e=this._cache.get(a))?b.defer(function(){d&&d(null,e)}):this._get(a,c,d),!!e},cancel:function(){this.cancelled=!0}}),c}(),h=function(){"use strict";function c(b){b=b||{},b.datumTokenizer&&b.queryTokenizer||a.error("datumTokenizer and queryTokenizer are both required"),this.datumTokenizer=b.datumTokenizer,this.queryTokenizer=b.queryTokenizer,this.reset()}function d(a){return a=b.filter(a,function(a){return!!a}),a=b.map(a,function(a){return a.toLowerCase()})}function e(){return{ids:[],children:{}}}function f(a){for(var b={},c=[],d=0,e=a.length;e>d;d++)b[a[d]]||(b[a[d]]=!0,c.push(a[d]));return c}function g(a,b){function c(a,b){return a-b}var d=0,e=0,f=[];a=a.sort(c),b=b.sort(c);for(var g=a.length,h=b.length;g>d&&h>e;)a[d]<b[e]?d++:a[d]>b[e]?e++:(f.push(a[d]),d++,e++);return f}return b.mixin(c.prototype,{bootstrap:function(a){this.datums=a.datums,this.trie=a.trie},add:function(a){var c=this;a=b.isArray(a)?a:[a],b.each(a,function(a){var f,g;f=c.datums.push(a)-1,g=d(c.datumTokenizer(a)),b.each(g,function(a){var b,d,g;for(b=c.trie,d=a.split("");g=d.shift();)b=b.children[g]||(b.children[g]=e()),b.ids.push(f)})})},get:function(a){var c,e,h=this;return c=d(this.queryTokenizer(a)),b.each(c,function(a){var b,c,d,f;if(e&&0===e.length)return!1;for(b=h.trie,c=a.split("");b&&(d=c.shift());)b=b.children[d];return b&&0===c.length?(f=b.ids.slice(0),void(e=e?g(e,f):f)):(e=[],!1)}),e?b.map(f(e),function(a){return h.datums[a]}):[]},reset:function(){this.datums=[],this.trie=e()},serialize:function(){return{datums:this.datums,trie:this.trie}}}),c}(),i=function(){"use strict";function d(a){return a.local||null}function e(d){var e,f;return f={url:null,thumbprint:"",ttl:864e5,filter:null,ajax:{}},(e=d.prefetch||null)&&(e=b.isString(e)?{url:e}:e,e=b.mixin(f,e),e.thumbprint=c+e.thumbprint,e.ajax.type=e.ajax.type||"GET",e.ajax.dataType=e.ajax.dataType||"json",!e.url&&a.error("prefetch requires url to be set")),e}function f(c){function d(a){return function(c){return b.debounce(c,a)}}function e(a){return function(c){return b.throttle(c,a)}}var f,g;return g={url:null,cache:!0,wildcard:"%QUERY",replace:null,rateLimitBy:"debounce",rateLimitWait:300,send:null,filter:null,ajax:{}},(f=c.remote||null)&&(f=b.isString(f)?{url:f}:f,f=b.mixin(g,f),f.rateLimiter=/^throttle$/i.test(f.rateLimitBy)?e(f.rateLimitWait):d(f.rateLimitWait),f.ajax.type=f.ajax.type||"GET",f.ajax.dataType=f.ajax.dataType||"json",delete f.rateLimitBy,delete f.rateLimitWait,!f.url&&a.error("remote requires url to be set")),f}return{local:d,prefetch:e,remote:f}}();!function(c){"use strict";function e(b){b&&(b.local||b.prefetch||b.remote)||a.error("one of local, prefetch, or remote is required"),this.limit=b.limit||5,this.sorter=j(b.sorter),this.dupDetector=b.dupDetector||k,this.local=i.local(b),this.prefetch=i.prefetch(b),this.remote=i.remote(b),this.cacheKey=this.prefetch?this.prefetch.cacheKey||this.prefetch.url:null,this.index=new h({datumTokenizer:b.datumTokenizer,queryTokenizer:b.queryTokenizer}),this.storage=this.cacheKey?new f(this.cacheKey):null}function j(a){function c(b){return b.sort(a)}function d(a){return a}return b.isFunction(a)?c:d}function k(){return!1}var l,m;return l=c.Bloodhound,m={data:"data",protocol:"protocol",thumbprint:"thumbprint"},c.Bloodhound=e,e.noConflict=function(){return c.Bloodhound=l,e},e.tokenizers=d,b.mixin(e.prototype,{_loadPrefetch:function(b){function c(a){f.clear(),f.add(b.filter?b.filter(a):a),f._saveToStorage(f.index.serialize(),b.thumbprint,b.ttl)}var d,e,f=this;return(d=this._readFromStorage(b.thumbprint))?(this.index.bootstrap(d),e=a.Deferred().resolve()):e=a.ajax(b.url,b.ajax).done(c),e},_getFromRemote:function(a,b){function c(a,c){b(a?[]:f.remote.filter?f.remote.filter(c):c)}var d,e,f=this;if(this.transport)return a=a||"",e=encodeURIComponent(a),d=this.remote.replace?this.remote.replace(this.remote.url,a):this.remote.url.replace(this.remote.wildcard,e),this.transport.get(d,this.remote.ajax,c)},_cancelLastRemoteRequest:function(){this.transport&&this.transport.cancel()},_saveToStorage:function(a,b,c){this.storage&&(this.storage.set(m.data,a,c),this.storage.set(m.protocol,location.protocol,c),this.storage.set(m.thumbprint,b,c))},_readFromStorage:function(a){var b,c={};return this.storage&&(c.data=this.storage.get(m.data),c.protocol=this.storage.get(m.protocol),c.thumbprint=this.storage.get(m.thumbprint)),b=c.thumbprint!==a||c.protocol!==location.protocol,c.data&&!b?c.data:null},_initialize:function(){function c(){e.add(b.isFunction(f)?f():f)}var d,e=this,f=this.local;return d=this.prefetch?this._loadPrefetch(this.prefetch):a.Deferred().resolve(),f&&d.done(c),this.transport=this.remote?new g(this.remote):null,this.initPromise=d.promise()},initialize:function(a){return!this.initPromise||a?this._initialize():this.initPromise},add:function(a){this.index.add(a)},get:function(a,c){function d(a){var d=f.slice(0);b.each(a,function(a){var c;return c=b.some(d,function(b){return e.dupDetector(a,b)}),!c&&d.push(a),d.length<e.limit}),c&&c(e.sorter(d))}var e=this,f=[],g=!1;f=this.index.get(a),f=this.sorter(f).slice(0,this.limit),f.length<this.limit?g=this._getFromRemote(a,d):this._cancelLastRemoteRequest(),g||(f.length>0||!this.transport)&&c&&c(f)},clear:function(){this.index.reset()},clearPrefetchCache:function(){this.storage&&this.storage.clear()},clearRemoteCache:function(){this.transport&&g.resetCache()},ttAdapter:function(){return b.bind(this.get,this)}}),e}(this);var j=function(){return{wrapper:'<span class="twitter-typeahead"></span>',dropdown:'<span class="tt-dropdown-menu"></span>',dataset:'<div class="tt-dataset-%CLASS%"></div>',suggestions:'<span class="tt-suggestions"></span>',suggestion:'<div class="tt-suggestion"></div>'}}(),k=function(){"use strict";var a={wrapper:{position:"relative",display:"inline-block"},hint:{position:"absolute",top:"0",left:"0",borderColor:"transparent",boxShadow:"none",opacity:"1"},input:{position:"relative",verticalAlign:"top",backgroundColor:"transparent"},inputWithNoHint:{position:"relative",verticalAlign:"top"},dropdown:{position:"absolute",top:"100%",left:"0",zIndex:"100",display:"none"},suggestions:{display:"block"},suggestion:{whiteSpace:"nowrap",cursor:"pointer"},suggestionChild:{whiteSpace:"normal"},ltr:{left:"0",right:"auto"},rtl:{left:"auto",right:" 0"}};return b.isMsie()&&b.mixin(a.input,{backgroundImage:"url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"}),b.isMsie()&&b.isMsie()<=7&&b.mixin(a.input,{marginTop:"-1px"}),a}(),l=function(){"use strict";function c(b){b&&b.el||a.error("EventBus initialized without el"),this.$el=a(b.el)}var d="typeahead:";return b.mixin(c.prototype,{trigger:function(a){var b=[].slice.call(arguments,1);this.$el.trigger(d+a,b)}}),c}(),m=function(){"use strict";function a(a,b,c,d){var e;if(!c)return this;for(b=b.split(i),c=d?h(c,d):c,this._callbacks=this._callbacks||{};e=b.shift();)this._callbacks[e]=this._callbacks[e]||{sync:[],async:[]},this._callbacks[e][a].push(c);return this}function b(b,c,d){return a.call(this,"async",b,c,d)}function c(b,c,d){return a.call(this,"sync",b,c,d)}function d(a){var b;if(!this._callbacks)return this;for(a=a.split(i);b=a.shift();)delete this._callbacks[b];return this}function e(a){var b,c,d,e,g;if(!this._callbacks)return this;for(a=a.split(i),d=[].slice.call(arguments,1);(b=a.shift())&&(c=this._callbacks[b]);)e=f(c.sync,this,[b].concat(d)),g=f(c.async,this,[b].concat(d)),e()&&j(g);return this}function f(a,b,c){function d(){for(var d,e=0,f=a.length;!d&&f>e;e+=1)d=a[e].apply(b,c)===!1;return!d}return d}function g(){var a;return a=window.setImmediate?function(a){setImmediate(function(){a()})}:function(a){setTimeout(function(){a()},0)}}function h(a,b){return a.bind?a.bind(b):function(){a.apply(b,[].slice.call(arguments,0))}}var i=/\s+/,j=g();return{onSync:c,onAsync:b,off:d,trigger:e}}(),n=function(a){"use strict";function c(a,c,d){for(var e,f=[],g=0,h=a.length;h>g;g++)f.push(b.escapeRegExChars(a[g]));return e=d?"\\b("+f.join("|")+")\\b":"("+f.join("|")+")",c?new RegExp(e):new RegExp(e,"i")}var d={node:null,pattern:null,tagName:"strong",className:null,wordsOnly:!1,caseSensitive:!1};return function(e){function f(b){var c,d,f;return(c=h.exec(b.data))&&(f=a.createElement(e.tagName),e.className&&(f.className=e.className),d=b.splitText(c.index),d.splitText(c[0].length),f.appendChild(d.cloneNode(!0)),b.parentNode.replaceChild(f,d)),!!c}function g(a,b){for(var c,d=3,e=0;e<a.childNodes.length;e++)c=a.childNodes[e],c.nodeType===d?e+=b(c)?1:0:g(c,b)}var h;e=b.mixin({},d,e),e.node&&e.pattern&&(e.pattern=b.isArray(e.pattern)?e.pattern:[e.pattern],h=c(e.pattern,e.caseSensitive,e.wordsOnly),g(e.node,f))}}(window.document),o=function(){"use strict";function c(c){var e,f,h,i,j=this;c=c||{},c.input||a.error("input is missing"),e=b.bind(this._onBlur,this),f=b.bind(this._onFocus,this),h=b.bind(this._onKeydown,this),i=b.bind(this._onInput,this),this.$hint=a(c.hint),this.$input=a(c.input).on("blur.tt",e).on("focus.tt",f).on("keydown.tt",h),0===this.$hint.length&&(this.setHint=this.getHint=this.clearHint=this.clearHintIfInvalid=b.noop),b.isMsie()?this.$input.on("keydown.tt keypress.tt cut.tt paste.tt",function(a){g[a.which||a.keyCode]||b.defer(b.bind(j._onInput,j,a))}):this.$input.on("input.tt",i),this.query=this.$input.val(),this.$overflowHelper=d(this.$input)}function d(b){return a('<pre aria-hidden="true"></pre>').css({position:"absolute",visibility:"hidden",whiteSpace:"pre",fontFamily:b.css("font-family"),fontSize:b.css("font-size"),fontStyle:b.css("font-style"),fontVariant:b.css("font-variant"),fontWeight:b.css("font-weight"),wordSpacing:b.css("word-spacing"),letterSpacing:b.css("letter-spacing"),textIndent:b.css("text-indent"),textRendering:b.css("text-rendering"),textTransform:b.css("text-transform")}).insertAfter(b)}function e(a,b){return c.normalizeQuery(a)===c.normalizeQuery(b)}function f(a){return a.altKey||a.ctrlKey||a.metaKey||a.shiftKey}var g;return g={9:"tab",27:"esc",37:"left",39:"right",13:"enter",38:"up",40:"down"},c.normalizeQuery=function(a){return(a||"").replace(/^\s*/g,"").replace(/\s{2,}/g," ")},b.mixin(c.prototype,m,{_onBlur:function(){this.resetInputValue(),this.trigger("blurred")},_onFocus:function(){this.trigger("focused")},_onKeydown:function(a){var b=g[a.which||a.keyCode];this._managePreventDefault(b,a),b&&this._shouldTrigger(b,a)&&this.trigger(b+"Keyed",a)},_onInput:function(){this._checkInputValue()},_managePreventDefault:function(a,b){var c,d,e;switch(a){case"tab":d=this.getHint(),e=this.getInputValue(),c=d&&d!==e&&!f(b);break;case"up":case"down":c=!f(b);break;default:c=!1}c&&b.preventDefault()},_shouldTrigger:function(a,b){var c;switch(a){case"tab":c=!f(b);break;default:c=!0}return c},_checkInputValue:function(){var a,b,c;a=this.getInputValue(),b=e(a,this.query),c=b?this.query.length!==a.length:!1,this.query=a,b?c&&this.trigger("whitespaceChanged",this.query):this.trigger("queryChanged",this.query)},focus:function(){this.$input.focus()},blur:function(){this.$input.blur()},getQuery:function(){return this.query},setQuery:function(a){this.query=a},getInputValue:function(){return this.$input.val()},setInputValue:function(a,b){this.$input.val(a),b?this.clearHint():this._checkInputValue()},resetInputValue:function(){this.setInputValue(this.query,!0)},getHint:function(){return this.$hint.val()},setHint:function(a){this.$hint.val(a)},clearHint:function(){this.setHint("")},clearHintIfInvalid:function(){var a,b,c,d;a=this.getInputValue(),b=this.getHint(),c=a!==b&&0===b.indexOf(a),d=""!==a&&c&&!this.hasOverflow(),!d&&this.clearHint()},getLanguageDirection:function(){return(this.$input.css("direction")||"ltr").toLowerCase()},hasOverflow:function(){var a=this.$input.width()-2;return this.$overflowHelper.text(this.getInputValue()),this.$overflowHelper.width()>=a},isCursorAtEnd:function(){var a,c,d;return a=this.$input.val().length,c=this.$input[0].selectionStart,b.isNumber(c)?c===a:document.selection?(d=document.selection.createRange(),d.moveStart("character",-a),a===d.text.length):!0},destroy:function(){this.$hint.off(".tt"),this.$input.off(".tt"),this.$hint=this.$input=this.$overflowHelper=null}}),c}(),p=function(){"use strict";function c(c){c=c||{},c.templates=c.templates||{},c.source||a.error("missing source"),c.name&&!f(c.name)&&a.error("invalid dataset name: "+c.name),this.query=null,this.highlight=!!c.highlight,this.name=c.name||b.getUniqueId(),this.source=c.source,this.displayFn=d(c.display||c.displayKey),this.templates=e(c.templates,this.displayFn),this.$el=a(j.dataset.replace("%CLASS%",this.name))}function d(a){function c(b){return b[a]}return a=a||"value",b.isFunction(a)?a:c}function e(a,c){function d(a){return"<p>"+c(a)+"</p>"}return{empty:a.empty&&b.templatify(a.empty),header:a.header&&b.templatify(a.header),footer:a.footer&&b.templatify(a.footer),suggestion:a.suggestion||d}}function f(a){return/^[_a-zA-Z0-9-]+$/.test(a)}var g="ttDataset",h="ttValue",i="ttDatum";return c.extractDatasetName=function(b){return a(b).data(g)},c.extractValue=function(b){return a(b).data(h)},c.extractDatum=function(b){return a(b).data(i)},b.mixin(c.prototype,m,{_render:function(c,d){function e(){return p.templates.empty({query:c,isEmpty:!0})}function f(){function e(b){var c;return c=a(j.suggestion).append(p.templates.suggestion(b)).data(g,p.name).data(h,p.displayFn(b)).data(i,b),c.children().each(function(){a(this).css(k.suggestionChild)}),c}var f,l;return f=a(j.suggestions).css(k.suggestions),l=b.map(d,e),f.append.apply(f,l),p.highlight&&n({className:"tt-highlight",node:f[0],pattern:c}),f}function l(){return p.templates.header({query:c,isEmpty:!o})}function m(){return p.templates.footer({query:c,isEmpty:!o})}if(this.$el){var o,p=this;this.$el.empty(),o=d&&d.length,!o&&this.templates.empty?this.$el.html(e()).prepend(p.templates.header?l():null).append(p.templates.footer?m():null):o&&this.$el.html(f()).prepend(p.templates.header?l():null).append(p.templates.footer?m():null),this.trigger("rendered")}},getRoot:function(){return this.$el},update:function(a){function b(b){c.canceled||a!==c.query||c._render(a,b)}var c=this;this.query=a,this.canceled=!1,this.source(a,b)},cancel:function(){this.canceled=!0},clear:function(){this.cancel(),this.$el.empty(),this.trigger("rendered")},isEmpty:function(){return this.$el.is(":empty")},destroy:function(){this.$el=null}}),c}(),q=function(){"use strict";function c(c){var e,f,g,h=this;c=c||{},c.menu||a.error("menu is required"),this.isOpen=!1,this.isEmpty=!0,this.datasets=b.map(c.datasets,d),e=b.bind(this._onSuggestionClick,this),f=b.bind(this._onSuggestionMouseEnter,this),g=b.bind(this._onSuggestionMouseLeave,this),this.$menu=a(c.menu).on("click.tt",".tt-suggestion",e).on("mouseenter.tt",".tt-suggestion",f).on("mouseleave.tt",".tt-suggestion",g),b.each(this.datasets,function(a){h.$menu.append(a.getRoot()),a.onSync("rendered",h._onRendered,h)})}function d(a){return new p(a)}return b.mixin(c.prototype,m,{_onSuggestionClick:function(b){this.trigger("suggestionClicked",a(b.currentTarget))},_onSuggestionMouseEnter:function(b){this._removeCursor(),this._setCursor(a(b.currentTarget),!0)},_onSuggestionMouseLeave:function(){this._removeCursor()},_onRendered:function(){function a(a){return a.isEmpty()}this.isEmpty=b.every(this.datasets,a),this.isEmpty?this._hide():this.isOpen&&this._show(),this.trigger("datasetRendered")},_hide:function(){this.$menu.hide()},_show:function(){this.$menu.css("display","block")},_getSuggestions:function(){return this.$menu.find(".tt-suggestion")},_getCursor:function(){return this.$menu.find(".tt-cursor").first()},_setCursor:function(a,b){a.first().addClass("tt-cursor"),!b&&this.trigger("cursorMoved")},_removeCursor:function(){this._getCursor().removeClass("tt-cursor")},_moveCursor:function(a){var b,c,d,e;if(this.isOpen){if(c=this._getCursor(),b=this._getSuggestions(),this._removeCursor(),d=b.index(c)+a,d=(d+1)%(b.length+1)-1,-1===d)return void this.trigger("cursorRemoved");-1>d&&(d=b.length-1),this._setCursor(e=b.eq(d)),this._ensureVisible(e)}},_ensureVisible:function(a){var b,c,d,e;b=a.position().top,c=b+a.outerHeight(!0),d=this.$menu.scrollTop(),e=this.$menu.height()+parseInt(this.$menu.css("paddingTop"),10)+parseInt(this.$menu.css("paddingBottom"),10),0>b?this.$menu.scrollTop(d+b):c>e&&this.$menu.scrollTop(d+(c-e))},close:function(){this.isOpen&&(this.isOpen=!1,this._removeCursor(),this._hide(),this.trigger("closed"))},open:function(){this.isOpen||(this.isOpen=!0,!this.isEmpty&&this._show(),this.trigger("opened"))},setLanguageDirection:function(a){this.$menu.css("ltr"===a?k.ltr:k.rtl)},moveCursorUp:function(){this._moveCursor(-1)},moveCursorDown:function(){this._moveCursor(1)},getDatumForSuggestion:function(a){var b=null;return a.length&&(b={raw:p.extractDatum(a),value:p.extractValue(a),datasetName:p.extractDatasetName(a)}),b},getDatumForCursor:function(){return this.getDatumForSuggestion(this._getCursor().first())},getDatumForTopSuggestion:function(){return this.getDatumForSuggestion(this._getSuggestions().first())},update:function(a){function c(b){b.update(a)}b.each(this.datasets,c)},empty:function(){function a(a){a.clear()}b.each(this.datasets,a),this.isEmpty=!0},isVisible:function(){return this.isOpen&&!this.isEmpty},destroy:function(){function a(a){a.destroy()}this.$menu.off(".tt"),this.$menu=null,b.each(this.datasets,a)}}),c}(),r=function(){"use strict";function c(c){var e,f,g;c=c||{},c.input||a.error("missing input"),this.isActivated=!1,this.autoselect=!!c.autoselect,this.minLength=b.isNumber(c.minLength)?c.minLength:1,this.$node=d(c.input,c.withHint),e=this.$node.find(".tt-dropdown-menu"),f=this.$node.find(".tt-input"),g=this.$node.find(".tt-hint"),f.on("blur.tt",function(a){var c,d,g;c=document.activeElement,d=e.is(c),g=e.has(c).length>0,b.isMsie()&&(d||g)&&(a.preventDefault(),a.stopImmediatePropagation(),b.defer(function(){f.focus()}))}),e.on("mousedown.tt",function(a){a.preventDefault()}),this.eventBus=c.eventBus||new l({el:f}),this.dropdown=new q({menu:e,datasets:c.datasets}).onSync("suggestionClicked",this._onSuggestionClicked,this).onSync("cursorMoved",this._onCursorMoved,this).onSync("cursorRemoved",this._onCursorRemoved,this).onSync("opened",this._onOpened,this).onSync("closed",this._onClosed,this).onAsync("datasetRendered",this._onDatasetRendered,this),this.input=new o({input:f,hint:g}).onSync("focused",this._onFocused,this).onSync("blurred",this._onBlurred,this).onSync("enterKeyed",this._onEnterKeyed,this).onSync("tabKeyed",this._onTabKeyed,this).onSync("escKeyed",this._onEscKeyed,this).onSync("upKeyed",this._onUpKeyed,this).onSync("downKeyed",this._onDownKeyed,this).onSync("leftKeyed",this._onLeftKeyed,this).onSync("rightKeyed",this._onRightKeyed,this).onSync("queryChanged",this._onQueryChanged,this).onSync("whitespaceChanged",this._onWhitespaceChanged,this),this._setLanguageDirection()}function d(b,c){var d,f,h,i;d=a(b),f=a(j.wrapper).css(k.wrapper),h=a(j.dropdown).css(k.dropdown),i=d.clone().css(k.hint).css(e(d)),i.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder required").prop("readonly",!0).attr({autocomplete:"off",spellcheck:"false",tabindex:-1}),d.data(g,{dir:d.attr("dir"),autocomplete:d.attr("autocomplete"),spellcheck:d.attr("spellcheck"),style:d.attr("style")}),d.addClass("tt-input").attr({autocomplete:"off",spellcheck:!1}).css(c?k.input:k.inputWithNoHint);try{!d.attr("dir")&&d.attr("dir","auto")}catch(l){}return d.wrap(f).parent().prepend(c?i:null).append(h)}function e(a){return{backgroundAttachment:a.css("background-attachment"),backgroundClip:a.css("background-clip"),backgroundColor:a.css("background-color"),backgroundImage:a.css("background-image"),backgroundOrigin:a.css("background-origin"),backgroundPosition:a.css("background-position"),backgroundRepeat:a.css("background-repeat"),backgroundSize:a.css("background-size")}}function f(a){var c=a.find(".tt-input");b.each(c.data(g),function(a,d){b.isUndefined(a)?c.removeAttr(d):c.attr(d,a)}),c.detach().removeData(g).removeClass("tt-input").insertAfter(a),a.remove()}var g="ttAttrs";return b.mixin(c.prototype,{_onSuggestionClicked:function(a,b){var c;(c=this.dropdown.getDatumForSuggestion(b))&&this._select(c)},_onCursorMoved:function(){var a=this.dropdown.getDatumForCursor();this.input.setInputValue(a.value,!0),this.eventBus.trigger("cursorchanged",a.raw,a.datasetName)},_onCursorRemoved:function(){this.input.resetInputValue(),this._updateHint()},_onDatasetRendered:function(){this._updateHint()},_onOpened:function(){this._updateHint(),this.eventBus.trigger("opened")},_onClosed:function(){this.input.clearHint(),this.eventBus.trigger("closed")},_onFocused:function(){this.isActivated=!0,this.dropdown.open()},_onBlurred:function(){this.isActivated=!1,this.dropdown.empty(),this.dropdown.close()},_onEnterKeyed:function(a,b){var c,d;c=this.dropdown.getDatumForCursor(),d=this.dropdown.getDatumForTopSuggestion(),c?(this._select(c),b.preventDefault()):this.autoselect&&d&&(this._select(d),b.preventDefault())},_onTabKeyed:function(a,b){var c;(c=this.dropdown.getDatumForCursor())?(this._select(c),b.preventDefault()):this._autocomplete(!0)},_onEscKeyed:function(){this.dropdown.close(),this.input.resetInputValue()},_onUpKeyed:function(){var a=this.input.getQuery();this.dropdown.isEmpty&&a.length>=this.minLength?this.dropdown.update(a):this.dropdown.moveCursorUp(),this.dropdown.open()},_onDownKeyed:function(){var a=this.input.getQuery();this.dropdown.isEmpty&&a.length>=this.minLength?this.dropdown.update(a):this.dropdown.moveCursorDown(),this.dropdown.open()},_onLeftKeyed:function(){"rtl"===this.dir&&this._autocomplete()},_onRightKeyed:function(){"ltr"===this.dir&&this._autocomplete()},_onQueryChanged:function(a,b){this.input.clearHintIfInvalid(),b.length>=this.minLength?this.dropdown.update(b):this.dropdown.empty(),this.dropdown.open(),this._setLanguageDirection()},_onWhitespaceChanged:function(){this._updateHint(),this.dropdown.open()},_setLanguageDirection:function(){var a;this.dir!==(a=this.input.getLanguageDirection())&&(this.dir=a,this.$node.css("direction",a),this.dropdown.setLanguageDirection(a))},_updateHint:function(){var a,c,d,e,f,g;a=this.dropdown.getDatumForTopSuggestion(),a&&this.dropdown.isVisible()&&!this.input.hasOverflow()?(c=this.input.getInputValue(),d=o.normalizeQuery(c),e=b.escapeRegExChars(d),f=new RegExp("^(?:"+e+")(.+$)","i"),g=f.exec(a.value),g?this.input.setHint(c+g[1]):this.input.clearHint()):this.input.clearHint()},_autocomplete:function(a){var b,c,d,e;b=this.input.getHint(),c=this.input.getQuery(),d=a||this.input.isCursorAtEnd(),b&&c!==b&&d&&(e=this.dropdown.getDatumForTopSuggestion(),e&&this.input.setInputValue(e.value),this.eventBus.trigger("autocompleted",e.raw,e.datasetName))},_select:function(a){this.input.setQuery(a.value),this.input.setInputValue(a.value,!0),this._setLanguageDirection(),this.eventBus.trigger("selected",a.raw,a.datasetName),this.dropdown.close(),b.defer(b.bind(this.dropdown.empty,this.dropdown))},open:function(){this.dropdown.open()},close:function(){this.dropdown.close()},setVal:function(a){a=b.toStr(a),this.isActivated?this.input.setInputValue(a):(this.input.setQuery(a),this.input.setInputValue(a,!0)),this._setLanguageDirection()},getVal:function(){return this.input.getQuery()},destroy:function(){this.input.destroy(),this.dropdown.destroy(),f(this.$node),this.$node=null}}),c}();!function(){"use strict";var c,d,e;c=a.fn.typeahead,d="ttTypeahead",e={initialize:function(c,e){function f(){var f,g,h=a(this);b.each(e,function(a){a.highlight=!!c.highlight}),g=new r({input:h,eventBus:f=new l({el:h}),withHint:b.isUndefined(c.hint)?!0:!!c.hint,minLength:c.minLength,autoselect:c.autoselect,datasets:e}),h.data(d,g)}return e=b.isArray(e)?e:[].slice.call(arguments,1),c=c||{},this.each(f)},open:function(){function b(){var b,c=a(this);(b=c.data(d))&&b.open()}return this.each(b)},close:function(){function b(){var b,c=a(this);(b=c.data(d))&&b.close()}return this.each(b)},val:function(b){function c(){var c,e=a(this);(c=e.data(d))&&c.setVal(b)}function e(a){var b,c;return(b=a.data(d))&&(c=b.getVal()),c}return arguments.length?this.each(c):e(this.first())},destroy:function(){function b(){var b,c=a(this);(b=c.data(d))&&(b.destroy(),c.removeData(d))}return this.each(b)}},a.fn.typeahead=function(b){var c;return e[b]&&"initialize"!==b?(c=this.filter(function(){return!!a(this).data(d)}),e[b].apply(c,[].slice.call(arguments,1))):e.initialize.apply(this,arguments)},a.fn.typeahead.noConflict=function(){return a.fn.typeahead=c,this}}()}(window.jQuery);
define("lib/typeahead", ["jquery"], function(){});

/**
 * An event emitter class
 *
 * @return Listener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/listener',[],function() {
  /**
   * Constructor
   *
   * @param emitter
   */
  function Listener(emitter) {
    if (!this.emitters) {
      this.emitters = [];
    }

    if (emitter) {
      emitter.registerListener(this);
    }
  }

  /**
   * anonymous one-line listener, which just registers the callback.
   *
   * @param emitter
   *          the emitter
   * @param events
   *          a comma-separated list of events to listen to
   * @param callback
   *          the callback function
   * @param thisArg
   *          Optional. "this" for the callback function. Defaults to the
   *          returned listener
   * @return the internally created Listener, e.g. for destroy() calls
   */
  Listener.bind = function(emitter, events, callback, thisArg) {
    var listener, initialCallback;

    if (thisArg) {
      initialCallback = function(_emitter, _event, data) {
        callback.call(thisArg, _emitter, _event, data);
      };
    } else {
      initialCallback = callback;
    }

    listener = new Listener(emitter);

    events.split(',').forEach(function(event) {
      // trim spaces
      event = event.replace(/^\s+|\s+$/g, '');

      if (emitter.EVENTS[event]) {
        listener['on' + event] = initialCallback;
      } else {
        console.error('Listener.bind: emitter does not emit event:"' + event);
      }
    });

    return listener;
  };

  /**
   * destroy the listener, i.e. remove it from all emitters
   */
  Listener.prototype.destroy = function() {
    while (this.emitters.length > 0) {
      this.emitters[0].unregisterListener(this);
    }
  };
  return Listener;
});

/**
 * An event emitter class
 *
 * @return Emitter
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/emitter',['lib/extend', 'core/listener'], function(extend, Listener) {
  var depth;

  depth = 0;

  function getClassName(instance) {
    return instance.constructor.toString().split('\n')[0].replace(
        /function (\S+)\(.*/, '$1');
  }

  /**
   * Constructor
   */
  function Emitter() {
    Emitter.superconstructor.call(this, undefined);

    if (this.listeners === undefined) {
      this.listeners = [];
    }

    if (Emitter.debug && this.EVENTS.update) {
      console.warn(getClassName(this)
          + ": The use of the 'update' event is discouraged.");
      console.warn("   Cause: The meaning of 'update' is ambiguous");
    }
  }
  extend(Emitter, Listener);
  Emitter.prototype.EVENTS = {
    'update': true,
    'reset': true
  }; // Default Events

  // TODO somehow restrict the events that can be emitted. This has to be
  // visible to the user (i.e. programmers)!

  /**
   * Emits an event to all registered listeners by calling the callback
   * functions of format 'on'+event, if available
   *
   * The callback functions' parameters are the emitter (this), the event string
   * (without 'on') and an optional data object, in this order.
   *
   * @param event
   *          a string containing the name of the event. Callback functions need
   *          to have a function name in the format 'on'+event
   * @param data
   *          arbitrary additional data. Please keep it simple!
   * @return true if the some listener received the event, false otherwise
   */
  Emitter.prototype.emit = function(event, data) {
    var success, indentation;

    success = false;

    if (!this.validEvent(event)) {
      console.error('Emitter: unspecified event type: ' + event);
      return false;
    }

    /*
     * Iterate over every listener in order. We call slice() to copy the array,
     * so that unregisterListener()-calls don't cause other listeners to be
     * skipped. Have a look at the corresponding unit test.
     */
    depth += 1;

    if (Emitter.debug) {
      indentation = '>';
      while (indentation.length <= depth) {
        indentation += ' ';
      }
      console.log(indentation + getClassName(this) + '.emit(' + event
          + ') with ' + this.listeners.length + ' listeners');
    }

    this.listeners.slice().forEach(function(listener) {
      if (listener['on' + event]) {
        listener['on' + event].call(listener, this, event, data);
        success = true;
      }
    }, this);

    depth -= 1;

    return success;
  };

  /**
   * validate the event type
   *
   * @param event
   *          an event string, e.g. 'update'
   * @return true if the event type is defined, false otherwise
   */
  Emitter.prototype.validEvent = function(event) {
    return this.EVENTS && !!this.EVENTS[event];
  };

  /**
   * register an event listener
   *
   * @param listener
   *          an event listener instance, which should define the necessary
   *          callback functions
   * @return this
   */
  Emitter.prototype.registerListener = function(listener) {
    this.unregisterListener(listener);
    this.listeners.push(listener);
    listener.emitters.push(this);

    return this;
  };

  /**
   * Makes sure that the event listener is not receiving event callbacks anymore
   *
   * @param listener
   *          an instance of the View class, which may have already been
   *          registered
   * @return this
   */
  Emitter.prototype.unregisterListener = function(listener) {
    var index;

    index = this.listeners.indexOf(listener);
    if (index !== -1) {
      this.listeners.splice(index, 1);
    }

    if (listener.emitters) {
      index = listener.emitters.indexOf(this);
      if (index !== -1) {
        listener.emitters.splice(index, 1);
      }
    }

    return this;
  };

  /**
   * unregister all related listeners
   */
  Emitter.prototype.destroy = function() {
    Emitter.superclass.destroy.call(this);

    while (this.listeners.length > 0) {
      this.unregisterListener(this.listeners[0]);
    }
  };

  /**
   * enable/disable debugging log
   */
  Emitter.debug = false;

  return Emitter;
});

/**
 * A simple type verification library.
 *
 * In addition to the Type() and Type.is() functions, Type.isNumber(),
 * Type.isBoolean(), Type.isArray() etc. functions are available, but lack
 * additional documentation. They just match the type and return true or false
 *
 * @return Type
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/type',[],function() {
  var types;

  /**
   * helper function to capitalize a string
   *
   * @param str
   *          an arbitrary string of length > 0
   * @return the same string, with the first letter in upper case and the rest
   *         in lower case
   */
  function capitalize(str) {
    return str[0].toUpperCase() + str.slice(1).toLowerCase();
  }

  function getFunctionName(func) {
    return func.toString().replace(/\s+/g, ' ').replace(
        /^\s*function ([A-Za-z]+)\(.*$/, '$1').toLowerCase();
  }

  types = [1, , {}, '', undefined, null, new Date(), [], /asd/, true,
  /**
   * anonymous reference function
   */
  function() {
    //
  }];

  /**
   * get the type string of an object, while also distinguishing between
   * objects, arrays, dates etc.
   *
   * @param obj
   *          the object
   * @return a lower-case single-word type string of the object.
   */
  function Type(obj) {
    return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  }

  /**
   * generic type comparison function. Other generic functions include:
   *
   * Type.isNumber(obj)
   *
   * Type.isObject(obj)
   *
   * Type.isString(obj)
   *
   * Type.isUndefined(obj)
   *
   * Type.isNull(obj)
   *
   * Type.isDate(obj)
   *
   * Type.isArray(obj)
   *
   * Type.isRegexp(obj)
   *
   * Type.isBoolean(obj)
   *
   * Type.isFunction(obj)
   *
   * @param obj
   *          the object
   * @param typestring
   *          the type string, as it may have been returned by Type()
   * @return true if the typestring matches Type(obj), false otherwise
   */
  Type.is = function(obj, typestring) {
    switch (Type(typestring)) {
    case 'string':
      return Type(obj) === typestring;
    case 'function':

      return Type(obj) === getFunctionName(typestring);
    case 'undefined':
      return Type(obj) === 'undefined';
    case 'null':
      return Type(obj) === 'null';
    default:
      return false;
    }
  };

  /**
   * automatically creates the Type.isSomething functions
   *
   * @param reference
   *          a reference object
   */
  types.map(function(reference) {
    var typestring = Type(reference);
    /**
     * Type.isSomething() closure
     */
    Type['is' + capitalize(typestring)] = function(obj) {
      return Type.is(obj, typestring);
    };
  });

  return Type;
});

/**
 * An abstract model class
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/model',['lib/extend', './emitter', './type'], function(extend, Emitter, Type) {
  function getClassName(instance) {
    return instance.constructor.toString().replace(
        /^function (\S+)\((.+|\s+)*$/g, '$1');
  }

  /**
   * match the type of data against referenceType. Also allows to match
   * equal-depth multidimensional arrays with a single contained data type
   *
   * @param data
   * @param referenceType
   * @return true if the types match, false otherwise
   */
  function verifyType(data, referenceType) {
    if (Type.isArray(referenceType)) {
      if (Type.isArray(data)) {
        if (referenceType.length === 1) {
          return data.every(function(dataElement) {
            if (verifyType(dataElement, referenceType[0])) {
              return true;
            }

            console.error('restore(): Array element does not match type');
            return false;
          });
        }
        console.error('SAVEFORMAT array does not contain exactly 1 Type!');
      }
      return false;
    }

    if (Type.is(data, referenceType)) {
      return true;
    }

    console.error(getClassName(this) + '.restore(): missing Key of type '
        + referenceType);
    return false;
  }

  /**
   * Constructor for setting an initial state.
   *
   * Please provide additional functions in order to allow state modifications.
   * Use this.emit() to signal state changes to registered views
   */
  function Model() {
    Model.superconstructor.call(this);
  }
  extend(Model, Emitter);

  /**
   * save the state of this object, so it can later be restored using the
   * restore() function. Subclasses are supposed to call superclass.save()
   * instead of instantiating their own data object.
   *
   * @return a data object
   */
  Model.prototype.save = function() {
    // TODO auto-verify the format
    return {};
  };

  /**
   * restore the state from a saved state, as written by save(); Subclasses are
   * supposed to call superclass.save() before restoring their own state.
   *
   * @param data
   *          a data object as written by save()
   * @return true on success, false or undefined otherwise
   */
  Model.prototype.restore = function(data) {
    // TODO warn about additional keys
    // TODO allow for the verification of sub-Models
    if (!Type.isObject(data)) {
      console.error('restore(): data is not an object');
      return false;
    }

    if (!Type.isObject(this.SAVEFORMAT)) {
      console.error('restore(): SAVEFORMAT is not an object');
      return false;
    }

    return Object.keys(this.SAVEFORMAT).every(function(key) {
      if (verifyType.call(this, data[key], this.SAVEFORMAT[key])) {
        return true;
      }
      console.error('Missing key or wrong format: ' + key);
      console.log(data);
      return false;
    }, this);
  };

  Model.prototype.SAVEFORMAT = {};

  return Model;
});

/**
 * RLE: A RunLengthEncoding class for multidimensional sparse non-referencing
 * numerical containers (vectors and arrays). null-data is compressed using
 * placeholders for a sequence of null elements, where null elements are all raw
 * data types that evaluate to false, and empty arrays.
 *
 * Again: This class is intended for the compression/inflation of numerical
 * data. Don't be surprised if it messes up any other kind of data.
 *
 * @return RLE
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rle',['./type'], function(Type) {
  var RLE = {};

  /**
   * RLE-encode the one- or multidimensional array of numerical data
   *
   * Warning: This function does not detect circular references and is hence
   * prone to infinite loops!
   *
   * @param array
   *          a sparse multidimensional non-circular numerical array
   * @return a string representation of array
   */
  RLE.encode = function(array) {
    var i, nullstart, str, elem, notnull;

    switch (Type(array)) {
    case 'array':
      // use the code below
      break;
    case 'number':
      // just return the string representation of the number. Fallback for
      return array.toString();
    default:
      throw new Error('RLE encoding failed: cannot parse content of type '
          + Type(array));
    }

    str = '';
    nullstart = -1;
    for (i = 0; i < array.length; i += 1) {
      elem = array[i];

      notnull = elem != null && elem != 0;

      if (nullstart > -1) {
        if (notnull) {
          if (nullstart === 0) {
            // begin a new string
            str = '[';
          } else {
            // continue an old string
            str += ',';
          }
          if ((i - nullstart) == 1) {
            str += 'n';
          } else {
            str += 'n' + (i - nullstart);
          }
          nullstart = -1;
        } else {
          // just continue the null run
          continue;
        }
      }

      if (notnull) {
        if (i != 0) {
          // continue string
          str += ',';
        } else {
          // start new string
          str += '[';
        }

        try {
          str += RLE.encode(elem);
        } catch (e) {
          console.error(e);
          str += undefined;
        }
        nullstart = -1;
      } else {
        nullstart = i;
      }
    }

    if (nullstart !== -1) {
      if (str.length === 0) {
        str = '[';
      } else {
        str += ',';
      }
      str += 'n' + (i - nullstart);
    }

    if (str.length) {
      str += ']';
    }

    return str;
  };

  /**
   * decode an RLE-encoded numerical array
   *
   * @param blob
   *          the string representation
   * @return an array which has been decoded from the blob, or undefined on
   *         failure
   */
  RLE.decode = function(blob) {
    var array, nesting, i, num, char, isnull, nullsleft, newarray;

    if (Type(blob) != 'string') {
      console.error('RLE.decode: input is no string, but of type "'
          + Type(blob) + "'");
      return undefined;
    }

    if (blob.length == 0) {
      return [];
    }

    nesting = [];
    num = '';
    array = undefined;
    isnull = false;
    nullsleft = 0;

    for (i = 0; i < blob.length; ++i) {
      char = blob[i];

      switch (char) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '+':
      case '-':
      case 'e':
      case '.':
        // is part of a number: add to number OR a skip number
        num += char;
        break;
      case 'n':
        // is indicative of a null run
        if (isnull) {
          console.error('unexpected sequence of multiple "n" '
              + 'characters in RLE.decode input');
          return undefined;
        }
        isnull = true;
        break;
      case '[':
        // starts a new nested subarray
        newarray = [];
        // write all nulls up to this point
        if (nesting.length > 0) {
          array[array.length + nullsleft] = newarray;
        }
        nullsleft = 0;
        nesting.push(newarray);
        array = nesting[nesting.length - 1];
        break;
      case ',':
        if (num.length == 0) {
          if (isnull) {
            nullsleft += 1;
          } else {
            // Note to self: ',,' does nothing (compromise)
            // Note to self: '],' is allowed this way, so KEEP IT THAT WAY!
            // console.error('empty array element in decode input');
            // return undefined;
          }
        } else {
          num = Number(num);
          if (isNaN(num)) {
            console.error('invalid number or character sequence '
                + 'in RLE.decode input');
            return undefined;
          }
          if (isnull) {
            nullsleft += num;
          } else {
            array[array.length + nullsleft] = num;
            nullsleft = 0;
          }
        }
        isnull = false;
        num = '';
        break;
      case ']':
        // first, write the last number, if any
        if (!isnull) {
          if (num.length == 0) {
            // console.error('empty field in RLE.decode input.
            // Discarding end of this array');
          } else {
            num = Number(num);
            if (isNaN(num)) {
              console.error('invalid number or character sequence '
                  + 'in RLE.decode input');
              return undefined;
            }
            array[array.length + nullsleft] = num;
            nullsleft = 0;
          }
        } else {
          num = Number(num);
          nullsleft += num;
          if (nullsleft > 0) {
            array[array.length + nullsleft - 1] = undefined;
          }
          nullsleft = 0;
        }
        // ends a nested subarray
        if (nesting.length == 1) {
          if (i == blob.length - 1) {
            // end of input reached
            return array;
          }
          console.error('unbalanced closing "]" in RLE input');
          return undefined;
        }
        nesting.pop();
        array = nesting[nesting.length - 1];
        if (array[array.length - 1].length == 0) {
          array[array.length - 1] = undefined;
        }
        num = '';
        isnull = false;
        break;
      default:
        console.error('RLE decode: unexpected character "' + char
            + '" in sparse array blob');
        return undefined;
      }
    }

    // ERROR: unexpected end of input
    console.error('unexpected end of input. Unbalanced brackets');
    return undefined;
  };

  return RLE;
});

/**
 * MatrixModel, a square matrix representation.
 *
 * We don't inherit from ListModel or VectorModel since they're compact
 * representations, but this class is supposed to handle extremely sparse
 * matrices. So, we're defining and maintaining our own arrays.
 *
 * @return MatrixModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/matrixmodel',['lib/extend', './model', './rle'], function(extend, Model, RLE) {
  /**
   * Constructor
   *
   * @param size
   *          size of the matrix. defaults to 0
   */
  function MatrixModel(size) {
    MatrixModel.superconstructor.call(this);

    this.data = [];
    this.length = Math.max(0, size || 0);

    return this;
  }
  extend(MatrixModel, Model);

  MatrixModel.prototype.EVENTS = {
    'resize': true
  };

  /**
   * removes the rows and cols associated with the index from the matrix
   *
   * @param index
   *          {Integer} index
   * @return {MatrixModel} this
   */
  MatrixModel.prototype.remove = function(index) {
    if (index >= this.length || index < 0) {
      return this;
    }

    this.data.splice(index, 1);
    this.data.forEach(function(b) {
      b.splice(index, 1);
    });

    this.length -= 1;

    this.emit('resize');

    return this;
  };

  /**
   * resizes the matrix while taking care of
   *
   * @param size
   *          the new size
   * @return this on success, undefined otherwise
   */
  MatrixModel.prototype.resize = function(size) {
    if (size === undefined) {
      return undefined;
    }
    if (size < 0) {
      size = 0;
    }

    if (this.length > size) {
      this.data.splice(size);

      this.data.forEach(function(row) {
        row.splice(size);
      });
    }

    this.length = size;

    this.emit('resize');

    return this;
  };

  /**
   * retrieves the value from the given indices.
   *
   * @param row
   *          vertical position
   * @param col
   *          horizontal position
   * @return value at (row, col). Defaults to 0
   */
  MatrixModel.prototype.get = function(row, col) {
    if (Math.min(row, col) < 0 || Math.max(row, col) >= this.length) {
      console.warn('MatrixModel.get(): out of bounds');
      return undefined;
    }
    if (!this.data[row]) {
      return 0;
    }

    return this.data[row][col] || 0;
  };

  /**
   * sets the value at the given indices and allocates/frees the cell/row if
   * possible
   *
   * @param row
   *          vertical position
   * @param col
   *          horizontal position
   * @param value
   *          integer value to store in position (row, col)
   * @return {MatrixModel} this
   */
  MatrixModel.prototype.set = function(row, col, value) {
    var rowref;

    if (Math.min(row, col) < 0 || Math.max(row, col) >= this.length) {
      console.warn('MatrixModel.set(): out of bounds');
      return undefined;
    }

    rowref = this.data[row];

    if (value) {
      if (!rowref) {
        rowref = this.data[row] = [];
      }
      rowref[col] = value;
    } else if (rowref) {
      delete rowref[col];
    }

    return this;
  };

  /**
   * write the main diagonal elements to a vector
   *
   * @param vector
   *          a VectorModel instance to write the results to
   * @return vector on success, undefined otherwise
   */
  MatrixModel.prototype.diagonal = function(vector) {
    var index;

    vector.resize(this.length);

    for (index = 0; index < vector.length; index += 1) {
      vector.set(index, this.get(index, index));
    }

    return vector;
  };

  /**
   * perform a Matrix*Vector multiplication and store the results in the
   * provided output vector
   *
   * @param outVec
   *          the output vector
   * @param vec
   *          the input vector
   * @return outVec on success, containing this*vec. undefined otherwise.
   */
  MatrixModel.prototype.multVector = function(outVec, vec) {
    var row, col, sum;

    if (vec.length !== this.length) {
      console.warn('MatrixModel.multVector: different input lengths: '
          + this.length + '<>' + vec.length);
      return undefined;
    }

    outVec.resize(vec.length);

    for (row = 0; row < outVec.length; row += 1) {
      sum = 0;

      for (col = 0; col < outVec.length; col += 1) {
        sum += this.get(row, col) * vec.get(col);
      }

      outVec.set(row, sum);
    }

    return outVec;
  };

  /**
   * perform a Vector*Matrix multiplication and store the results in the
   * provided output vector
   *
   * @param outVec
   *          the output vector
   * @param vec
   *          the input vector
   * @return outVec on success, containing this*vec. undefined otherwise.
   */
  MatrixModel.prototype.vectorMult = function(outVec, vec) {
    var row, col, sum;

    if (vec.length !== this.length) {
      console.warn('MatrixModel.multVector: different input lengths: '
          + this.length + '<>' + vec.length);
      return undefined;
    }

    outVec.resize(vec.length);

    for (col = 0; col < outVec.length; col += 1) {
      sum = 0;

      for (row = 0; row < outVec.length; row += 1) {
        sum += this.get(row, col) * vec.get(row);
      }

      outVec.set(col, sum);
    }

    return outVec;
  };

  /**
   * set all elements in the matrix to the same value.
   *
   * In AntisymmetricMatrixModel, the superdiagonal elements will be inverted,
   * while the diagonal elements will equal the value.
   *
   * @param value
   *          Optional. The value. Defaults to 0.
   */
  MatrixModel.prototype.fill = function(value) {
    var row, col;
    value = value || 0;

    if (value === 0) {
      // discard all data, since get() defaults to 0.
      this.data.splice(0);
    } else {
      /*
       * Since we don't know about the data mapping, we cannot simply copy data
       * across this.data. Instead, we just iterate over this.set().
       */
      for (row = 0; row < this.length; row += 1) {
        for (col = 0; col < this.length; col += 1) {
          this.set(row, col, value);
        }
      }
    }
  };

  /**
   * prepare a readonly, nonreferencing, serializable data object, representing
   * the matrix
   *
   * @return a serializable data object
   */
  MatrixModel.prototype.save = function() {
    var data, mat;

    data = MatrixModel.superclass.save.call(this);

    mat = this.data.map(function(row) {
      return row.map(function(cell) {
        return cell || 0;
      });
    }, this);

    data.mat = RLE.encode(mat);
    data.len = this.length;

    return data;
  };

  MatrixModel.prototype.restore = function(data) {
    var mat;
    if (!MatrixModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.resize(0);

    mat = RLE.decode(data.mat);

    mat.forEach(function(row, rowindex) {
      this.data[rowindex] = row.slice();
    }, this);

    this.resize(data.len);

    return true;
  };

  MatrixModel.prototype.SAVEFORMAT = Object
      .create(MatrixModel.superclass.SAVEFORMAT);
  MatrixModel.prototype.SAVEFORMAT.mat = String;
  MatrixModel.prototype.SAVEFORMAT.len = Number;

  return MatrixModel;
});

/**
 * DelegateMatrix takes a MatrixModel instance (or any of its subclasses) and
 * wraps around it as a MatrixModel instance, enabling all matrix read functions
 * while write functions are disabled.
 *
 * By overriding get(), the return values can be modified (absolute, only
 * positive, checkered patterns, whatever). Use this.superget() to access the
 * original get()
 *
 * @return DelegateMatrix
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/delegatematrix',['lib/extend', './matrixmodel'], function(extend, MatrixModel) {
  /**
   * Constructor
   *
   * @param matrix
   *          the matrix to bind itself to
   */
  function DelegateMatrix(matrix) {
    // call constructor for safety. We're going to overwrite all fields
    DelegateMatrix.superconstructor.call(this, matrix.length);

    if (!matrix) {
      throw new Error('DelegateMatrix(): no input matrix: ' + matrix);
    }

    this.data = matrix.data;
    this.superget = matrix.get;
    /* this.length is set by the superconstructor */

    matrix.registerListener(this);
  }
  extend(DelegateMatrix, MatrixModel);

  /**
   * Delegate the get call to superget, with the appropriate adjustments.
   *
   * Please override ONLY this function
   *
   * @param row
   *          the row
   * @param col
   *          the column
   * @return the value at the given matrix position
   */
  DelegateMatrix.prototype.get = function(row, col) {
    return this.superget(row, col);
  };

  /**
   * Disable write function
   */
  DelegateMatrix.prototype.remove = undefined;

  /**
   * Disable write function
   */
  DelegateMatrix.prototype.set = undefined;

  /**
   * Disable write function
   */
  DelegateMatrix.prototype.fill = undefined;

  /**
   * Disable write function
   */
  DelegateMatrix.prototype.resize = undefined;

  /**
   * automatically update the length when the references matrix is resized and
   * re-emit the event
   *
   * @param matrix
   *          the emitter, i.e. the base matrix
   */
  DelegateMatrix.prototype.onresize = function(matrix) {
    this.length = matrix.length;
    this.emit('resize');
  };

  return DelegateMatrix;
});

/**
 * AbsoluteMatrix: return the absolute of all values
 *
 * @return AbsoluteMatrix
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/absolutematrix',['lib/extend', './delegatematrix'], function(extend, DelegateMatrix) {
  /**
   * Constructor
   *
   * @param matrix
   *          the matrix to bind itself to
   */
  function AbsoluteMatrix(matrix) {
    AbsoluteMatrix.superconstructor.call(this, matrix);
  }
  extend(AbsoluteMatrix, DelegateMatrix);

  /**
   * return the absolute value at the given position
   *
   * @param row
   *          the row
   * @param col
   *          the column
   * @return the absolute value at position (row,col)
   */
  AbsoluteMatrix.prototype.get = function(row, col) {
    var value = this.superget(row, col);
    if (value < 0) {
      return -value;
    }
    return value;
  };

  return AbsoluteMatrix;
});

/**
 * AntisymmetricMatrixModel is a MatrixModel subclass which maps write and read
 * access to a triangular portion of the matrix, thereby maintaining
 * antisymmetry. For this, the values themselves are also negated.
 *
 * Other than a pure antisymmetric matrix, non-zero writes to the main diagonal
 * are allowed and are not negated. They can be useful in some cases. If you
 * require a strictly antisymmetric matrix, just don't write there.
 *
 * The restrictions are imposed by overloading the get() and set() functions,
 * which in turn call the superclass functions if the range is within the
 * writable limits.
 *
 * @return AntisymmetricMatrixModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/antisymmetricmatrixmodel',['lib/extend', './matrixmodel'], function(extend, MatrixModel) {
  /**
   * Constructor
   *
   * @param size
   *          size of the matrix. defaults to 0
   */
  function AntisymmetricMatrixModel(size) {
    AntisymmetricMatrixModel.superconstructor.call(this, size);
  }
  extend(AntisymmetricMatrixModel, MatrixModel);

  /**
   * get() function, which maps super-diagonal elements to a lower triangular
   * matrix, including the necessary additive inversion
   *
   * @param row
   *          row
   * @param col
   *          column
   * @return the stored value
   */
  AntisymmetricMatrixModel.prototype.get = function(row, col) {
    if (row < col) {
      return -AntisymmetricMatrixModel.superclass.get.call(this, col, row);
    }

    return AntisymmetricMatrixModel.superclass.get.call(this, row, col);
  };

  /**
   * set() function, which maps super-diagonal writes to the lower triangular
   * matrix, with an additive inversion
   *
   * @param row
   *          row
   * @param col
   *          column
   * @param value
   *          value
   * @return this on success, undefined otherwise
   */
  AntisymmetricMatrixModel.prototype.set = function(row, col, value) {
    if (row < col) {
      return AntisymmetricMatrixModel.superclass.set.call(this, col, row,
          -value);
    }

    return AntisymmetricMatrixModel.superclass.set.call(this, row, col, value);
  };

  return AntisymmetricMatrixModel;
});

/**
 * ListUpdateListener: call the callback function whenever the list size has
 * been changed or reset
 *
 * @return ListUpdateListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/listupdatelistener',['lib/extend', './listener'], function(extend, Listener) {
  /**
   * Constructor
   *
   * @param list
   *          the list object
   * @param callback
   *          the callback function of format function(data) { }
   */
  function ListUpdateListener(list, callback) {
    ListUpdateListener.superconstructor.call(this, list);

    this.callback = callback;
  }
  extend(ListUpdateListener, Listener);

  /**
   * bind function for self-commenting code and to avoid lint warnings
   *
   * @param list
   *          a ListModel instance
   * @param callback
   *          a callback function of the format function(data)
   * @return a valid ListUpdateListener instance on success
   */
  ListUpdateListener.bind = function(list, callback) {
    return new ListUpdateListener(list, callback);
  };

  /**
   * general callback function
   *
   * @param emitter
   *          the list
   * @param event
   *          the event type
   * @param data
   *          a data object
   */
  ListUpdateListener.prototype.update = function(emitter, event, data) {
    this.callback.call(emitter, data);
  };

  /**
   * collect different event types
   */
  ListUpdateListener.prototype.onremove = ListUpdateListener.prototype.update;
  ListUpdateListener.prototype.onreset = ListUpdateListener.prototype.update;
  ListUpdateListener.prototype.oninsert = ListUpdateListener.prototype.update;

  return ListUpdateListener;
});

/**
 * A list object, which contains numerically indexed values for use with other
 * MVC classes
 *
 * @return ListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/listmodel',['lib/extend', './model', './listupdatelistener', './type'], function(
    extend, Model, ListUpdateListener, Type) {

  /**
   * Constructor for an empty list
   *
   * @param array
   *          Optional. An array of elements which to fill the list with
   */
  function ListModel(array) {
    ListModel.superconstructor.call(this);
    this.length = 0;
    this.list = [];

    ListUpdateListener.bind(this, this.updateLength);

    if (Type.isArray(array)) {
      array.forEach(function(elem) {
        this.push(elem);
      }, this);
    }
  }
  extend(ListModel, Model);
  ListModel.prototype.EVENTS = {
    'reset': true,
    'insert': true,
    'remove': true,
    'resize': true
  };

  /**
   * push() function, which appends an object to the end of the list
   *
   * @param object
   *          an object which will be appended to the list
   * @return the new length of the array. undefined on failure
   */
  ListModel.prototype.push = function(object) {
    var retval;

    retval = this.list.push(object);

    this.emit('insert', {
      id: this.list.length - 1,
      object: object
    });

    return retval;
  };

  /**
   * remove the last element of the array and returns it
   *
   * @return the previously last element of the array, which has been removed
   *         during this function call
   */
  ListModel.prototype.pop = function() {
    var object;

    object = this.list.pop();

    this.emit('remove', {
      id: this.list.length,
      object: object
    });

    return object;
  };

  /**
   * insert an object at the specified index
   *
   * @param index
   *          the index at which to insert the object
   * @param object
   *          the object, which will take the specified index after insertion
   * @return undefined on failure, the inserted object
   */
  ListModel.prototype.insert = function(index, object) {
    if (index >= 0 && index <= this.list.length) {
      this.list.splice(index, 0, object);

      this.emit('insert', {
        id: index,
        object: object
      });

      return object;
    }
    return undefined;
  };

  /**
   * removes the object at the specified index from the list
   *
   * @param index
   *          the index from which to remove from the list
   * @return the removed object
   */
  ListModel.prototype.remove = function(index) {
    var object;

    if (index >= 0 && index < this.list.length) {
      object = this.list.splice(index, 1)[0];

      this.emit('remove', {
        id: index,
        object: object
      });

      return object;
    }

    return undefined;
  };

  /**
   * removes everything in the array.
   */
  ListModel.prototype.clear = function() {
    while (this.length) {
      this.pop();
    }
    this.emit('reset');
  };

  /**
   * finds the index of an object, if available.
   *
   * @param object
   *          the object to look for
   * @return the index of the object in the array, or -1 otherwise
   */
  ListModel.prototype.indexOf = function(object) {
    return this.list.indexOf(object);
  };

  /**
   * Return true if the object is in the list, false otherwise
   *
   * @param object
   *          the object to look for
   * @return true if the object is in the list, false otherwise
   */
  ListModel.prototype.includes = function(object) {
    return this.list.indexOf(object) !== -1;
  };

  /**
   * access the element at the specified index
   *
   * @param index
   *          the index within the list
   * @return the object at the specified index
   */
  ListModel.prototype.get = function(index) {
    return this.list[index];
  };

  /**
   * overwrites (i.e. removes and inserts) an object at the specified index
   *
   * @param index
   *          the index within the list
   * @param object
   *          the object with which to overwrite the index
   * @return the inserted object, or undefined on failure
   */
  ListModel.prototype.set = function(index, object) {
    if (index >= 0 && index < this.list.length) {
      this.remove(index);
      this.insert(index, object);
      return object;
    }

    return undefined;
  };

  /**
   * erase every instance of an object from the list
   *
   * @param object
   *          the object to erase from the list
   * @return the number of removed objects. 0 if none found, undefined on
   *         failure
   */
  ListModel.prototype.erase = function(object) {
    var num, index;
    num = 0;

    while ((index = this.indexOf(object)) >= 0) {
      if (this.remove(index) === object) {
        num += 1;
      }
    }

    return num;
  };

  /**
   * for each element in the list, run the specified function. The return values
   * of the function are accumulated and returned as an array
   *
   * @param callback
   *          function(object, index, list)
   * @param thisArg
   *          Optional. Value to use as this when executing callback
   * @return an array of the functions return values
   */
  ListModel.prototype.map = function(callback, thisArg) {
    var index, ret;

    thisArg = thisArg || undefined;
    ret = [];

    for (index = 0; index < this.length; index += 1) {
      ret.push(callback.call(thisArg, this.get(index), index, this));
    }

    return ret;
  };

  /**
   * returns the contents of the list as an array
   *
   * @return the contents of the list as an array
   */
  ListModel.prototype.asArray = function() {
    return this.list.slice(0);
  };

  /**
   * update the length variable of the list. Used internally.
   */
  ListModel.prototype.updateLength = function() {
    if (this.length !== this.list.length) {
      this.length = this.list.length;
      this.emit('resize');
    }
  };

  /**
   * makes this instance of ListModel readonly
   */
  ListModel.prototype.makeReadonly = function() {
    this.push = undefined;
    this.pop = undefined;
    this.insert = undefined;
    this.remove = undefined;
    this.clear = undefined;
    this.erase = undefined;
  };

  /**
   * save the current state to a data object for serialization. The data object
   * is supposed to be compact, i.e. a native list
   *
   * @return a list that can be used to restore the current list state
   */
  ListModel.prototype.save = function() {
    var data;
    /*
     * Note to self: ListModel ignores the default data object format in favor
     * of a list representation. Types aren't checked, so in the worst case,
     * restore() will fail dramatically
     */

    if (this.list.every(function(element) {
      return Type.isFunction(element.save);
    })) {
      // everything is serializable
      data = this.list.map(function(element) {
        try {
          return element.save();
        } catch (e) {
          console.error('ListModel.save() failed with error: ');
          console.error(e.stack);
          throw new Error('ListModel.save() failed');
        }
      });
    } else {
      // just return the objects themselves, since they're not serializable.
      // I don't see an elegant way to enable structs and atomic types to use
      // this feature.
      data = this.asArray();
    }

    return data;
  };

  /**
   * restore the list state from a previously saved data object (see save())
   *
   * @param data
   * @param ElementModel
   *          a constructor for the element, which has to be a subclass of
   *          Model, or a factory function, which takes the restore data and
   *          returns a new SomethingModel() instance, but doesn't call
   *          restore() itself.
   * @return true on success, false otherwise
   */
  ListModel.prototype.restore = function(data, ElementModel) {
    if (!data || !Type.isArray(data)) {
      return false;
    }

    this.clear();

    if (Type.isFunction(ElementModel)) {
      // path for constructor/Model types
      return data.every(function(element, index) {
        var instance;
        try {
          if (extend.isSubclass(ElementModel, Model)) {
            instance = new ElementModel();
          } else {
            instance = ElementModel(element);
          }
          if (!instance.restore(element)) {
            return false;
          }
          while (this.length < index) {
            this.push(undefined);
          }
          this.push(instance);
          return true;
        } catch (e) {
          console.error('ListModel.restore() failed for an element:');
          console.error(element);
          console.error(e.stack);
          return false;
        }
      }, this);
    }

    // path for raw types
    data.forEach(function(element, index) {
      while (this.length < index) {
        this.push(undefined);
      }
      this.push(element);
    }, this);
    return true;
  };

  ListModel.prototype.SAVEFORMAT = [/* anything */];

  return ListModel;
});

/**
 * SortedReferenceListModel:
 *
 * @return SortedReferenceListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/sortedreferencelistmodel',['lib/extend', './listmodel'], function(extend, ListModel) {
  /**
   * @param list
   *          a ListModel instance
   * @param sortFunction
   *          Optional. A sort function to use for sorting the lists
   * @param unique
   *          Optional. If true, each object will only be inserted once.
   *          subsequent insertions are ignored. Defaults to 'false'. NOTE:
   *          Removing the second element removes ALL elements of this type! Be
   *          careful when you use it.
   */
  function SortedReferenceListModel(list, sortFunction, unique) {
    SortedReferenceListModel.superconstructor.call(this);

    this.makeReadonly();

    if (list === undefined) {
      throw new Error('SortedReferenceListModel: list argument is missing');
    }

    if (sortFunction === undefined) {
      sortFunction = SortedReferenceListModel.ascending;
    }

    this.refList = list;
    this.sortFunction = sortFunction;
    this.unique = unique || false;

    list.map(function(element) {
      SortedReferenceListModel.insertElement(this, element);
    }, this);

    list.registerListener(this);
  }
  extend(SortedReferenceListModel, ListModel);

  /**
   * Callback function. Also inserts the inserted element into the sorted list,
   * at the correct position
   *
   * @param emitter
   *          Should be this.refList
   * @param event
   *          'insert'
   * @param data
   *          a data object, as emitted by insert() from the original list
   */
  SortedReferenceListModel.prototype.oninsert = function(emitter, event, data) {
    if (emitter === this.refList) {
      SortedReferenceListModel.insertElement(this, data.object);
    }
  };

  /**
   * Callback function. Also removes the removed element from the sorted list
   *
   * @param emitter
   *          Should be this.refList
   * @param event
   *          'remove'
   * @param data
   *          a data object, as emitted by remove() from the original list
   */
  SortedReferenceListModel.prototype.onremove = function(emitter, event, data) {
    if (emitter === this.refList) {
      SortedReferenceListModel.removeElement(this, data.object);
    }
  };

  /**
   * default sort function, for ascending order
   *
   * @param a
   *          the first object
   * @param b
   *          the second object
   * @return the ordering relation between the two, i.e. -1, 0 or +1
   */
  SortedReferenceListModel.ascending = function(a, b) {
    switch (true) {
    case a > b:
      return 1;
    case a < b:
      return -1;
    default:
      return 0;
    }
  };

  /**
   * alternative sort function, for descending order
   *
   * @param a
   *          the first object
   * @param b
   *          the second object
   * @return the ordering relation between the two, i.e. -1, 0 or +1
   */
  SortedReferenceListModel.descending = function(a, b) {
    return -SortedReferenceListModel.ascending(a, b);
  };

  /**
   * insert an element into a sorted list
   *
   * @param list
   *          the sorted list into which to insert the element
   * @param element
   *          the element to insert into the list
   */
  SortedReferenceListModel.insertElement = function(list, element) {
    var index = SortedReferenceListModel.findPosition(list, element);

    if (list.unique && index !== 0) {
      if (list.sortFunction(list.get(index - 1), element) === 0) {
        return;
      }
    }

    SortedReferenceListModel.superclass.insert.call(list, index, element);
  };

  /**
   * Remove an element from a sorted list
   *
   * @param list
   *          the list from which to remove one occurence of the element
   * @param element
   *          the element to remove from the list
   */
  SortedReferenceListModel.removeElement = function(list, element) {
    var index = list.indexOf(element);
    if (index >= 0) {
      SortedReferenceListModel.superclass.remove.call(list, index);
    }
  };

  /**
   * A simple binary search for the position at which to place the next element.
   * Since we're using >=0 in the second code path, similar values are always
   * appended.
   *
   * @param list
   *          the ListModel instance into which to insert the element. Should be
   *          "this" when called.
   * @param element
   *          the element to insert
   * @param begin
   *          Optional. The index at which to begin the search, inclusive.
   * @param end
   *          Optional. The index at which to end the search, exclusive.
   * @return the position at which an element is to be inserted. Can range from
   *         0 to list.length.
   */
  SortedReferenceListModel.findPosition = function(list, element, begin, end) {
    var relation, mid;

    if (begin === undefined) {
      begin = 0;
    }
    if (end === undefined) {
      end = list.length;
    }

    if (begin === end) {
      return begin;
    }

    mid = (begin + end) >> 1;

    relation = list.sortFunction(list.get(mid), element);

    if (relation > 0) {
      return SortedReferenceListModel.findPosition(list, element, begin, mid);
    }

    return SortedReferenceListModel.findPosition(list, element, mid + 1, end);
  };

  return SortedReferenceListModel;
});

/**
 * BinningReferenceListModel: Group elements of another list in bins while
 * preserving the order of items within the bins. This was primarily intended
 * for grouping matches by their group.
 *
 * @return BinningReferenceListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/binningreferencelistmodel',['lib/extend', './listmodel', './type', './sortedreferencelistmodel'], //
function(extend, ListModel, Type, SortedReferenceListModel) {
  /**
   * Constructor
   *
   * @param list
   *          a ListModel instance, preferably sorted for higher efficiency
   * @param binningFunction
   *          a function
   */
  function BinningReferenceListModel(list, binningFunction) {
    BinningReferenceListModel.superconstructor.call(this);

    this.makeReadonly();

    if (list === undefined) {
      throw new Error('list argument is missing');
    }

    if (binningFunction === undefined) {
      throw new Error('binning function is missing');
    }

    this.binningFunction = binningFunction;
    this.bins = new ListModel();
    this.sortedBins = new SortedReferenceListModel(this.bins,
        this.binSortFunction, true);
    this.refList = list;

    this.refList.map(function(element, index) {
      BinningReferenceListModel.insertElement(this, index);
    }, this);

    this.refList.registerListener(this);
  }
  extend(BinningReferenceListModel, ListModel);

  /**
   * @return a readonly ListModel instance, which contains the names of all
   *         bins, in the bin order.
   */
  BinningReferenceListModel.prototype.getBinNames = function() {
    return this.sortedBins;
  };

  /**
   * creates a new empty bin
   *
   * @param binName
   *          the name of the bin. Preferably a numerical value
   * @param createIfMissing
   *          if true, the bin is created if it's missing
   * @return the bin (i.e. an empty ListModel instance), or undefined if it
   *         couldn't be found and shouldn't be created
   */
  BinningReferenceListModel.prototype.getBin = function(binName) {
    var index;

    index = this.sortedBins.indexOf(binName);

    if (index === -1) {
      return undefined;
    }

    return this.get(index);
  };

  /**
   * Since bins are never allowed to be empty, a new bin is instantiated with an
   * object. This avoids event race conditions
   *
   * @param binName
   *          the name of the newly created bin
   * @param object
   *          the first object in the newly created bin
   * @return the newly created bin (a ListModel), or undefined if the bin
   *         already exists
   */
  BinningReferenceListModel.prototype.createBinWithObject = function(binName,
      object) {
    var index, bin;

    bin = undefined;
    index = this.sortedBins.indexOf(binName);

    if (index === -1) {
      this.bins.push(binName);
      index = this.sortedBins.indexOf(binName);

      bin = new ListModel([object]);
      BinningReferenceListModel.superclass.insert.call(this, index, bin);
    }

    return bin;
  };

  /**
   * @param binIndex
   *          the index of the bin, as used in this.get()
   *
   * @return the name of the bin, as returned by the binning function for each
   *         element in the respective bin
   */
  BinningReferenceListModel.prototype.getBinName = function(binIndex) {
    return this.sortedBins.get(binIndex);
  };

  /**
   * Remnove
   *
   * @param binName
   *          the name of the bin
   */
  BinningReferenceListModel.prototype.removeEmptyBin = function(binName) {
    var binIndex, sortedBinIndex;
    binIndex = this.bins.indexOf(binName);
    sortedBinIndex = this.sortedBins.indexOf(binName);

    if (binIndex !== -1 && sortedBinIndex !== -1) {
      if (this.get(sortedBinIndex).length === 0) {
        this.bins.remove(binIndex);
        BinningReferenceListModel.superclass.remove.call(this, sortedBinIndex);
      }
    }
  };

  /**
   * insert an element into the correct bin of the BinningReferenceListModel
   * "list". The bin is created if not already existant.
   *
   * @param list
   *          a BinningReferenceListModel instance to push the element into
   * @param elementIndex
   *          the index of the element inside list.refList.
   * @return the bin into which the element was inserted.
   */
  BinningReferenceListModel.insertElement = function(list, elementIndex) {
    var bin, binName, element, nextElementIndex;

    element = list.refList.get(elementIndex);
    binName = list.binningFunction(element);
    bin = list.getBin(binName);

    if (bin === undefined) {
      bin = list.createBinWithObject(binName, element);
    } else {

      nextElementIndex = BinningReferenceListModel.getNextBinElementIndex(list,
          elementIndex, binName);

      if (nextElementIndex === -1) {
        nextElementIndex = bin.length;
      } else {
        nextElementIndex = bin.indexOf(list.refList.get(nextElementIndex));
        if (nextElementIndex === -1) {
          nextElementIndex = bin.length;
        }
      }

      bin.insert(nextElementIndex, element);
    }

    return bin;
  };

  /**
   * find the element which is supposed to follow an element in the bin
   *
   * @param list
   *          the BinningReferenceListModel instance
   * @param begin
   *          the index after which to look for similar elements
   * @param binName
   *          the name of the bin
   * @return the index at which to find the next element of the same bin, or -1
   *         if such an element does not exist.
   */
  BinningReferenceListModel.getNextBinElementIndex = function(list, begin,
      binName) {
    var index;

    for (index = begin + 1; index < list.refList.length; index += 1) {
      if (list.binningFunction(list.refList.get(index)) === binName) {
        return index;
      }
    }

    return -1;
  };

  /**
   * remove an element from its bin
   *
   * @param list
   *          the BinningReferenceListModel instance
   * @param element
   *          the element to remove
   */
  BinningReferenceListModel.removeElement = function(list, element) {
    var bin, binName, index;

    binName = list.binningFunction(element);
    bin = list.getBin(binName);

    if (bin === undefined) {
      return;
    }

    index = bin.indexOf(element);
    if (index !== -1) {
      bin.remove(index);
      if (bin.length === 0) {
        list.removeEmptyBin(binName);
      }
    }
  };

  /**
   * Callback function. Also inserts the inserted element into the sorted list,
   * at the correct position
   *
   * @param emitter
   *          Should be this.refList
   * @param event
   *          'insert'
   * @param data
   *          a data object, as emitted by insert() from the original list
   */
  BinningReferenceListModel.prototype.oninsert = function(emitter, event, data) //
  {
    if (emitter === this.refList) {
      BinningReferenceListModel.insertElement(this, data.id);
    }
  };

  /**
   * Callback function. Also removes the removed element from the sorted list
   *
   * @param emitter
   *          Should be this.refList
   * @param event
   *          'remove'
   * @param data
   *          a data object, as emitted by remove() from the original list
   */
  BinningReferenceListModel.prototype.onremove = function(emitter, event, data) //
  {
    if (emitter === this.refList) {
      BinningReferenceListModel.removeElement(this, data.object);
    }
  };

  /**
   * General sort function for Numbers, Strings, Dates, etc. Handles Numbers
   * differently.
   *
   * @param a
   *          a bin name
   * @param b
   *          another bin name
   * @return +1 is a > b, -1 if a < b, 0 otherwise
   */
  BinningReferenceListModel.prototype.binSortFunction = function(a, b) {
    if (Type.isNumber(a) && Type.isNumber(b)) {
      return a - b;
    }
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  };

  return BinningReferenceListModel;
});

/**
 * A model which has an index, e.g. inside an indexed list
 *
 * @return IndexedModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/indexedmodel',['lib/extend', 'core/model'], function(extend, Model) {

  /**
   * Constructor
   *
   * @param id
   *          a preferably unique numeric id
   */
  function IndexedModel(id) {
    IndexedModel.superconstructor.call(this);

    IndexedModel.prototype.setID.call(this, id);
  }
  extend(IndexedModel, Model);

  /**
   * retrieve the id of this object within a certain set of objects
   *
   * @return the id of this object within a certain set of objects
   */
  IndexedModel.prototype.getID = function() {
    return this.id;
  };

  /**
   * change the id
   *
   * @param id
   *          a preferably unique numeric id
   */
  IndexedModel.prototype.setID = function(id) {
    if (id === undefined) {
      id = -1;
    }
    if (id !== this.id) {
      this.id = id;
      this.emit('update');
    }
  };

  /**
   * save the current state to an object
   *
   * @return the current state, as a data object
   */
  IndexedModel.prototype.save = function() {
    var data = IndexedModel.superclass.save.call(this);

    data.id = this.id;

    return data;
  };

  /**
   * restore the current state from an object
   *
   * @param data
   *          a stored state
   * @return true on success, false otherwise
   */
  IndexedModel.prototype.restore = function(data) {
    if (!IndexedModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.id = data.id;

    return true;
  };

  IndexedModel.prototype.SAVEFORMAT = Object
      .create(IndexedModel.superclass.SAVEFORMAT);
  IndexedModel.prototype.SAVEFORMAT.id = Number;

  return IndexedModel;
});

/**
 * MatchModel, a representation of a single match between teams
 *
 * @return MatchModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/matchmodel',['lib/extend', './indexedmodel', './type'], function(extend,
    IndexedModel, Type) {
  /**
   * Constructor
   *
   * @param teams
   *          an array of team ids
   * @param id
   *          unique id of the match within its group
   * @param group
   *          identifier of the round, phase, pool, ...
   */
  function MatchModel(teams, id, group) {
    MatchModel.superconstructor.call(this, id);

    if (teams === undefined) {
      teams = [];
    }
    if (group === undefined) {
      group = -1;
    }

    this.teams = teams.slice();
    this.length = this.teams.length;
    this.group = group;
  }
  extend(MatchModel, IndexedModel);

  MatchModel.prototype.EVENTS = {
    'update': true,
    'finish': true
  };

  /**
   *
   * @param pos
   *          the teams position within the match
   * @return the team at position pos
   */
  MatchModel.prototype.getTeamID = function(pos) {
    /*
     * no additional check necessary. The array will return 'undefined' for us
     */
    // if (pos === undefined || pos < 0 || pos >= this.length) {
    // return undefined;
    // }
    return this.teams[pos];
  };

  /**
   * return the group of the match within the tournament
   *
   * @return the group of the match within the tournament
   */
  MatchModel.prototype.getGroup = function() {
    return this.group;
  };

  /**
   * If isResult() is false, `this.score` does not exist and this.finish() still
   * works.
   *
   * @return true if an inherited object is a MatchResult, false otherwise.
   */
  MatchModel.prototype.isResult = function() {
    return this.score !== undefined || !this.finish;
  };

  /**
   * @return true if this is not a result, all team IDs are unique and all team
   *         IDs are valid (not undefined). false otherwise.
   */
  MatchModel.prototype.isRunningMatch = function() {
    var valid;

    valid = true;

    if (valid) {
      valid = !this.isResult();
    }

    if (valid) {
      valid = this.teams.every(function(teamID) {
        return Type.isNumber(teamID);
      });
    }

    if (valid) {
      valid = this.teams.every(function(teamID, index) {
        return this.teams.slice(index + 1).indexOf(teamID) === -1;
      }, this);
    }

    return valid;
  };

  /**
   * disable setID() functionality
   */
  MatchModel.prototype.setID = undefined;

  /**
   * finishes a match with a certain result
   *
   * @param points
   *          An array of scored points for each team. Lengths have to match
   * @return a MatchResult instance representing the accepted result. undefined
   *         otherwise
   */
  MatchModel.prototype.finish = function(points) {
    var result, MatchResult;

    if (!points || points.length !== this.length) {
      console.error("MatchModel.finish(): lengths don't match");
      return undefined;
    }

    // Circular dependency. Require MatchResult directly
    MatchResult = require('core/matchresult');
    result = new MatchResult(this, points);

    this.emit('finish', result);

    return result;
  };

  /**
   * save the state into a data object
   *
   * @return a data object
   */
  MatchModel.prototype.save = function() {
    var data = MatchModel.superclass.save.call(this);

    data.g = this.group;
    data.t = this.teams.map(function(team) {
      if (team && team.getID) {
        return team.getID();
      } else if (team === undefined) {
        return -1;
      } else {
        return team;
      }
    });

    return data;
  };

  /**
   * restore from a saved state. Copies teams as Team IDs.
   *
   * @param data
   *          a saved state
   * @return true on success, false otherwise
   */
  MatchModel.prototype.restore = function(data) {
    if (!MatchModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.group = data.g;

    this.teams.splice(0);
    data.t.forEach(function(t) {
      this.teams.push(t === -1 ? undefined : t);
    }, this);
    this.length = this.teams.length;

    return true;
  };

  MatchModel.prototype.SAVEFORMAT = Object
      .create(MatchModel.superclass.SAVEFORMAT);
  MatchModel.prototype.SAVEFORMAT.g = Number;
  MatchModel.prototype.SAVEFORMAT.t = [Number];

  return MatchModel;
});

/**
 * MatchResult, a simple match results class
 *
 * @return MatchResult
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/matchresult',['lib/extend', './matchmodel'], function(extend, MatchModel) {
  /**
   * Constructor
   *
   * @param match
   *          a MatchModel instance of which the result is to be kept
   * @param score
   *          an array of scored points
   */
  function MatchResult(match, score) {
    MatchResult.superconstructor.call(this, match && match.teams, match
        && match.id, match && match.group);

    // empty default constructor for list-based construction
    if (score === undefined) {
      this.score = [];
      return;
    }

    if (this.teams.length !== score.length) {
      throw new Error('MatchResult(): array lengths differ: '
          + this.teams.length + '<>' + score.length);
    }

    this.score = score.slice(0);
  }
  extend(MatchResult, MatchModel);

  /**
   * Disable the finish() function
   */
  MatchResult.prototype.finish = undefined;

  /**
   * @return true if this result is a bye, false otherwise
   */
  MatchResult.prototype.isBye = function() {
    return this.isResult() && this.length === 2
        && this.getTeamID(0) === this.getTeamID(1);
  };

  /**
   * crude save function as if it was ripped right out of the Model class.
   *
   * @return a serializable data object on success, undefined otherwise
   */
  MatchResult.prototype.save = function() {
    var data = MatchResult.superclass.save.call(this);

    data.s = this.score;

    return data;
  };

  /**
   * restore from a serialized data object
   *
   * @param data
   *          the data object
   * @return true on success, false otherwise
   */
  MatchResult.prototype.restore = function(data) {
    if (!MatchResult.superclass.restore.call(this, data)) {
      return false;
    }

    this.score = data.s;

    return true;
  };

  MatchResult.prototype.SAVEFORMAT = Object
      .create(MatchModel.superclass.SAVEFORMAT);
  MatchResult.prototype.SAVEFORMAT.s = [Number];

  return MatchResult;
});

/**
 * ByeResult
 *
 * @return ByeResult
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/byeresult',['lib/extend', './matchresult', './matchmodel'], function(extend,
    MatchResult, MatchModel) {
  /**
   * Constructor for auto-creation of a bye instance, which contains all
   * relevant data, and matches the MatchResult interface.
   *
   * If both teams have the same id, it's a bye
   *
   * save() and restore() work with the MatchResult, too, which is necessary for
   * tournamentmodel.save()/restore(). Corrections, on the other hand, are not
   * supposed to be used with byes, but can work, too.
   *
   * @param teamid
   *          the internal id of the team which gets the bye
   * @param score
   *          the score of the bye, a two-element-array. (e.g. [13, 7]). For
   *          displaying only, not supposed to be used for actual result
   *          calculations.
   * @param id
   *          id of the bye. Similar to the match id.
   * @param group
   *          the group of the bye. Similar to the match group.
   *
   */
  function ByeResult(teamid, score, id, group) {
    ByeResult.superconstructor.call(this, new MatchModel([teamid, teamid], id,
        group), score);
  }
  extend(ByeResult, MatchResult);

  return ByeResult;
});

/**
 * An abstract view class
 *
 * @return View
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/view',['lib/extend', 'core/listener', 'core/model'], function(extend,
    Listener, Model) {
  /**
   * Displays a model and updates on changes to it.
   *
   * @param model
   *          The associated instance of the Model class
   * @param $view
   *          A jQuery object which is represented by this view
   */
  function View(model, $view) {
    model = model || new Model();
    View.superconstructor.call(this, model);

    if ($view === undefined || $view.length === 0) {
      console.error('View: $view is empty or undefined:');
      console.error($view);
      if ($view && $view.selector) {
        console.error($view ? 'selector: ' + $view.selector : '');
      }
    }

    this.model = model;
    this.$view = $view;
  }
  extend(View, Listener);

  /**
   * resets the whole view
   */
  View.prototype.reset = function() {
    //
  };

  /**
   * update the whole view
   */
  View.prototype.update = function() {
    //
  };

  /**
   * destroy the whole view by removing its element from the DOM and
   * unregistering the default event listener (disconnect from this.model)
   *
   * Ideas:
   *
   * A View should not be destroyed and re-instantiated in place on the same DOM
   * element, that's what reset() is for
   *
   * This function should effectively destroy the view, leaving nothing behind.
   * That's intended for deletion from lists etc., where elements are
   * permanently removed and replaced with new elements.
   *
   */
  View.prototype.destroy = function() {
    View.superclass.destroy.call(this);
    this.$view.remove();
  };

  return View;
});

/**
 * ClassView, a class which sets CSS classes according to
 *
 * @return ClassView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/classview',['lib/extend', './view'], function(extend, View) {
  /**
   * Constructor
   *
   * @param model
   *          a boolean ValueModel instance
   * @param $view
   *          the DOM element for which to change the classes
   * @param onclass
   *          Optional. the class when model.get() returns true
   * @param offclass
   *          Optional. the class when model.get() returns false
   */
  function ClassView(model, $view, onclass, offclass) {
    ClassView.superconstructor.call(this, model, $view);

    this.onclass = onclass || undefined;
    this.offclass = offclass || undefined;

    this.update();
  }
  extend(ClassView, View);

  /**
   * set or remove the classes according to model.get()
   */
  ClassView.prototype.update = function() {
    if (this.model.get()) {
      if (this.onclass) {
        this.$view.addClass(this.onclass);
      }
      if (this.offclass) {
        this.$view.removeClass(this.offclass);
      }
    } else {
      if (this.onclass) {
        this.$view.removeClass(this.onclass);
      }
      if (this.offclass) {
        this.$view.addClass(this.offclass);
      }
    }
  };

  /**
   * Callback function to monitor value changes
   */
  ClassView.prototype.onupdate = function() {
    this.update();
  };

  return ClassView;
});

/**
 * CombinedReferenceListModel:
 *
 * @return CombinedReferenceListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/combinedreferencelistmodel',['lib/extend', './listmodel'], function(extend, ListModel) {
  /**
   * @param list1
   *          a ListModel instance
   * @param list2
   *          a ListModel instance. The contents of every argument of this list
   *          are merged into a single list (i.e. this)
   */
  function CombinedReferenceListModel(list1, list2) {
    var i;
    CombinedReferenceListModel.superconstructor.call(this);

    this.makeReadonly();

    if (list1 === undefined) {
      throw new Error('No lists to combine');
    }

    this.refLists = [];
    this.listOffsets = [];
    for (i = 0; i < arguments.length; i += 1) {
      this.refLists.push(arguments[i]);
      this.listOffsets.push(0);
    }

    this.refLists.map(function(refList, listID) {
      refList.map(function(element, elementID) {
        CombinedReferenceListModel.insertElement(this, listID, elementID);
      }, this);

      refList.registerListener(this);
    }, this);

  }
  extend(CombinedReferenceListModel, ListModel);

  /**
   * Callback function. Also inserts the inserted element into the sorted list,
   * at the correct position
   *
   * @param emitter
   *          Should be this.refList
   * @param evt
   *          'insert'
   * @param data
   *          a data object, as emitted by insert() from the original list
   */
  CombinedReferenceListModel.prototype.oninsert = function(emitter, evt, data) {
    var listIndex = this.refLists.indexOf(emitter);
    if (listIndex !== -1) {
      CombinedReferenceListModel.insertElement(this, listIndex, data.id);
    }
  };

  /**
   * Callback function. Also removes the removed element from the sorted list
   *
   * @param emitter
   *          Should be this.refList
   * @param evt
   *          'remove'
   * @param data
   *          a data object, as emitted by remove() from the original list
   */
  CombinedReferenceListModel.prototype.onremove = function(emitter, evt, data) {
    var listIndex = this.refLists.indexOf(emitter);
    if (listIndex !== -1) {
      CombinedReferenceListModel.removeElement(this, listIndex, data.id);
    }
  };

  /**
   * insert an element into a sorted list
   *
   * @param listID
   *          the sorted list into which to insert the element
   * @param elementID
   *          the element to insert into the list
   */
  CombinedReferenceListModel.insertElement = function(list, listID, elementID) {
    var index = list.findPosition(listID, elementID);

    if (index !== -1) {
      CombinedReferenceListModel.superclass.insert.call(list, index,
          list.refLists[listID].get(elementID));
      list.increaseOffsets(listID);
    }
  };

  /**
   * Remove an element from a sorted list
   *
   * @param list
   *          the list from which to remove one occurence of the element
   * @param element
   *          the element to remove from the list
   */
  CombinedReferenceListModel.removeElement = function(list, listID, elementID) {
    var index = list.findPosition(listID, elementID);
    if (index !== -1) {
      CombinedReferenceListModel.superclass.remove.call(list, index);
      list.reduceOffsets(listID);
    }
  };

  /**
   *
   * @param listID
   *          the id of the original list inside the combined list (i.e. the
   *          argument position at construction)
   * @param elementID
   *          the index of the element inside its original list
   * @return the supposed index of the element inside the combined list, or -1
   *         if it shouldn't be inside it
   */
  CombinedReferenceListModel.prototype.findPosition = function(listID,
      elementID) {
    return this.listOffsets[listID] + elementID;
  };

  CombinedReferenceListModel.prototype.increaseOffsets = function(
      startingListIndex) {
    var id;
    for (id = startingListIndex + 1; id < this.listOffsets.length; id += 1) {
      this.listOffsets[id] += 1;
    }
  };

  CombinedReferenceListModel.prototype.reduceOffsets = function(
      startingListIndex) {
    var id;
    for (id = startingListIndex + 1; id < this.listOffsets.length; id += 1) {
      this.listOffsets[id] -= 1;
    }
  };

  return CombinedReferenceListModel;
});

/**
 * An abstract controller class
 *
 * @return Controller
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/controller',[],function() {
  /**
   * Controls a model, which is referenced by its view.
   *
   * Please provide additional functions for controlling and event callback,
   * e.g. after button presses
   *
   * @param view
   *          An associated instance of View
   */
  function Controller(view) {
    this.model = view.model;
    this.view = view;
  }

  Controller.prototype.destroy = function() {
  };

  return Controller;
});

/**
 * CorrectionModel: store and serialize/deserialize a correction, i.e. the
 * change of a match result.
 *
 * @return CorrectionModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/correctionmodel',['lib/extend', './model', './matchresult'], function(extend, Model,
    MatchResult) {
  /**
   * Constructor
   *
   * @param oldResult
   *          the result before the correction
   * @param newResult
   *          the result after the correction
   */
  function CorrectionModel(oldResult, newResult) {
    CorrectionModel.superconstructor.call(this);

    if (oldResult === undefined) {
      this.before = new MatchResult();
    } else if (oldResult instanceof MatchResult) {
      this.before = oldResult;
    } else {
      throw new Error('CorrectionModel: oldResult is not a MatchResult!');
    }

    if (newResult === undefined) {
      this.after = new MatchResult();
    } else if (newResult instanceof MatchResult) {
      this.after = newResult;
    } else {
      throw new Error('CorrectionModel: newResult is not a MatchResult!');
    }
  }
  extend(CorrectionModel, Model);

  /**
   * This model does not emit events. It's for storage only.
   */
  CorrectionModel.prototype.EVENTS = {};

  /**
   * gather the data and return it as a serializable object
   *
   * @return a serializable data object
   */
  CorrectionModel.prototype.save = function() {
    var data = CorrectionModel.superclass.save.call(this);

    data.b = this.before.save();
    data.a = this.after.save();

    return data;
  };

  /**
   * restore a previous state, which has been saved with the 'save()' function
   *
   * @param data
   *          a deserialized data object
   * @return true on success, false otherwise
   */
  CorrectionModel.prototype.restore = function(data) {
    if (!CorrectionModel.superclass.restore.call(this, data)) {
      return false;
    }

    if (!this.before.restore(data.b)) {
      return false;
    }

    if (!this.after.restore(data.a)) {
      return false;
    }

    return true;
  };

  CorrectionModel.prototype.SAVEFORMAT = Object
      .create(CorrectionModel.superclass.SAVEFORMAT);
  CorrectionModel.prototype.SAVEFORMAT.a = Object;
  CorrectionModel.prototype.SAVEFORMAT.b = Object;

  return CorrectionModel;
});

/**
 * MatchReferenceModel: Reference a match in all regards, but map the teams from
 * their tournament-specific id to the global id.
 *
 * @return MatchReferenceModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/matchreferencemodel',['lib/extend', './matchmodel'], function(extend, MatchModel) {
  /**
   * Constructor
   *
   * @param match
   *          a valid match to reference
   * @param teamlist
   *          a list of teams which maps an internal id (index within the
   *          tournament) the the external id (global team id)
   */
  function MatchReferenceModel(match, teamlist) {
    var teams;

    if (teamlist) {
      teams = match.teams.map(function(teamid) {
        return teamlist.get(teamid);
      });
    } else {
      teams = match.teams.slice();
    }
    MatchReferenceModel.superconstructor.call(this, teams, match.id,
        match.group);

    this.match = match;
    match.registerListener(this);
  }
  extend(MatchReferenceModel, MatchModel);

  /**
   * forward the finish()-call to the referenced match
   *
   * @param score
   *          an array of points for each team. Lengths have to match!
   * @return true on success, undefined otherwise
   */
  MatchReferenceModel.prototype.finish = function(score) {
    if (this.match.finish(score) === undefined) {
      return undefined;
    }
    return true;
  };

  /**
   * Forward the "finish"-event to notify listeners about a finished match
   *
   * The re-emitted event does not contain the result of the match, which is to
   * be processed at the lowest level, i.e. within the tournament.
   *
   * This function also unregisters from the match itself to avoid memory leaks.
   * The current specification disallows any events after 'finish'.
   */
  MatchReferenceModel.prototype.onfinish = function() {
    this.match.unregisterListener(this);
    this.emit('finish');
  };

  return MatchReferenceModel;
});

/**
 * ResultReferenceModel: Reference a result in all regards, but map the teams
 * from their tournament-specific id to the global id.
 *
 * @return ResultReferenceModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/resultreferencemodel',['lib/extend', './matchresult', './matchreferencemodel'], function(
    extend, MatchResult, MatchReferenceModel) {
  /**
   * Constructor
   *
   * @param result
   *          a MatchResult instance
   * @param teamlist
   *          a ListModel instance of team ids, which is used for team mapping
   */
  function ResultReferenceModel(result, teamlist) {
    var matchRef;

    if (result instanceof MatchResult) {
      matchRef = new MatchReferenceModel(result, teamlist);
      ResultReferenceModel.superconstructor.call(this, matchRef, result.score);
      this.result = result;
    } else {
      MatchReferenceModel.call(this, result, teamlist);
      this.finish = MatchReferenceModel.prototype.finish;
    }
  }
  extend(ResultReferenceModel, MatchResult);

  return ResultReferenceModel;
});

/**
 * CorrectionReferenceModel
 *
 * @return CorrectionReferenceModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/correctionreferencemodel',['lib/extend', './correctionmodel', './resultreferencemodel'], function(
    extend, CorrectionModel, ResultReferenceModel) {
  /**
   * Constructor
   */
  function CorrectionReferenceModel(correction, teamlist) {
    CorrectionReferenceModel.superconstructor.call(this,
        new ResultReferenceModel(correction.before, teamlist),
        new ResultReferenceModel(correction.after, teamlist));

    this.correction = correction;
  }
  extend(CorrectionReferenceModel, CorrectionModel);

  return CorrectionReferenceModel;
});

/**
 * A ListModel, which also adjusts the ids using setID
 *
 * @return IndexedListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/indexedlistmodel',['lib/extend', './listmodel', './listupdatelistener'], function(extend,
    ListModel, ListUpdateListener) {
  /**
   * Constructor for an empty list
   */
  function IndexedListModel() {
    IndexedListModel.superconstructor.call(this);

    ListUpdateListener.bind(this, this.updateIDs);
  }
  extend(IndexedListModel, ListModel);

  /**
   * update the ids, starting at the specified index
   *
   * @param data
   *          event callback data
   */
  IndexedListModel.prototype.updateIDs = function(data) {
    var index, startindex;

    if (data === undefined) {
      // 'reset' event, where no data is sent
      return;
    }

    startindex = data.id || 0;

    for (index = startindex; index < this.length; index += 1) {
      this.get(index).setID(index);
    }
  };

  return IndexedListModel;
});

/**
 * PropertyModel: Store values as keys and emit events upon update.
 *
 * Basically, this is an Emitter wrapped around a native Hash Object, so please
 * use string keys and primary data types (Strings, Numbers, Boolean)
 *
 * @return PropertyModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/propertymodel',['lib/extend', './model', './type'], function(extend, Model, Type) {
  /**
   * Constructor
   *
   * @param defaultProperties
   *          Optional. Native object from which to copy the initial properties
   */
  function PropertyModel(defaultProperties) {
    PropertyModel.superconstructor.call(this);

    this.props = {};

    // initialize with the init object, if available
    if (defaultProperties) {
      Object.keys(defaultProperties).forEach(function(key) {
        this.setProperty(key, defaultProperties[key]);
      }, this);
    }
  }
  extend(PropertyModel, Model);

  PropertyModel.prototype.EVENTS = {
    'update': true
  };

  /**
   * retrieve the value from the key
   *
   * @param key
   *          String. the key
   * @return the value which is stored under the key
   */
  PropertyModel.prototype.getProperty = function(key) {
    return this.props[key];
  };

  /**
   * store the value and emit an event if and only if the value has been changed
   * or the key was first inserted.
   *
   * @param key
   *          String. the key
   * @param value
   *          the value to store under the key
   * @return true on success, false otherwise
   */
  PropertyModel.prototype.setProperty = function(key, value) {
    if (this.getProperty(key) !== value) {
      if (Type.isString(value) || Type.isNumber(value)
          || Type.is(value, Boolean)) {
        this.props[key] = value;
        if (this.getProperty(key) === value) {
          this.emit('update', {
            key: key,
            value: value
          });
          return true;
        }
      } else {
        console.error('setProperty(): unsupported property type: '
            + Type(value));
      }
    }

    return false;
  };

  /**
   * retrieve the keys of this property
   *
   * @return an array of key names, i.e. an array of strings
   */
  PropertyModel.prototype.getPropertyKeys = function() {
    return Object.keys(this.props).sort();
  };

  /**
   * produce a readonly, functionless, unreferencing, serializable data object
   * that stores represents
   *
   * @return a data object
   */
  PropertyModel.prototype.save = function() {
    var data = PropertyModel.superclass.save.call(this);

    data.props = {};

    this.getPropertyKeys().forEach(function(key) {
      data.props[key] = this.getProperty(key);
    }, this);

    return data;
  };

  /**
   * restore the state from a data object. Keeps keys that aren't in data.
   *
   * @param data
   * @return true on success, false otherwise
   */
  PropertyModel.prototype.restore = function(data) {
    if (!PropertyModel.superclass.restore.call(this, data)) {
      return false;
    }

    Object.keys(data.props).forEach(function(key) {
      var val = data.props[key];
      this.setProperty(key, val);
    }, this);

    return true;
  };

  PropertyModel.prototype.SAVEFORMAT = Object
      .create(PropertyModel.superclass.SAVEFORMAT);
  PropertyModel.prototype.SAVEFORMAT.props = Object;

  return PropertyModel;
});

/**
 * UniqueListModel: A ListModel in which a value or reference is contained at
 * most once.
 *
 * @return UniqueListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/uniquelistmodel',['lib/extend', './listmodel'], function(extend, ListModel) {
  /**
   * Constructor
   *
   * @param array
   *          Optional. An array with elements which to fill the list with
   */
  function UniqueListModel(array) {
    UniqueListModel.superconstructor.call(this, array);
  }
  extend(UniqueListModel, ListModel);

  /**
   * push() function, which appends an object to the end of the list if it isn't
   * already contained
   *
   * @param object
   *          an object which will be appended to the list
   * @return the new length of the array. undefined on failure
   */
  UniqueListModel.prototype.push = function(object) {
    if (this.indexOf(object) !== -1) {
      return undefined;
    }
    return UniqueListModel.superclass.push.call(this, object);
  };

  /**
   * insert an object at the specified index if it isn't already contained
   *
   * @param index
   *          the index at which to insert the object
   * @param object
   *          the object, which will take the specified index after insertion
   * @return undefined on failure, true othwerise
   */
  UniqueListModel.prototype.insert = function(index, object) {
    if (this.indexOf(object) !== -1) {
      return undefined;
    }
    return UniqueListModel.superclass.insert.call(this, index, object);
  };

  /**
   * overwrites (i.e. removes and inserts) an object at the specified index if
   * it isn't already contained. If it is contained, the old value will remain
   * in the list.
   *
   * @param index
   *          the index within the list
   * @param object
   *          the object with which to overwrite the index
   * @return the inserted object, of undefined on failure
   */
  UniqueListModel.prototype.set = function(index, object) {
    if (this.indexOf(object) !== -1) {
      return undefined;
    }
    return UniqueListModel.superclass.set.call(this, index, object);
  };

  return UniqueListModel;
});

/**
 * RankingMapper: map internal team ids to external team ids, listen to and emit
 * update events, provide a get() function and cache the ranking results for
 * better performance.
 *
 * @return RankingMapper
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingmapper',['lib/extend', './model'], function(extend, Model) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance with internal ids
   * @param teams
   *          a ListModel instance which maps internal to external ids
   */
  function RankingMapper(ranking, teams) {
    RankingMapper.superconstructor.call(this);

    this.cache = undefined;
    this.ranking = ranking;
    this.teams = teams;

    ranking.registerListener(this);
  }
  extend(RankingMapper, Model);

  /**
   * translate internal ids (pos) to external ids
   *
   * @param rankingcomponent
   *          an array of internal ids, i.e. positions
   * @param map
   *          a ListModel instance which maps positions to values
   * @return an array of re-mapped ids
   */
  RankingMapper.translateIDs = function(rankingcomponent, map) {
    return rankingcomponent.map(function(pos) {
      return map.get(pos);
    });
  };

  /**
   * read a ranking object with internal ids and map all internal ids to
   * external ids. Remapping should only be performed on
   * ranking.get().displayOrder
   */
  RankingMapper.updateCache = function() {
    var ranks, newcache;

    ranks = this.ranking.get();
    newcache = {};

    Object.keys(ranks).forEach(function(key) {
      var values;

      if (key === 'ids') {
        values = RankingMapper.translateIDs(ranks[key], this.teams);
      } else {
        values = ranks[key].slice(0);
      }

      newcache[key] = values;
    }, this);

    this.cache = newcache;
  };

  /**
   * get the cached ranking or rebuild it if invalidated
   *
   * @return a ranking object
   */
  RankingMapper.prototype.get = function() {
    if (this.cache === undefined) {
      RankingMapper.updateCache.call(this);
    }

    return this.cache;
  };

  /**
   * force a rebuild of the ranking object (mapping only)
   */
  RankingMapper.prototype.invalidate = function() {
    this.cache = undefined;
  };

  /**
   * callback function
   */
  RankingMapper.prototype.onupdate = function() {
    this.invalidate();
    this.emit('update');
  };

  return RankingMapper;
});

/**
 * No Description
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/**
 * A model, which stores a value and emits update events when it's changed
 *
 * @return ValueModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/valuemodel',['lib/extend', 'core/model'], function(extend, Model) {

  /**
   * Constructor
   *
   * @param value
   *          the initial value
   */
  function ValueModel(value) {
    ValueModel.superconstructor.call(this);

    if (this.onupdate !== ValueModel.prototype.onupdate
        && this.bind === ValueModel.prototype.bind) {
      this.bind = undefined;
    }

    // don't call this.set, because set() can be overridden by a subclass
    ValueModel.prototype.set.call(this, value);
  }
  extend(ValueModel, Model);

  /**
   * set the value
   *
   * @param value
   *          the new value
   */
  ValueModel.prototype.set = function(value) {
    if (this.value !== value) {
      this.value = value;
      this.emit('update', value);
    }
  };

  /**
   * retrieve the value
   *
   * @return the stored value
   */
  ValueModel.prototype.get = function() {
    return this.value;
  };

  /**
   * bind this value to another value without re-registering the listeners. The
   * connection is one-way only, but two symmetric bind calls are supported.
   *
   * Does not work if onupdate() is overwritten to avoid undefined behaviour.
   * This function is intended to be used to catch state changes in static
   * structures, such as the image parameter in the tabs, which could be mapped
   * to the team size.
   *
   * @param valueModel
   *          the other value model
   */
  ValueModel.prototype.bind = function(valueModel) {
    valueModel.registerListener(this);
    this.onupdate(valueModel);
  };

  /**
   * Callback function
   *
   * TODO use 'value' event or something, not 'update', which is ambiguous
   *
   * @param emitter
   */
  ValueModel.prototype.onupdate = function(emitter) {
    if (this.set) {
      this.set(emitter.get());
    }
  };

  /*
   * ValueModel does not implement save()/restore(), because it is an abstract
   * class which can store generic data types that is used primarily for
   * communicating value changes, not storing them efficiently.
   *
   * Please use a SuperModel instead, e.g. StateModel or PropertyModel.
   */

  return ValueModel;
});

/**
 * SelectionValueModel:
 *
 * @return SelectionValueModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/selectionvaluemodel',['lib/extend', './valuemodel'], function(extend, ValueModel) {
  /**
   * Constructor
   *
   * @param defaultValue
   *          the default value, which also serves as the initial value
   * @param allowedValues
   *          a ListModel instance of allowed values
   */
  function SelectionValueModel(defaultValue, allowedValues) {
    SelectionValueModel.superconstructor.call(this, defaultValue);

    this.allowedValues = allowedValues;
    this.setDefault(defaultValue);

    this.allowedValues.registerListener(this);
  }
  extend(SelectionValueModel, ValueModel);

  /**
   * /** *
   *
   * @param value
   * @return true if the value would be valid, false otherwise
   */
  SelectionValueModel.prototype.isValid = function(value) {
    return this.allowedValues.indexOf(value) !== -1;
  };

  /**
   * set the value if it's valid, i.e. if it has been registered as a valid
   * option *
   *
   * @param value
   *          the value
   * @return true on success, false otherwise
   */
  SelectionValueModel.prototype.set = function(value) {
    if (this.isValid(value)) {
      SelectionValueModel.superclass.set.call(this, value);
      return true;
    }
    return false;
  };

  /**
   * set the default value, which supersedes the allowed values *
   *
   * @param defaultValue
   *          the default value
   */
  SelectionValueModel.prototype.setDefault = function(defaultValue) {
    this.defaultValue = defaultValue;
    this.validate();
  };

  /**
   * check whether the current value is still valid and set the default value
   * otherwise. Ignores the allowed values for the default value.
   */
  SelectionValueModel.prototype.validate = function() {
    if (!this.isValid(this.get())) {
      SelectionValueModel.superclass.set.call(this, this.defaultValue);
    }
  };

  /**
   * Event callback for removing a value from the underlying list
   */
  SelectionValueModel.prototype.onremove = function() {
    this.validate();
  };

  return SelectionValueModel;
});

/**
 * StateValueModel, which defines states and state transitions.
 *
 * @return StateValueModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/statevaluemodel',['lib/extend', './selectionvaluemodel', './uniquelistmodel'], function(
    extend, SelectionValueModel, UniqueListModel) {

  /**
   * Constructor
   *
   * Transition object: { 'current': ['possible1', 'possible2']}
   *
   * @param initial
   *          initial value
   * @param transitions
   *          an object with transition arrays, as described above
   */
  function StateValueModel(initial, transitions) {
    StateValueModel.superconstructor.call(this, initial,//
    new UniqueListModel());

    // push it for safety
    this.allowedValues.push(initial);

    /*
     * Design decision: Not cloning the transitions object, so the state
     * transitions can later be modified, although they're not immediate, but
     * require an update across one of the old transition paths.
     */
    this.transitions = transitions;
    this.updateStates();

    this.registerListener(this);
  }
  extend(StateValueModel, SelectionValueModel);

  /**
   * Write all possible next states, as specified by this.transitions, to the
   * list of allowed values.
   */
  StateValueModel.prototype.updateStates = function() {
    /*
     * Read all possible states, remove all currently inaccessible states from
     * allowedValues and add those that are accessible. This is not the fastest
     * way, but it avoids any assumptions about possible subclasses
     */
    Object.keys(this.transitions).forEach(function(state) {
      var transition;
      transition = this.transitions[this.get()];

      if (this.get() === state) {
        // retain the current state to avoid the default value
        this.allowedValues.push(state);
      } else if (transition.indexOf(state) !== -1) {
        // transition is possible. Allowed state
        this.allowedValues.push(state);
      } else {
        // transition is impossible. Invalid state
        this.allowedValues.erase(state);
      }
    }, this);
  };

  /**
   * like this.set(), but it enforces a state change
   *
   * @param newState
   * @return true on success, false otherwise
   */
  StateValueModel.prototype.forceState = function(newState) {
    if (this.transitions[newState]) {
      this.allowedValues.push(newState);
      this.set(newState);
      return true;
    }
    return false;
  };

  /**
   * Callback function to update the list of allowed states after a state change
   */
  StateValueModel.prototype.onupdate = function() {
    this.updateStates();
  };

  return StateValueModel;
});

/**
 * ListCollectorModel: register to every list element and unregister when it's
 * removed. passes the emitted events to its own emitter, and adds the original
 * emitter to the data object as data.source
 *
 * @return ListCollectorModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/listcollectormodel',['lib/extend', 'core/model', 'core/listener'], function(extend, Model,
    Listener) {
  /**
   * Constructor
   *
   * @param list
   *          a list of elements to listen to
   * @param ContentModel
   *          the constructor of all contained elements
   */
  function ListCollectorModel(list, ContentModel) {
    ListCollectorModel.superconstructor.call(this);

    this.list = list;

    this.createListListener();
    this.createEventCallbacks(ContentModel);
    this.registerExistingElements();
  }
  extend(ListCollectorModel, Model);

  /**
   * create a listener object and bind it to this.
   *
   * whenever list elements are added or removed, the collector is registered or
   * unregistered from their emitters
   */
  ListCollectorModel.prototype.createListListener = function() {
    this.listener = new Listener(this.list);
    this.listener.collector = this;
    this.listener.list = this.list;

    /**
     * register to inserted emitters
     */
    this.listener.oninsert = function(emitter, event, data) {
      data.object.registerListener(this.collector);
    };

    /**
     * unregister from removed emitters
     */
    this.listener.onremove = function(emitter, event, data) {
      // avoid the unregistration of multiply inserted emitters
      if (this.list.indexOf(data.object) === -1) {
        data.object.unregisterListener(this.collector);
      }
    };
  };

  /**
   * for every possible event of the ContentModel, add a proxy callback.
   *
   * See ListCollectorModel.PROXYCALLBACK for a note on how events are passed
   * through
   *
   * @param ContentModel
   *          the class of which the list elements are instances
   */
  ListCollectorModel.prototype.createEventCallbacks = function(ContentModel) {
    var event;

    this.EVENTS = {};

    for (event in ContentModel.prototype.EVENTS) {
      if (ContentModel.prototype.EVENTS[event]) {
        this.EVENTS[event] = true;
        this['on' + event] = ListCollectorModel.PROXYCALLBACK;
      }
    }
  };

  /**
   * For every element, register a listener. Should only be used during the
   * constructor call
   */
  ListCollectorModel.prototype.registerExistingElements = function() {
    this.list.map(function(emitter) {
      emitter.registerListener(this);
    }, this);
  };

  /**
   * pass a recieved event through to the own emitter.
   *
   * The original emitter is written to data.source, unless data.source already
   * exists, in which case it is assumed that there's a chain of collectors.
   * Hence, the direct of this event emitter will be discarded in favor of the
   * original emitter.
   *
   * @param emitter
   *          the original emitter, i.e. the ListModel instance
   * @param event
   *          the event type, e.g. "update" or "reset"
   * @param data
   *          an optional data object
   */
  ListCollectorModel.PROXYCALLBACK = function(emitter, event, data) {
    if (!data) {
      data = {};
    }
    // TODO get rid of "source" field
    if (!data.source) {
      data.source = emitter;
    }
    this.emit(event, data);
  };

  return ListCollectorModel;
});

/**
 * RankingComponent: The base class for every ranking component. Chaining them
 * (singly-linked list using this.nextcomponent) allows for any ranking
 * priorities, including nonsensical ones.
 *
 * Every RankingComponent has access to the ranking object, and references the
 * next component in the chain. The
 *
 * @return RankingComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingcomponent',[],function() {
  /**
   * Constructor
   *
   * @param ranking
   *          a Ranking instance for value referencing
   * @param nextcomponent
   *          the next RankingComponent in the chain
   */
  function RankingComponent(ranking, nextcomponent) {
    this.ranking = ranking;

    if (nextcomponent) {
      this.nextcomponent = nextcomponent;
      this.dependencies = this.nextcomponent.dependencies;
    } else {
      this.nextcomponent = RankingComponent.DUMMYCOMPONENT;
      this.dependencies = [];
    }

    // add dependencies to the dependencies list
    if (this.constructor.DEPENDENCIES === undefined) {
      this.dependencies.push(this.constructor.NAME);
    } else {
      this.constructor.DEPENDENCIES.forEach(function(DEP) {
        this.dependencies.push(DEP);
      }, this);
    }
  }

  /**
   * the unique name for a ranking component, e.g. 'wins', 'saldo', 'coin'. To
   * be declared by every child class.
   *
   * This also is an implicit dependency, unless DEPENDENCIES is defined. If
   * there are no dependencies, set DEPENDENCIES to an empty array.
   */
  RankingComponent.NAME = 'undefined';

  /**
   * a list of dependencies, i.e. names, as in ranking.name.
   *
   * If this is undefined, the NAME is an implicit dependency.
   */
  RankingComponent.DEPENDENCIES = [];

  /**
   * DUMMYCOMPONENT is the default "nextcomponent", so the sort function does
   * not fail. It makes sure that teams with equal points are assigned the
   * same place
   */
  RankingComponent.DUMMYCOMPONENT = {
    /**
     * @param i
     *          a team index
     * @param k
     *          another team index
     * @return 0. After this step, every team is equal, so multiple first
     *         places can happen.
     */
    compare: function(i, k) {
      return 0;
    },
    /**
     * do nothing, just return the output array
     */
    getValues: function(outArray) {
      return outArray;
    }
  };

  /**
   * Recursively output all values to a two-dimensional array. Ignore fully
   * undefined components (e.g. comparison-based components)
   *
   * @param outArray
   *          Optional. the output array. Will be created if undefined
   * @return outArray, an array of value arrays for every chain level. If a
   *          level does not have any values, its entry will be set to undefined
   */
  RankingComponent.prototype.getValues = function(outArray) {
    var values, index;

    if (outArray === undefined) {
      outArray = [];
    }

    values = [];

    for (index = 0; index < this.ranking.length; index += 1) {
      values[index] = this.value(index);
    }

    if (values.every(function(value) {
      return value === undefined;
    })) {
      values = undefined;
    }

    outArray.push(values);

    return this.nextcomponent.getValues(outArray);
  };

  /**
   * if the values for comparison are independent (points, as opposed to direct
   * comparison or coin tosses), retrieve and return the value. This can be the
   * number of wins, small points, saldo points, or whatever. It just has to be
   * bound to a single player/team
   *
   * If possible, please overload this function instead of overloading compare.
   *
   * @param i
   *          a team index
   * @return a point value (or whatever) for this team
   */
  RankingComponent.prototype.value = function(i) {
    return undefined;
  };

  /**
   * compare function for sort(). Is chained to the next component. Think before
   * overloading.
   *
   * The idea is to have an implicit sort order by chaining the sort functions.
   * Wins > Buchholz > Saldo > Whatever. That's reflected by a component chain.
   *
   * @param i
   *          index of a team
   * @param k
   *          index of another team
   * @return {Number} see Array.prototype.sort() for an explanation of compare
   *         functions
   */
  RankingComponent.prototype.compare = function(i, k) {
    return this.value(k) - this.value(i) || this.nextcomponent.compare(i, k);
  };

  return RankingComponent;
});

/**
 * RankingIDComponent: rank by player id
 *
 * @return RankingIDComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingidcomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingIDComponent(ranking) {
    RankingIDComponent.superconstructor.call(this, ranking, undefined);
  }
  extend(RankingIDComponent, RankingComponent);

  RankingIDComponent.NAME = 'id';
  RankingIDComponent.DEPENDENCIES = [];

  /**
   * simply return the id. This always leads to a non-equal comparison.
   *
   * @param i
   *          a player index
   * @return the player index, for sorting
   */
  RankingIDComponent.prototype.value = function(i) {
    return i;
  };

  RankingIDComponent.prototype.compare = function(i, k) {
    return -RankingIDComponent.superclass.compare.call(this, i, k);
  };

  return RankingIDComponent;
});

/**
 * RankingPointsComponent
 *
 * @return RankingPointsComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingpointscomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingPointsComponent(ranking, nextcomponent) {
    RankingPointsComponent.superconstructor.call(this, ranking, //
    nextcomponent);
  }
  extend(RankingPointsComponent, RankingComponent);

  RankingPointsComponent.NAME = 'points';

  /**
   * @param i
   *          a team index
   * @return the small points: won points, without subtracting lost points
   */
  RankingPointsComponent.prototype.value = function(i) {
    return this.ranking.points.get(i);
  };

  return RankingPointsComponent;
});

/**
 * RankingLostPointsComponent
 *
 * @return RankingLostPointsComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankinglostpointscomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingLostPointsComponent(ranking, nextcomponent) {
    RankingLostPointsComponent.superconstructor.call(this, ranking,
        nextcomponent);
  }
  extend(RankingLostPointsComponent, RankingComponent);

  RankingLostPointsComponent.NAME = 'lostpoints';

  /**
   * @param i
   *          a team index
   * @return the small points: won points, without subtracting lost points
   */
  RankingLostPointsComponent.prototype.value = function(i) {
    return this.ranking.lostpoints.get(i);
  };

  return RankingLostPointsComponent;
});

/**
 * RankingSaldoComponent
 *
 * @return RankingSaldoComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingsaldocomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingSaldoComponent(ranking, nextcomponent) {
    RankingSaldoComponent.superconstructor.call(this, ranking, nextcomponent);
  }
  extend(RankingSaldoComponent, RankingComponent);

  RankingSaldoComponent.NAME = 'saldo';

  /**
   * @param i
   *          a team index
   * @return the point difference, aka. saldo points
   */
  RankingSaldoComponent.prototype.value = function(i) {
    return this.ranking.saldo.get(i);
  };

  return RankingSaldoComponent;
});

/**
 * RankingBuchholzComponent
 *
 * @return RankingBuchholzComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingbuchholzcomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingBuchholzComponent(ranking, nextcomponent) {
    RankingBuchholzComponent.superconstructor
        .call(this, ranking, nextcomponent);
  }
  extend(RankingBuchholzComponent, RankingComponent);

  RankingBuchholzComponent.NAME = 'buchholz';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingBuchholzComponent.prototype.value = function(i) {
    return this.ranking.buchholz.get(i);
  };

  return RankingBuchholzComponent;
});

/**
 * RankingFinebuchholzComponent
 *
 * @return RankingFinebuchholzComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingfinebuchholzcomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingFinebuchholzComponent(ranking, nextcomponent) {
    RankingFinebuchholzComponent.superconstructor.call(this, ranking,
        nextcomponent);
  }
  extend(RankingFinebuchholzComponent, RankingComponent);

  RankingFinebuchholzComponent.NAME = 'finebuchholz';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingFinebuchholzComponent.prototype.value = function(i) {
    return this.ranking.finebuchholz.get(i);
  };

  return RankingFinebuchholzComponent;
});

/**
 * RankingSonnebornComponent
 *
 * @return RankingSonnebornComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingsonneborncomponent',['lib/extend', './rankingcomponent'],//
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingSonnebornComponent(ranking, nextcomponent) {
    RankingSonnebornComponent.superconstructor.call(this, ranking,
        nextcomponent);
  }
  extend(RankingSonnebornComponent, RankingComponent);

  RankingSonnebornComponent.NAME = 'sonneborn';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingSonnebornComponent.prototype.value = function(i) {
    return this.ranking.sonneborn.get(i);
  };

  return RankingSonnebornComponent;
});

/**
 * RankingWinsComponent: rank by team id
 *
 * @return RankingWinsComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingwinscomponent',['lib/extend', './rankingcomponent'], function(extend, //
RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingWinsComponent(ranking, nextcomponent) {
    RankingWinsComponent.superconstructor.call(this, ranking, nextcomponent);
  }
  extend(RankingWinsComponent, RankingComponent);

  RankingWinsComponent.NAME = 'wins';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingWinsComponent.prototype.value = function(i) {
    return this.ranking.wins.get(i);
  };

  return RankingWinsComponent;
});

/**
 * RankingHeadToHeadComponent
 *
 * @return RankingHeadToHeadComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingheadtoheadcomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the component chain
   */
  function RankingHeadToHeadComponent(ranking, nextcomponent) {
    RankingHeadToHeadComponent.superconstructor.call(this, ranking,
        nextcomponent);
  }
  extend(RankingHeadToHeadComponent, RankingComponent);

  RankingHeadToHeadComponent.NAME = 'headtohead';

  /**
   * @param i
   *          a team index
   * @return the headtohead value, i.e. how often the team has won against
   *         another with the same number of wins
   */
  RankingHeadToHeadComponent.prototype.value = function(i) {
    return this.ranking.headtohead.get(i) || '';
  };

  return RankingHeadToHeadComponent;
});

/**
 * RankingTacComponent: TAC-specific calculations
 *
 * @return RankingTacComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingtaccomponent',['lib/extend', './rankingcomponent'],//
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingTacComponent(ranking, nextcomponent) {
    RankingTacComponent.superconstructor.call(this, ranking, nextcomponent);
  }
  extend(RankingTacComponent, RankingComponent);

  RankingTacComponent.NAME = 'tac';

  /**
   * @param i
   *          a team index
   * @return the point difference, aka. tac points
   */
  RankingTacComponent.prototype.value = function(i) {
    return this.ranking.tac.get(i);
  };

  return RankingTacComponent;
});

/**
 * RankingVotesComponent
 *
 * @return RankingVotesComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingvotescomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingVotesComponent(ranking, nextcomponent) {
    RankingVotesComponent.superconstructor.call(this, ranking, nextcomponent);
  }
  extend(RankingVotesComponent, RankingComponent);

  RankingVotesComponent.NAME = 'votes';

  /**
   * @param i
   *          a team index
   * @return a string representation of the votes
   */
  RankingVotesComponent.prototype.value = function(i) {
    return this.ranking.votes.get(i);
  };

  /**
   * skip this component for ranking. It's not a valid component, just a
   * visualization
   *
   * @return the result of the next component's ranking
   */
  RankingVotesComponent.prototype.compare = function(i, k) {
    return this.nextcomponent.compare(i, k);
  };

  return RankingVotesComponent;
});

/**
 * RankingNumGamesComponent
 *
 * @return RankingNumGamesComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingnumgamescomponent',['lib/extend', './rankingcomponent'], //
function(extend, RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingNumGamesComponent(ranking, nextcomponent) {
    RankingNumGamesComponent.superconstructor
        .call(this, ranking, nextcomponent);
  }
  extend(RankingNumGamesComponent, RankingComponent);

  RankingNumGamesComponent.NAME = 'numgames';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingNumGamesComponent.prototype.value = function(i) {
    return this.ranking.numgames.get(i);
  };

  return RankingNumGamesComponent;
});

/**
 * RankingKOComponent: rank by team id
 *
 * @return RankingKOComponent
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingkocomponent',['lib/extend', './rankingcomponent'], function(extend, //
RankingComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param nextcomponent
   *          the next component in the chain
   */
  function RankingKOComponent(ranking, nextcomponent) {
    RankingKOComponent.superconstructor.call(this, ranking, nextcomponent);
  }
  extend(RankingKOComponent, RankingComponent);

  RankingKOComponent.NAME = 'ko';

  /**
   * @param i
   *          a team index
   * @return the number of won games
   */
  RankingKOComponent.prototype.value = function(i) {
    return this.ranking.ko.get(i);
  };

  return RankingKOComponent;
});

/**
 * RankingComponentIndex: An object, which indexes the constructors of all
 * ranking components.
 *
 * @return RankingComponentIndex
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingcomponentindex',['./rankingidcomponent', './rankingpointscomponent',
    './rankinglostpointscomponent', './rankingsaldocomponent',
    './rankingbuchholzcomponent', './rankingfinebuchholzcomponent',
    './rankingsonneborncomponent', './rankingwinscomponent',
    './rankingheadtoheadcomponent', './rankingtaccomponent',
    './rankingvotescomponent', './rankingnumgamescomponent',
    './rankingkocomponent'], function() {
  var RankingComponentIndex, index, Component, allComponents;

  // build the index from the XXXRankingComponent.NAME fields
  RankingComponentIndex = {};
  allComponents = {};
  for (index = 0; index < arguments.length; index += 1) {
    Component = arguments[index];
    allComponents[Component.NAME.toLowerCase()] = Component;
  }

  /**
   * from a list of components, create a chain of RankingComponent instances to
   * be used for sorting and comparison
   *
   * @param ranking
   *          a RankingModel instance
   * @param components
   *          an array of strings
   * @return the topmost element of the component chain, which corresponds to
   *         the first element in the components array
   */
  RankingComponentIndex.createComponentChain = function(ranking, components) {
    var chainfront, retval;

    chainfront = undefined;

    // copy the array and revert it: we'll construct the chain from its end
    components = components.slice(0);
    components.reverse();

    // iterate over the components and chain them in order.
    // Abort if a component is not defined.
    if (!components.every(function(component) {
      component = component.toLowerCase();
      var constructor = allComponents[component];
      if (constructor === undefined) {
        console.error('RankingComponentIndex.createComponentChain error: '
            + 'undefined component name: ' + component);
        return false;
      }

      chainfront = new constructor(ranking, chainfront);

      return true;
    })) {
      // some component could not be created. Abort.
      return undefined;
    }

    return chainfront;
  };

  RankingComponentIndex.components = Object.keys(allComponents).sort();

  return RankingComponentIndex;
});

/**
 * RankingDataListener: Strange name, but it is registered through the
 * dependency system to a RankingModel, from where it catches recalc events,
 * which it uses to update a single field of data, e.g. wins, points, saldo, ...
 *
 * @return RankingDataListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingdatalistener',['lib/extend', './listener'], function(extend, Listener) {
  /**
   * Constructor.
   *
   * Subclasses are required to create "ranking.{NAME}" in the constructor
   *
   * @param ranking
   *          a RankingModel instance
   * @param fieldobject
   *          the object for the field this class is calculating
   */
  function RankingDataListener(ranking, fieldobject) {
    var Const;
    RankingDataListener.superconstructor.call(this);

    /**
     * This.constructor, on inherited classes, is NOT RankingDataListener, but
     * the constructor that was invoked by 'new'
     */
    Const = this.constructor;

    this.ranking = ranking;

    // resize and map the ranking field
    if (fieldobject.length !== ranking.length) {
      fieldobject.resize(ranking.length);
    }
    if (ranking[Const.NAME] !== undefined) {
      throw new Error('ranking field already exists: ' + Const.NAME);
    }
    ranking[Const.NAME] = fieldobject;
    this[Const.NAME] = fieldobject;

    // create dependency links
    if (Const.DEPENDENCIES) {
      Const.DEPENDENCIES.forEach(function(DEPNAME) {
        this[DEPNAME] = ranking[DEPNAME];
        if (this[DEPNAME] === undefined) {
          console.warn('ranking dependency not found: ' + DEPNAME);
        }
      }, this);
    }

    ranking.registerListener(this);
  }
  extend(RankingDataListener, Listener);

  /**
   * detect whether this specific instance is a primary data listener, or is
   * only processing recalc events, i.e. processing data of other data listeners
   *
   * @return true if this listener contains primary data, false otherwise
   */
  RankingDataListener.prototype.isPrimary = function() {
    return this.onbye !== RankingDataListener.prototype.onbye
        || this.onresult !== RankingDataListener.prototype.onresult;
  };

  /**
   * the name of the field, which is handled by this class, e.g. 'wins'
   */
  RankingDataListener.NAME = 'undefined';

  /**
   * an array of dependencies, e.g. [ 'buchholz', 'games'] for finebuchholz
   */
  RankingDataListener.DEPENDENCIES = [];

  RankingDataListener.prototype.destroy = function() {
    RankingDataListener.superclass.destroy.call(this);

    delete this.ranking[this.constructor.NAME];
  };

  /**
   * insert the results of a game into the ranking.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param game
   *          a game result
   */
  RankingDataListener.prototype.onresult = function(r, e, game) {
    // do something to this.NAME, where NAME is the value of constructor.NAME
  };

  /**
   * inserts a bye into the ranking
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param teams
   *          array of teams which receive a bye
   */
  RankingDataListener.prototype.onbye = function(r, e, teams) {
    // do something to this.NAME, where NAME is the value of constructor.NAME
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param correction
   *          a game correction (CorrectionModel instance)
   */
  RankingDataListener.prototype.oncorrect = function(r, e, correction) {
    // do something to this.NAME, where NAME is the value of constructor.NAME
  };

  /**
   * calculate the field
   */
  RankingDataListener.prototype.onrecalc = function() {
    // do something to this.NAME, where NAME is the value of constructor.NAME
  };

  /**
   * reset the field
   */
  RankingDataListener.prototype.onreset = function() {
    this[this.constructor.NAME].fill(0);
  };

  /**
   * resize the contents
   *
   * @param ranking
   */
  RankingDataListener.prototype.onresize = function(ranking) {
    var dataobject = this[this.constructor.NAME];
    if (dataobject && dataobject.resize) {
      this[this.constructor.NAME].resize(ranking.length);
    }
  };

  return RankingDataListener;
});

/**
 * VectorModel, a vector class. Inherits from ListModel for convenience.
 *
 * @return VectorModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/vectormodel',['lib/extend', './listmodel', './type', './rle'], function(extend,
    ListModel, Type, RLE) {
  /**
   * Constructor
   *
   * @param size
   *          Optional. The initial size of the vector
   */
  function VectorModel(size) {
    VectorModel.superconstructor.call(this);

    this.resize(size);
  }
  extend(VectorModel, ListModel);

  /**
   * resize function: pop or push elements until the target size is reached
   *
   * @param size
   */
  VectorModel.prototype.resize = function(size) {
    if (size === undefined || size < 0) {
      size = 0;
    }

    while (this.length > size) {
      this.pop();
    }
    while (this.length < size) {
      this.push(0);
    }
  };

  /**
   * set the whole vector to one value
   *
   * @param value
   *          Optional. The value. Defaults to 0.
   */
  VectorModel.prototype.fill = function(value) {
    var index;

    value = value || 0;

    for (index = 0; index < this.length; index += 1) {
      this.set(index, value);
    }
  };

  /**
   * calculate and return the vector sum
   *
   * @return the vector sum
   */
  VectorModel.prototype.sum = function() {
    return this.list.reduce(function(a, b) {
      return a + b;
    });
  };

  /**
   * sets the vector contens with the element-wise product of two vectors
   *
   * @param vecA
   *          Vector A
   * @param vecB
   *          Optional. Vector B. defaults to this.
   * @return this
   */
  VectorModel.prototype.mult = function(vecA, vecB) {
    var index;

    if (Type.isNumber(vecB)) {
      throw new Error('VectorModel.prototype.mult: '
          + 'second argument must be undefined or a VectorModel instance: '
          + vecB);
    }

    vecB = vecB || this;

    if (Type.isNumber(vecA)) {
      // numerical multiplication
      this.resize(vecB.length);
      for (index = 0; index < this.length; index += 1) {
        this.set(index, vecB.get(index) * vecA);
      }
    } else {
      // element-wise multiplication
      if (vecA.length !== vecB.length) {
        console.error('VectorModel.setProduct: different input lengths: '
            + vecA.length + '<>' + vecB.length);
        return undefined;
      }

      this.resize(vecB.length);

      for (index = 0; index < this.length; index += 1) {
        this.set(index, vecA.get(index) * vecB.get(index));
      }
    }

    return this;
  };

  /**
   * calculate and return the dot product of this and another vector
   *
   * @param vec
   *          the other vector
   * @return the dot product, (this . vec)
   */
  VectorModel.prototype.dot = function(vec) {
    var index, sum;

    if (this.length != vec.length) {
      console.error('VectorModel.dot: different input lengths: ' + this.length
          + '<>' + vec.length);
      return undefined;
    }

    sum = 0;
    for (index = 0; index < this.length; index += 1) {
      sum += this.get(index) * vec.get(index);
    }

    return sum;
  };

  /**
   * Adds two vectors and stores the results in this. If the second vector is
   * undefined, vector 1 is added to this.
   *
   * @param vec1
   *          vector 1
   * @param vec2
   *          Optional. vector 2. Defaults to this.
   * @return this on success, undefined otherwise
   */
  VectorModel.prototype.add = function(vec1, vec2) {
    var index;

    vec2 = vec2 || this;

    if (vec1.length !== vec2.length) {
      console.error('VectorModel.prototype.add: different input lengths: '
          + +vec1.length + '<>' + vec2.length);
      return undefined;
    }

    this.resize(vec1.length);

    for (index = 0; index < this.length; index += 1) {
      this.set(index, vec1.get(index) + vec2.get(index));
    }

    return this;
  };

  /**
   * prepare a compact serializable representation of the vector
   *
   * @return a data object
   */
  VectorModel.prototype.save = function() {
    var data = VectorModel.superclass.save.call(this);

    data = RLE.encode(data);

    return data;
  };

  /**
   * restore the vector from a previously saved data object
   *
   * @param data
   *          the data object
   * @return true on success, false otherwise
   */
  VectorModel.prototype.restore = function(data) {
    var index;

    try {
      data = RLE.decode(data);
    } catch (e) {
      console.error(e);
      return false;
    }

    if (!VectorModel.superclass.restore.call(this, data)) {
      return false;
    }

    while ((index = this.indexOf(undefined)) !== -1) {
      this.set(index, 0);
    }
    return true;
  };

  VectorModel.prototype.SAVEFORMAT = Object
      .create(VectorModel.superclass.SAVEFORMAT);
  VectorModel.prototype.SAVEFORMAT.v = [Number];

  return VectorModel;
});

/**
 * central options object. Please require 'options' instead of 'ui/optionsclass'
 * to ensure the target-specific Default options.
 *
 * TODO MVC-rewrite with multiple levels of default values
 *
 * TODO don't store the whole options object in localStorage
 *
 * @return Opts
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/optionstemplate',[], function() { // NOTE TO SELF: Don't remove the '[],' from this line
// Removing it WILL break EVERYTHING after r.js compilation !!!
  var OptionsTemplate, Default, State;

  State = undefined;
  Default = {};
  OptionsTemplate = {};

  function getState() {
    return State || (State = require('ui/state'));
  }

  OptionsTemplate.toBlob = function() {
    return JSON.stringify(OptionsTemplate);
  };

  OptionsTemplate.fromBlob = function(blob) {
    var opts, key;
    opts = JSON.parse(blob);

    // delete everything
    for (key in OptionsTemplate) {
      if (typeof (OptionsTemplate[key]) !== 'function') {
        delete OptionsTemplate[key];
      }
    }

    // apply default options
    for (key in Default) {
      OptionsTemplate[key] = Default[key];
    }

    // reset everything
    for (key in opts) {
      OptionsTemplate[key] = opts[key];
    }
  };

  OptionsTemplate.setDefault = function(newDefault) {
    Default = newDefault;
  };

  OptionsTemplate.reset = function() {
    // just use available functions instead of cloning
    OptionsTemplate.fromBlob(JSON.stringify(Default));
  };

  OptionsTemplate.reset();

  return OptionsTemplate;
});

/**
 * Options object, which contains options such as database keys, points, etc.
 *
 * @deprecated will be replaced with a new OptionsModel class or something
 *
 * @return OptionsTemplate
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('options',['ui/optionstemplate'], function(OptionsTemplate) {
  var Default;

  Default = {
    // must stay the same across this save, hence OptionsTemplate, not Presets
    minpoints: 0,
    maxpoints: 15,
    byepointswon: 13,
    byepointslost: 7,
    defaultscore: 0,
    tiesforbidden: false,
    maxpointtiesforbidden: true
  };

  OptionsTemplate.setDefault(Default);
  OptionsTemplate.reset();

  return OptionsTemplate;
});

/**
 * RankingLostPointsListener
 *
 * @return RankingLostPointsListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankinglostpointslistener',['lib/extend', './rankingdatalistener', './vectormodel', //
'options'], function(extend, RankingDataListener, VectorModel, Options) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingLostPointsListener(ranking) {
    RankingLostPointsListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingLostPointsListener, RankingDataListener);

  RankingLostPointsListener.NAME = 'lostpoints';
  RankingLostPointsListener.DEPENDENCIES = undefined;

  /**
   * insert the results of a game into the ranking.
   *
   * We cannot make the assumption that there's only one opponent. That's why we
   * iterate over every team as a possible opponent and apply his points to
   * every other team's lostpoints vector.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingLostPointsListener.prototype.onresult = function(r, e, result) {
    result.teams.forEach(function(opponent, index) {
      result.teams.forEach(function(team) {
        if (team !== opponent) {
          this.lostpoints.set(team, this.lostpoints.get(team)
              - result.score[index]);
        }
      }, this);
    }, this);
  };

  /**
   * account for bye points
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "bye"
   * @param teams
   *          an array of team ids
   */
  RankingLostPointsListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(teamid) {
      this.lostpoints.set(teamid, this.lostpoints.get(teamid)
          - Options.byepointslost);
    }, this);
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "bye"
   * @param correction
   *          a game correction
   */
  RankingLostPointsListener.prototype.oncorrect = function(r, e, correction) {
    correction.before.teams.forEach(function(opponent, index) {
      correction.before.teams.forEach(function(team) {
        if (team !== opponent) {
          this.lostpoints.set(team, this.lostpoints.get(team)
              + correction.before.score[index]);
        }
      }, this);

    }, this);

    this.onresult(r, e, correction.after);
  };

  return RankingLostPointsListener;
});

/**
 * RankingPointsListener
 *
 * @return RankingPointsListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingpointslistener',['lib/extend', './rankingdatalistener', './vectormodel', //
'options'], function(extend, RankingDataListener, VectorModel, Options) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingPointsListener(ranking) {
    RankingPointsListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingPointsListener, RankingDataListener);

  RankingPointsListener.NAME = 'points';
  RankingPointsListener.DEPENDENCIES = undefined;

  /**
   * insert the results of a game into the ranking.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingPointsListener.prototype.onresult = function(r, e, result) {
    result.teams.forEach(function(teamid, index) {
      this.points.set(teamid, this.points.get(teamid) + result.score[index]);
    }, this);
  };

  /**
   * add bye points
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "bye"
   * @param teams
   *          an array of team ids
   */
  RankingPointsListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(teamid) {
      this.points.set(teamid, this.points.get(teamid) + Options.byepointswon);
    }, this);
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "correct"
   * @param correction
   *          a game correction
   */
  RankingPointsListener.prototype.oncorrect = function(r, e, correction) {
    correction.before.teams.forEach(function(teamid, index) {
      this.points.set(teamid, this.points.get(teamid)
          - correction.before.score[index]);
    }, this);

    this.onresult(r, e, correction.after);
  };

  return RankingPointsListener;
});

/**
 * RankingSaldoListener
 *
 * @return RankingSaldoListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingsaldolistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingSaldoListener(ranking) {
    RankingSaldoListener.superconstructor
        .call(this, ranking, new VectorModel());
  }
  extend(RankingSaldoListener, RankingDataListener);

  RankingSaldoListener.NAME = 'saldo';
  RankingSaldoListener.DEPENDENCIES = ['points', 'lostpoints'];

  RankingSaldoListener.prototype.onrecalc = function() {
    this.saldo.add(this.points, this.lostpoints);
  };

  return RankingSaldoListener;
});

/**
 * RankingUpvotesListener
 *
 * @return RankingUpvotesListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingupvoteslistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingUpvotesListener(ranking) {
    RankingUpvotesListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingUpvotesListener, RankingDataListener);

  /**
   * override the 'isPrimary()' function: Don't check for specialties, just make
   * it save stuff.
   *
   * @return true
   */
  RankingUpvotesListener.prototype.isPrimary = function() {
    return true;
  };

  RankingUpvotesListener.NAME = 'upvotes';
  RankingUpvotesListener.DEPENDENCIES = undefined;

  return RankingUpvotesListener;
});

/**
 * RankingDownvotesListener
 *
 * @return RankingDownvotesListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingdownvoteslistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingDownvotesListener(ranking) {
    RankingDownvotesListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingDownvotesListener, RankingDataListener);

  /**
   * override the 'isPrimary()' function: Don't check for specialties, just make
   * it save stuff.
   *
   * @return true
   */
  RankingDownvotesListener.prototype.isPrimary = function() {
    return true;
  };

  RankingDownvotesListener.NAME = 'downvotes';
  RankingDownvotesListener.DEPENDENCIES = undefined;

  return RankingDownvotesListener;
});

/**
 * RankingVotesListener
 *
 * @return RankingVotesListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingvoteslistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingVotesListener(ranking) {
    RankingVotesListener.superconstructor
        .call(this, ranking, new VectorModel());
  }
  extend(RankingVotesListener, RankingDataListener);

  RankingVotesListener.NAME = 'votes';
  RankingVotesListener.DEPENDENCIES = ['upvotes', 'downvotes', 'byes'];

  RankingVotesListener.prototype.onrecalc = function() {
    this.votes.map(function(oldVote, teamID) {
      var i, string;

      string = '';

      // byes
      for (i = 0; i < this.byes.get(teamID); i += 1) {
        string += '∅';
      }

      // upvotes
      for (i = 0; i < this.upvotes.get(teamID); i += 1) {
        string += '▲';
      }

      // downvotes
      for (i = 0; i < this.downvotes.get(teamID); i += 1) {
        string += '▼';
      }

      this.votes.set(teamID, string);
    }, this);
  };

  return RankingVotesListener;
});

/**
 * RankingByeListener
 *
 * TODO: test properly
 *
 * @return RankingByeListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingbyelistener',['lib/extend', './rankingdatalistener', //
'./vectormodel'], function(extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingByeListener(ranking) {
    RankingByeListener.superconstructor.call(this, ranking, // autoformat
    new VectorModel());
  }
  extend(RankingByeListener, RankingDataListener);

  RankingByeListener.NAME = 'byes';
  RankingByeListener.DEPENDENCIES = undefined;

  /**
   * accumulate byes
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "bye"
   * @param teams
   *          an array of team ids
   */
  RankingByeListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(teamid) {
      this.byes.set(teamid, this.byes.get(teamid) + 1);
    }, this);
  };

  return RankingByeListener;
});

/**
 * RankingWinsListener
 *
 * @return RankingWinsListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingwinslistener',['lib/extend', './rankingdatalistener', //
'./vectormodel'], function(extend, RankingDataListener, VectorModel) {

  /**
   * @param result
   *          a MatchResult instance
   * @return the index of the winner (for result.getTeamID(index)), or undefined
   *         if no unique winner exists
   */
  function getWinner(result) {
    var winner, maxpoints;

    winner = undefined;
    maxpoints = undefined;

    result.teams.forEach(function(teamid, index) {
      var points;
      points = result.score[index];
      if (maxpoints === undefined || points > maxpoints) {
        winner = teamid;
        maxpoints = points;
      } else if (points === maxpoints) {
        winner = undefined;
      }
    }, this);

    return winner;
  }

  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingWinsListener(ranking) {
    RankingWinsListener.superconstructor.call(this, ranking, // autoformat
    new VectorModel());
  }
  extend(RankingWinsListener, RankingDataListener);

  RankingWinsListener.NAME = 'wins';
  RankingWinsListener.DEPENDENCIES = undefined;

  /**
   * insert the results of a game into the ranking.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingWinsListener.prototype.onresult = function(r, e, result) {
    var winner = getWinner(result);

    if (winner !== undefined) {
      this.wins.set(winner, this.wins.get(winner) + 1);
    }
  };

  /**
   * add bye-related "wins"
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "bye"
   * @param teams
   *          an array of team ids
   */
  RankingWinsListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(teamid) {
      this.wins.set(teamid, this.wins.get(teamid) + 1);
    }, this);
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "correct"
   * @param correction
   *          a game correction
   */
  RankingWinsListener.prototype.oncorrect = function(r, e, correction) {
    var winner = getWinner(correction.before);

    if (winner !== undefined) {
      this.wins.set(winner, this.wins.get(winner) - 1);
    }

    this.onresult(r, e, correction.after);
  };

  return RankingWinsListener;
});

/**
 * TransposeSumMatrix: the sum of a matrix and its transpose.
 *
 * Example use in a tournament: If matrix is a matrix with the number of wins
 * (1) and draws (1/2) against every opponent, TransposeSumMatrix(matrix) is the
 * number of games against an opponent, so long as the main diagonal is zero.
 *
 * @return TransposeSumMatrix
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/transposesummatrix',['lib/extend', './delegatematrix'], function(extend, DelegateMatrix) {
  /**
   * Constructor
   *
   * @param matrix
   *          the matrix to bind itself to
   */
  function TransposeSumMatrix(matrix) {
    TransposeSumMatrix.superconstructor.call(this, matrix);
  }
  extend(TransposeSumMatrix, DelegateMatrix);

  /**
   * return only positive values
   *
   * @param row
   *          the row
   * @param col
   *          the column
   * @return get(row, col)+get(col, row), i.e. (A + A^T)
   */
  TransposeSumMatrix.prototype.get = function(row, col) {
    var v1, v2;
    v1 = this.superget(row, col);
    v2 = this.superget(col, row);
    if (v1 === undefined || v2 === undefined) {
      return undefined;
    }
    return v1 + v2;
  };

  return TransposeSumMatrix;
});

/**
 * RankingGameMatrixListener: calculates the (symmetric) gamematrix from the
 * (asymmetric) winsmatrix by adding it to its transpose using a
 * TransposeSumMatrix.
 *
 * @return RankingGameMatrixListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankinggamematrixlistener',['lib/extend', './rankingdatalistener', './transposesummatrix'], //
function(extend, RankingDataListener, TransposeSumMatrix) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingGameMatrixListener(ranking) {
    RankingGameMatrixListener.superconstructor.call(this, ranking,
        new TransposeSumMatrix(ranking.winsmatrix));
  }
  extend(RankingGameMatrixListener, RankingDataListener);

  RankingGameMatrixListener.NAME = 'gamematrix';
  RankingGameMatrixListener.DEPENDENCIES = ['winsmatrix'];

  return RankingGameMatrixListener;
});

/**
 * RankingBuchholzListener
 *
 * @return RankingBuchholzListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingbuchholzlistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingBuchholzListener(ranking) {
    RankingBuchholzListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingBuchholzListener, RankingDataListener);

  RankingBuchholzListener.NAME = 'buchholz';
  RankingBuchholzListener.DEPENDENCIES = ['gamematrix', 'wins'];

  RankingBuchholzListener.prototype.onrecalc = function() {
    this.gamematrix.multVector(this.buchholz, this.wins);
  };

  return RankingBuchholzListener;
});

/**
 * RankingBuchholzListener
 *
 * @return RankingBuchholzListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingfinebuchholzlistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingBuchholzListener(ranking) {
    RankingBuchholzListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingBuchholzListener, RankingDataListener);

  RankingBuchholzListener.NAME = 'finebuchholz';
  RankingBuchholzListener.DEPENDENCIES = ['gamematrix', 'buchholz'];

  RankingBuchholzListener.prototype.onrecalc = function() {
    this.gamematrix.multVector(this.finebuchholz, this.buchholz);
  };

  return RankingBuchholzListener;
});

/**
 * RankingWinsMatrixListener, a matrix that represents how often a team has won
 * against another team. Does not represent byes
 *
 * @return RankingWinsMatrixListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingwinsmatrixlistener',['lib/extend', './rankingdatalistener', './matrixmodel'], function(
    extend, RankingDataListener, MatrixModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingWinsMatrixListener(ranking) {
    RankingWinsMatrixListener.superconstructor.call(this, ranking,
        new MatrixModel());
  }
  extend(RankingWinsMatrixListener, RankingDataListener);

  RankingWinsMatrixListener.NAME = 'winsmatrix';

  /**
   * insert the game results into the ranking
   *
   * This one is tricky... To enable arbitrary numbers of players, there's no
   * direct comparison, but the highest points and whether they appear multiple
   * times (-> draw) are determined. Then, for every player with the highest
   * points, the score is increased by 1 if he's the only winner or 0.5 if he
   * shared the victory. That way, arbitrary numbers of players and winners are
   * possible
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingWinsMatrixListener.prototype.onresult = function(r, e, result) {
    var maxpoints, draw, score;

    // get the max points, remember if there's a draw
    maxpoints = undefined;
    draw = false;
    result.score.forEach(function(points) {
      if (points > maxpoints || maxpoints === undefined) {
        maxpoints = points;
        draw = false;
      } else if (points === maxpoints) {
        draw = true;
      }
    }, this);

    // only give half the score for a draw
    score = draw ? 0.5 : 1;

    // find every winner and apply the score over his opponents (i.e. everyone
    // else)
    result.score.forEach(function(points, index) {
      var teamid;
      if (points === maxpoints) {
        teamid = result.teams[index];
        result.teams.forEach(function(opponent) {
          var value;
          if (teamid !== opponent) {
            value = this.winsmatrix.get(teamid, opponent) + score;
            this.winsmatrix.set(teamid, opponent, value);
          }
        }, this);
      }
    }, this);
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the emitter, i.e. a RankingModel instance
   * @param e
   *          the event, i.e. "correct"
   * @param correction
   *          a game correction
   */
  RankingWinsMatrixListener.prototype.oncorrect = function(r, e, correction) {
    // TODO DRY - Don't Repeat Yourself!
    // TODO extract a method for use by onresult and oncorrect
    var maxpoints, draw, score;

    // get the max points, remember if there's a draw
    maxpoints = undefined;
    draw = false;
    correction.before.score.forEach(function(points) {
      if (points > maxpoints || maxpoints === undefined) {
        maxpoints = points;
        draw = false;
      } else if (points === maxpoints) {
        draw = true;
      }
    }, this);

    // only give half the score for a draw
    score = draw ? 0.5 : 1;

    // find every winner and apply the score over his opponents (i.e. everyone
    // else)
    correction.before.score.forEach(function(points, index) {
      var teamid;
      if (points === maxpoints) {
        teamid = correction.before.teams[index];
        correction.before.teams.forEach(function(opponent) {
          var value;
          if (teamid !== opponent) {
            value = this.winsmatrix.get(teamid, opponent) - score;
            this.winsmatrix.set(teamid, opponent, value);
          }
        }, this);
      }
    }, this);

    this.onresult(r, e, correction.after);
  };

  return RankingWinsMatrixListener;
});

/**
 * RankingTacListener
 *
 * @return RankingTacListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingtaclistener',['lib/extend', './rankingdatalistener', './vectormodel', //
'options'], function(extend, RankingDataListener, VectorModel, Options) {
  var winscore;

  // FIXME extract "12" to the config.in
  winscore = 12;

  function sign(num) {
    if (num < 0) {
      return -1;
    }
    if (num > 0) {
      return 1;
    }
    if (num === 0) {
      return 0;
    }
    return NaN;
  }

  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingTacListener(ranking) {
    RankingTacListener.superconstructor.call(this, ranking, new VectorModel());
  }
  extend(RankingTacListener, RankingDataListener);

  RankingTacListener.NAME = 'tac';

  RankingTacListener.prototype.onresult = function(r, e, result) {
    var winner, loser, difference, points;

    if (result.teams.length !== 2) {
      throw new Error('TAC ranking requires exactly two teams in a result');
    }

    difference = result.score[0] - result.score[1];
    switch (sign(difference)) {
    case -1:
      winner = 1;
      loser = 0;
      difference = -difference;
      break;
    case 1:
      winner = 0;
      loser = 1;
      break;
    case 0:
      winner = 0;
      loser = 0;
      break;
    default:
      console.error('TAC ranking does not accept draws');
      return undefined;
    }

    if (result.score[winner] >= Options.maxpoints && winner !== loser) {
      // everything went to completion

      // winner
      points = this.tac.get(result.teams[winner]) + winscore + difference;
      this.tac.set(result.teams[winner], points);

      // loser
      points = this.tac.get(result.teams[loser]) + result.score[loser];
      if (result.score[loser] === 0) {
        points += 1;
      }
      this.tac.set(result.teams[loser], points);
    } else {
      // game had to be aborted. Timeout situation: teams keep their own
      // points

      points = this.tac.get(result.teams[0]) + result.score[0];
      this.tac.set(result.teams[0], points);

      points = this.tac.get(result.teams[1]) + result.score[1];
      this.tac.set(result.teams[1], points);
    }
  };

  /**
   * bye listener
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event, i.e. 'bye'
   * @param teams
   *          an array of teams, as prepared and provided by RankingModel.bye()
   */
  RankingTacListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(team) {
      var points = this.tac.get(team) + Options.byepointswon
          - Options.byepointslost;
      this.tac.set(team, points);
    }, this);
  };

  RankingTacListener.prototype.oncorrect = function(r, e, correction) {
    // TODO DRY - Don't Repeat Yourself!
    // TODO extract a method for use by onresult and oncorrect
    var winner, loser, difference, points;

    if (correction.before.teams.length !== 2) {
      throw new Error('TAC ranking requires exactly two teams in a result');
    }

    difference = correction.before.score[0] - correction.before.score[1];
    switch (sign(difference)) {
    case -1:
      winner = 1;
      loser = 0;
      difference = -difference;
      break;
    case 1:
      winner = 0;
      loser = 1;
      break;
    case 0:
      winner = 0;
      loser = 0;
      break;
    default:
      console.error('TAC ranking does not accept draws');
      return undefined;
    }

    if (correction.before.score[winner] >= Options.maxpoints
        && winner !== loser) {
      // everything went to completion

      // winner
      points = this.tac.get(correction.before.teams[winner]) - winscore
          - difference;
      this.tac.set(correction.before.teams[winner], points);

      // loser
      points = this.tac.get(correction.before.teams[loser])
          - correction.before.score[loser];
      if (correction.before.score[loser] === 0) {
        points -= 1;
      }
      this.tac.set(correction.before.teams[loser], points);
    } else {
      // game had to be aborted. Timeout situation: teams keep their own
      // points

      points = this.tac.get(correction.before.teams[0])
          - correction.before.score[0];
      this.tac.set(correction.before.teams[0], points);

      points = this.tac.get(correction.before.teams[1])
          - correction.before.score[1];
      this.tac.set(correction.before.teams[1], points);
    }

    this.onresult(r, e, correction.after);
  };

  return RankingTacListener;
});

/**
 * RankingSonnebornListener
 *
 * @return RankingSonnebornListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingsonnebornlistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingSonnebornListener(ranking) {
    RankingSonnebornListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingSonnebornListener, RankingDataListener);

  RankingSonnebornListener.NAME = 'sonneborn';
  RankingSonnebornListener.DEPENDENCIES = ['winsmatrix', 'wins'];

  RankingSonnebornListener.prototype.onrecalc = function() {
    // TODO exclude bye from sonneborn points?
    this.winsmatrix.multVector(this.sonneborn, this.wins);
  };

  return RankingSonnebornListener;
});

/**
 * RankingHeadToHeadListener: calculates the (antisymmetric) headtohead from the
 * (asymmetric) winsmatrix by subtracting its transpose from it with a
 * TransposeDifferenceMatrix.
 *
 * @return RankingHeadToHeadListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingheadtoheadlistener',['lib/extend', './rankingdatalistener', './vectormodel',
    './rankingheadtoheadcomponent'], function(extend, RankingDataListener,
    VectorModel, RankingHeadToHeadComponent) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingHeadToHeadListener(ranking) {
    RankingHeadToHeadListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingHeadToHeadListener, RankingDataListener);

  RankingHeadToHeadListener.NAME = 'headtohead';
  RankingHeadToHeadListener.DEPENDENCIES = ['winsmatrix'];

  /**
   * creates a copy of this.ranking, where the ranking stops just before
   * 'headtohead'
   *
   * @return a RankingModel instance, which is a direct copy of this.ranking,
   *         but stops its ranking just before the 'headtohead' component
   */
  RankingHeadToHeadListener.prototype.createDummyRanking = function() {
    var components, dummyRanking, RankingModel;

    components = this.ranking.componentnames.slice(0);
    components.splice(components.indexOf(RankingHeadToHeadComponent.NAME));

    RankingModel = require('core/rankingmodel');
    dummyRanking = new RankingModel(components, this.ranking.length);

    Object.keys(this.ranking.dataListeners).forEach(function(name) {
      if (dummyRanking[name]) {
        dummyRanking[name] = this.ranking[name];
      }
    }, this);

    return dummyRanking;
  };

  /**
   * converts the dummy ranking result to a 2d array of equally-ranked teams
   *
   * @param ranks
   *          the result of dummyRanking.get()
   * @return the 2D array of equally-ranked teams
   */
  RankingHeadToHeadListener.prototype.getGroups = function(ranks) {
    var groups = [];

    ranks.ranks.forEach(function(rank, internalid) {
      if (groups[rank] === undefined) {
        groups[rank] = [];
      }

      groups[rank].push(internalid);
    });

    return groups;
  };

  /**
   * calculates the headtohead ranking for each team and writes them straight to
   * this.headtohead
   *
   * @param groups
   *          the result of getGroups()
   */
  RankingHeadToHeadListener.prototype.calculatePoints = function(groups) {
    this.headtohead.fill(0);

    groups.forEach(function(group) {
      group.forEach(function(teamA) {
        var points = this.headtohead.get(teamA);

        group.forEach(function(teamB) {
          points += this.winsmatrix.get(teamA, teamB);
        }, this);

        this.headtohead.set(teamA, points);
      }, this);
    }, this);
  };

  /**
   * Recalculates the headtohead vector, depending on the ranking with only the
   * previous components.
   *
   * The headtohead value is calculated as the sum of wins against
   * equally-ranked teams
   */
  RankingHeadToHeadListener.prototype.onrecalc = function() {
    var dummyRanking, ranks;

    dummyRanking = this.createDummyRanking();

    ranks = dummyRanking.getNoRecalc();

    groups = this.getGroups(ranks);

    this.calculatePoints(groups);
  };

  return RankingHeadToHeadListener;
});

/**
 * RankingNumGamesListener
 *
 * @return RankingNumGamesListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingnumgameslistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingNumGamesListener(ranking) {
    RankingNumGamesListener.superconstructor.call(this, ranking,
        new VectorModel());
  }
  extend(RankingNumGamesListener, RankingDataListener);

  RankingNumGamesListener.NAME = 'numgames';
  RankingNumGamesListener.DEPENDENCIES = undefined;

  /**
   * insert the results of a game into the ranking.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingNumGamesListener.prototype.onresult = function(r, e, result) {
    result.teams.forEach(function(teamid) {
      this.numgames.set(teamid, this.numgames.get(teamid) + 1);
    }, this);
  };

  /**
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param teams
   *          an array of team ids
   */
  RankingNumGamesListener.prototype.onbye = function(r, e, teams) {
    teams.forEach(function(teamid) {
      this.numgames.set(teamid, this.numgames.get(teamid) + 1);
    }, this);
  };

  /**
   * correct a ranking entry. Do not check whether it's valid. The
   * TournamentModel has to take care of that
   *
   * @param r
   *          the Emitter, i.e. a RankingModel instance
   * @param e
   *          the event type, i.e. "correct"
   * @param correction
   *          a game correction
   */
  RankingNumGamesListener.prototype.oncorrect = function(r, e, correction) {
    correction.before.teams.forEach(function(teamid) {
      this.numgames.set(teamid, this.numgames.get(teamid) - 1);
    }, this);

    this.onresult(r, e, correction.after);
  };

  return RankingNumGamesListener;
});

/**
 * RankingKOListener
 *
 * @return RankingKOListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingkolistener',['lib/extend', './rankingdatalistener', './vectormodel'], function(
    extend, RankingDataListener, VectorModel) {
  var KOTournamentModel;

  KOTournamentModel = undefined;

  /**
   * @param result
   *          a MatchResult instance
   * @return the index of the loser (for result.getTeamID(index)), or undefined
   *         if no unique loser exists
   */
  function getLoser(result) {
    var loser, minpoints;

    loser = undefined;
    minpoints = undefined;

    result.teams.forEach(function(teamid, index) {
      var points;
      points = result.score[index];
      if (minpoints === undefined || points < minpoints) {
        loser = teamid;
        minpoints = points;
      } else if (points === minpoints) {
        loser = undefined;
      }
    }, this);

    return loser;
  }

  /**
   * Constructor
   *
   * @param ranking
   *          a RankingModel instance
   */
  function RankingKOListener(ranking) {
    RankingKOListener.superconstructor.call(this, ranking, // autoformat
    new VectorModel());
  }
  extend(RankingKOListener, RankingDataListener);

  RankingKOListener.NAME = 'ko';
  RankingKOListener.DEPENDENCIES = undefined;

  /**
   * insert the results of a game into the ranking.
   *
   * @param r
   *          the emitting RankingModel instance. Please ignore.
   * @param e
   *          the name of the emitted event
   * @param result
   *          a game result
   */
  RankingKOListener.prototype.onresult = function(r, e, result) {
    var matchID, group, loser;

    matchID = result.getID();
    group = result.getGroup();
    loser = getLoser(result);

    if (loser === undefined) {
      console.error('there is no loser. just pick the second team.');
      loser = result.getTeamID(1);
    }

    if (matchID <= 1) {
      this.ko.set(loser, -2 * group - 1);
    } else {
      if (!KOTournamentModel) {
        KOTournamentModel = require('core/kotournamentmodel');
      }

      this.ko.set(loser, -2 * KOTournamentModel.loserGroupID(group, matchID));
    }
  };

  return RankingKOListener;
});

/**
 * RankingDataListenerIndex: An object which indexes the constructors of all
 * RankingDataListeners. RankingDataListenerIndex.registerDataListeners()
 * creates an array of listeners from the RankingComponentIndex-provided
 * dependencies.
 *
 * Helper functions resolve the dependencies to provide a correctly ordered
 * array of DataListener instances, so the recalc events will be fired in the
 * correct order.
 *
 * @return RankingDataListenerIndex
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingdatalistenerindex',[//
'./rankinglostpointslistener', //
'./rankingpointslistener',//
'./rankingsaldolistener', //
'./rankingupvoteslistener', //
'./rankingdownvoteslistener', //
'./rankingvoteslistener', //
'./rankingbyelistener', //
'./rankingwinslistener', //
'./rankinggamematrixlistener', //
'./rankingbuchholzlistener', //
'./rankingfinebuchholzlistener', //
'./rankingwinsmatrixlistener', //
'./rankingtaclistener', //
'./rankingsonnebornlistener', //
'./rankingheadtoheadlistener', //
'./rankingnumgameslistener', //
'./rankingkolistener'], //
function() {
  var RankingDataListenerIndex;

  /**
   * build the index from the RankingXXXListener.NAME fields
   *
   * @param DataListeners
   *          the arguments object of the outer function. NOT an array!
   * @return a RankingDataListenerIndex object (no class)
   */
  RankingDataListenerIndex = (function(DataListeners) {
    var RDLI, index, DataListener;

    RDLI = {};
    for (index = 0; index < DataListeners.length; index += 1) {
      DataListener = DataListeners[index];
      RDLI[DataListener.NAME.toLowerCase()] = DataListener;
    }

    return RDLI;
  })(arguments);

  /**
   * return the DataListener as referenced by its name
   *
   * @param name
   *          the registered name of the DataListener
   * @return a DataListener subclass (constructor)
   */
  function getDataListener(name) {
    return RankingDataListenerIndex[name];
  }

  /**
   * return the dependencies array of the DataListener with the given name
   *
   * @param name
   *          the registered name of the DataListener
   * @return an array of dependency names, or undefined if there are no
   *         dependencies
   */
  function getDataDependencies(name) {
    var DataListener = getDataListener(name);
    if (!DataListener) {
      console.warn('DataListener is undefined: ' + name);
      return undefined;
    }
    return getDataListener(name).DEPENDENCIES;
  }

  /**
   * Check whether all dependencies are fulfilled, i.e. the required
   * dependencies are part of the provided dependency
   *
   * @param required
   *          an array of required dependencies
   * @param provided
   *          an array of the provided dependencies
   *
   * @return true when the dependencies are fulfilled, false otherwise
   */
  function dependenciesFulfilled(required, provided) {
    if (!required) {
      return true;
    }
    if (!provided) {
      return false;
    }

    return required.every(function(dependency) {
      return provided.indexOf(dependency) !== -1;
    });
  }

  /**
   * Missing dependencies are read from RankingXListener.DEPENDENCIES and
   * appended as needed. There's no additional dependency order resolution
   *
   * @param dependencies
   *          Where new dependencies are added to and the dependencies are read
   *          from
   */
  function addMissingDependencies(dependencies) {
    var index, dataDependencies;

    for (index = 0; index < dependencies.length; index += 1) {
      dataDependencies = getDataDependencies(dependencies[index]);
      if (dataDependencies) {
        dataDependencies.forEach(function(DEP) {
          if (dependencies.indexOf(DEP) === -1) {
            dependencies.push(DEP);
          }
        });
      }
    }
  }

  /**
   * removes multiple entries in dependencies
   *
   * @param dependencies
   *          an array of dependency names
   *
   * @return dependencies an array of all dependencies, in any order
   */
  function removeMultipleDependencies(dependencies) {
    var index;

    for (index = dependencies.length - 1; index >= 0; index -= 1) {
      if (dependencies.indexOf(dependencies[index]) < index) {
        dependencies.splice(index, 1);
      }
    }
  }

  /**
   * perform a single dependency ordering run.
   *
   * @param input
   *          an input array with names which are not yet part of output
   * @param output
   *          an output array which to push the names to, if their dependencies
   *          are in
   * @return true of an element has been moved, false otherwise
   */
  function orderDependenciesOnce(input, output) {
    var added;

    added = []; // array of indices

    // transfer every name whose dependencies have been fulfilled
    input.forEach(function(name, index) {
      if (dependenciesFulfilled(getDataDependencies(name), output)) {

        added.push(index);
        output.push(name);
      }
    });

    // remove the items beginning with the last one to not corrupt the array
    added.reverse();
    added.forEach(function(inputIndex) {
      input.splice(inputIndex, 1);
    });

    return added.length > 0;
  }

  /**
   * order the names by their dependencies inplace, i.e. without creating a new
   * array for output
   *
   * @param names
   *          the input array, which contains the names. Also works as the
   *          output array.
   * @return false on failure, true on success
   */
  function orderDependencies(names) {
    var input;

    input = names.splice(0).reverse();

    addMissingDependencies(input);
    removeMultipleDependencies(input);

    // keep adding names until there's none left
    while (orderDependenciesOnce(input, names)) {
      //
    }

    // check for unresolvable dependencies
    if (input.length > 0) {
      console.error('dependencies could not be resolved: [' + input.join(',')
          + ']');
      names.splice(0);
      return false;
    }

    return true;
  }

  /**
   * remove all defined names and leave only the undefined names in the array
   *
   * @param names
   *          an array of dependency names
   */
  function extractUndefinedNames(names) {
    var index;

    for (index = names.length - 1; index >= 0; index -= 1) {
      if (getDataListener(names[index]) !== undefined) {
        names.splice(index, 1);
      }
    }
  }

  /**
   * order the names by their dependencies and register every DataListener, if
   * available. Aborts otherwise
   *
   * @param names
   *          an array of DataListener names (see RankingDataListener.NAME).
   *          Will contain the names, which correspond to the returned
   *          listeners. On error, undefined names are written here.
   * @param ranking
   *          the RankingModel instance to register the listeners to
   * @return A ordered array of DataListener instances on success, undefined
   *         otherwise
   */
  RankingDataListenerIndex.registerDataListeners = function(ranking, names) {
    var DataListeners;

    if (!names) {
      return undefined;
    }

    if (!orderDependencies(names)) {
      return undefined;
    }

    DataListeners = names.map(function(name) {
      return getDataListener(name);
    });

    if (DataListeners.indexOf(undefined) >= 0) {
      extractUndefinedNames(names);
      console.error('data listener is undefined: ' + names.join(', '));
      return undefined;
    }

    return DataListeners.map(function(DataListener) {
      return new DataListener(ranking);
    });
  };

  return RankingDataListenerIndex;
});

/**
 * RankingModel: A general ranking model, which can bind different
 * RankingComponents in order and sort using their compare function
 *
 * @return RankingModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/rankingmodel',['lib/extend', './model', './rankingcomponentindex', './type',
    './rankingdatalistenerindex'], function(extend, Model,
    RankingComponentIndex, Type, RankingDataListenerIndex) {

  /**
   * create a list of IDs for reference
   *
   * @return an array of ids, where the index matches the value
   */
  function getIDs() {
    var ids;

    ids = [];
    while (ids.length < this.length) {
      ids.push(ids.length);
    }

    return ids;
  }

  /**
   * order team ids by their ranking
   *
   * @param ids
   *          an array of ids
   * @return an array of ids, sorted by rank
   */
  function getRankingOrder(ids) {
    var order, chain;

    order = ids.slice(0);

    chain = this.componentchain;
    order.sort(function(a, b) {
      return chain.compare(a, b) || (a - b);
    }, this);

    return order;
  }

  /**
   * read the ranks of each team from their array position in the ordered array
   * and their relation to the previous team.
   *
   * @param ids
   *          the return value of getRankingOrder().
   *
   * @return an array of ranks, as retrieved from the ids
   */
  function getRanks(ids) {
    var ranks;

    ranks = new Array(this.length);

    ids.forEach(function(teamid, index) {
      if (index === 0) {
        ranks[teamid] = 0;
      } else {
        if (this.componentchain.compare(ids[index - 1], teamid) < 0) {
          ranks[teamid] = index;
        } else {
          ranks[teamid] = ranks[ids[index - 1]];
        }
      }
    }, this);

    return ranks;
  }

  /**
   * Update the ranking from its data fields. See get() for a description of the
   * ranking object.
   *
   * Private RankingModel function.
   *
   * @param norecalc
   *          true if the data listeners shouldn't be recalculated, undefined or
   *          false otherwise.
   */
  function updateRanking(norecalc) {
    var newRanking, components;

    if (!norecalc) {
      this.emit('recalc');
    }

    newRanking = {
      components: this.componentnames
    };

    newRanking.ids = getIDs.call(this);
    newRanking.displayOrder = getRankingOrder.call(this, newRanking.ids);
    newRanking.ranks = getRanks.call(this, newRanking.displayOrder);

    if (this.componentchain !== undefined) {
      components = this.componentchain.getValues();
      components.forEach(function(component, index) {
        var name;
        if (component !== undefined) {
          name = this.componentnames[index];
          newRanking[name] = component;
        }
      }, this);
    }

    this.ranking = newRanking;
  }

  /**
   * Constructor
   *
   * @param components
   *          an array with sorting strings
   * @param size
   *          the number of teams/players
   * @param externalDependencies
   *          Optional. an array of additional dependencies, e.g. a games matrix
   *          for "have they played"-type questions
   */
  function RankingModel(components, size, externalDependencies) {
    RankingModel.superconstructor.call(this);

    components = components || [];
    size = size || 0;

    this.ranking = undefined;
    this.componentnames = [];
    this.componentchain = undefined;
    this.length = 0;
    this.extDeps = [];
    this.dataListeners = {};

    this.init(components, size, externalDependencies);
  }
  extend(RankingModel, Model);

  /**
   * the different events
   */
  RankingModel.prototype.EVENTS = {
    'result': true, // insert a new game result
    'bye': true, // insert a new bye
    'correct': true, // correct a game
    'recalc': true, // force a recalculation
    'update': true, // there has been an update
    'reset': true, // everything has to be reset
    'resize': true
  // the size of the ranking has been changed
  };

  /**
   * initializes the ranking object
   *
   * @param components
   * @param size
   * @param extDependencies
   * @return true on success, false otherwise
   */
  RankingModel.prototype.init = function(components, size, extDependencies) {
    var dependencies, dataListenerArray;

    // abort if the ranking object has not been reset
    if (this.componentchain || this.componentnames.length !== 0
        || Object.keys(this.dataListeners).length !== 0) {
      return false;
    }

    this.componentnames = components.slice(0);
    this.componentchain = RankingComponentIndex.createComponentChain(this,
        components);
    if (this.componentchain) {
      dependencies = this.componentchain.dependencies;
    } else {
      dependencies = [];
    }

    if (extDependencies) {
      this.extDeps.push.apply(this.extDeps, extDependencies);
      dependencies.push.apply(dependencies, this.extDeps);
    }

    dataListenerArray = RankingDataListenerIndex.registerDataListeners(this,
        dependencies);
    if (dataListenerArray && components && components.length > 0) {
      dataListenerArray.forEach(function(dataListener, index) {
        this.dataListeners[dependencies[index]] = dataListener;
      }, this);
      this.resize(size);
    }

    return true;
  };

  /**
   * restore everything to an initial state, as provided by an empty
   * RankingModel construction
   */
  RankingModel.prototype.reset = function() {
    Object.keys(this.dataListeners).forEach(function(key) {
      this.dataListeners[key].destroy();
    }, this);

    // just let the constructor reset everything for us.
    RankingModel.call(this);
    this.emit('reset');

    // trigger an 'update' event
    this.invalidate();
  };

  /**
   * process a game result
   *
   * @param result
   *          a GameResult instance
   */
  RankingModel.prototype.result = function(result) {
    // TODO result verification?
    this.emit('result', result);
    this.invalidate();
  };

  /**
   * process a bye
   *
   * @param teams
   *          an array of affected teams
   */
  RankingModel.prototype.bye = function(teams) {
    if (Type.isNumber(teams)) {
      teams = [teams];
    }
    this.emit('bye', teams);
    this.invalidate();
  };

  RankingModel.prototype.correct = function(correction) {
    this.emit('correct', correction);
    this.invalidate();
  };

  /**
   * force a full recalculation of the ranking from the data fields. This will
   * not replay the tournament from history, just update dependent data fields.
   */
  RankingModel.prototype.invalidate = function() {
    this.ranking = undefined;
    this.emit('update');
  };

  /**
   * Returns the current ranking as a ranking object. Recalculates as necessary.
   * This function can take up to several seconds for huge tournaments (> 2000)
   *
   * The returned ranking object contains the following fields:
   *
   * ranks: an array of ranks. Equal ranks are allowed
   *
   * displayOrder: an array of player/team indices, which is pre-sorted by rank.
   * The index in this array does reflect the rank ONLY if each rank is unique.
   *
   * components: an ordered array of RankingComponent names.
   *
   * For each component with not-undefined values, there's an equally-named
   * field, which contains the values.
   *
   * @return the current ranking, as a ranking object
   */
  RankingModel.prototype.get = function() {
    if (this.ranking === undefined) {
      updateRanking.call(this);
    }

    return this.ranking;
  };

  RankingModel.prototype.getNoRecalc = function() {
    updateRanking.call(this, true);

    return this.ranking;
  };

  /**
   * Resizes the ranking data structures
   *
   * WARNING: This operation can delete data when reducing the size. Be careful
   *
   * @param size
   *          the new size
   * @return true on success, false otherwise
   */
  RankingModel.prototype.resize = function(size) {
    if (size === this.length) {
      return true;
    }
    if (size >= 0) {
      this.length = size;
      this.emit('resize');
      this.invalidate();
      return true;
    }

    console.error('RankingModel.resize: invalid size: ' + size);
    return false;
  };

  /**
   * stores the necessary scores and points in a data object for serialization.
   * Only primary data containers are stored, as the other ones can be
   * recalculated.
   *
   * @return a serializable data object
   */
  RankingModel.prototype.save = function() {
    var data = RankingModel.superclass.save.call(this);

    data.len = this.length;
    data.comps = this.componentnames.slice(0);
    data.edep = this.extDeps.slice(0);
    data.vals = {};

    // only store primary dataListeners. Abort on error
    if (!Object.keys(this.dataListeners).every(function(name) {
      var listener;
      listener = this.dataListeners[name];

      if (listener.isPrimary(listener)) {
        if (this[name] && Type.isFunction(this[name].save)) {
          data.vals[name] = this[name].save();
        } else {
          console.error('datalistener cannot be saved: ' + name);
          return false;
        }
      }
      return true;
    }, this)) {
      return undefined;
    }

    return data;
  };

  /**
   * restores the ranking from a previously saved data object
   *
   * @param data
   *          a deserialized data object
   * @return true on success, false otherwise
   */
  RankingModel.prototype.restore = function(data) {
    if (!RankingModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.reset();
    if (!this.init(data.comps, data.len, data.edep)) {
      this.reset();
      return false;
    }

    if (!Object.keys(data.vals).every(function(name) {
      if (this[name] && this[name].restore) {
        if (this[name].restore(data.vals[name])) {
          return true;
        }
      }
      console.error('RankingModel.restore(): cannot restore listener ' + name);
      return false;
    }, this)) {
      this.reset();
      return false;
    }

    this.invalidate();

    return true;
  };

  RankingModel.prototype.SAVEFORMAT = Object
      .create(RankingModel.superclass.SAVEFORMAT);
  RankingModel.prototype.SAVEFORMAT.len = Number;
  RankingModel.prototype.SAVEFORMAT.comps = [String];
  RankingModel.prototype.SAVEFORMAT.edep = [String];
  RankingModel.prototype.SAVEFORMAT.vals = Object;

  return RankingModel;
});

/**
 * ReferenceListModel: for every match in the matchlist, provide read-only
 * access to the matches, while translating the team indices to external team
 * numbers (e.g. global team ids)
 *
 * @return ReferenceListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/referencelistmodel',['lib/extend', './listmodel'], function(extend, ListModel) {

  /**
   * Constructor
   *
   * @param matchlist
   *          a ListModel instance comprising of MatchModel instances
   * @param teamlist
   *          a ListModel instance comprising of team numbers
   * @param ReferenceModel
   *          a reference model, which takes an actual model and a team list as
   *          the constructor arguments, and creates a reference to the model
   */
  function ReferenceListModel(matchlist, teamlist, ReferenceModel) {
    ReferenceListModel.superconstructor.call(this);

    this.makeReadonly();

    this.matches = matchlist;
    this.teams = teamlist;
    this.ReferenceModel = ReferenceModel;

    this.matches.map(function(match, id) {
      ReferenceListModel.insertMatch(this, id);
    }, this);

    this.matches.registerListener(this);
  }
  extend(ReferenceListModel, ListModel);

  /**
   * Helper function for dealing with readonly list: Do not call directly
   *
   * @param referenceList
   *          a ReferenceListModel instance
   * @param id
   *          the id to insert at
   */
  ReferenceListModel.insertMatch = function(referenceList, id) {
    var ref;
    ref = new referenceList.ReferenceModel(referenceList.matches.get(id),
        referenceList.teams);
    ListModel.prototype.insert.call(referenceList, id, ref);
  };

  /**
   * Helper function for dealing with readonly list: Do not call directly
   *
   * @param list
   *          a ReferenceListModel instance
   * @param id
   *          the id to remove
   */
  ReferenceListModel.removeMatch = function(list, id) {
    ListModel.prototype.remove.call(list, id);
  };

  /**
   * Callback function: called when an 'insert' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReferenceListModel.prototype.oninsert = function(emitter, event, data) {
    if (emitter === this.matches) {
      ReferenceListModel.insertMatch(this, data.id);
    }
  };

  /**
   * Callback function: called when a 'remove' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReferenceListModel.prototype.onremove = function(emitter, event, data) {
    if (emitter === this.matches) {
      ReferenceListModel.removeMatch(this, data.id);
    }
  };

  /**
   * Callback function: called when a 'reset' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReferenceListModel.prototype.onreset = function(emitter, event, data) {
    if (emitter === this.matches) {
      this.emit(event, data);
    }
  };

  /*
   * Note to self:
   *
   * There's no need to intercept onresize, because the remove and insert
   * functions automatically emit resize events.
   */

  return ReferenceListModel;
});

/**
 * MapListModel: map a list of indices to actual elements, which can be indexed
 * from a list. This is useful for mapping between local/global elements as a
 * readonly list.
 *
 * @return MapListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/maplistmodel',['lib/extend', './listmodel'], function(extend, ListModel) {

  /**
   * Constructor
   *
   * @param indexlist
   *          a list of integer indices
   * @param maplist
   *          a static list, which contains elements that are indexed by
   *          indexlist. This class does not listen for changes in the map
   */
  function MapListModel(indexlist, maplist) {
    MapListModel.superconstructor.call(this);

    this.makeReadonly();

    this.indices = indexlist;
    this.map = maplist;

    this.indices.map(function(index, pos) {
      MapListModel.insertID(this, pos);
    }, this);

    this.indices.registerListener(this);
  }
  extend(MapListModel, ListModel);

  /**
   * Helper function for dealing with readonly list: Do not call directly
   *
   * @param list
   *          a MapListModel instance
   * @param pos
   *          the id to insert at
   */
  MapListModel.insertID = function(list, pos) {
    var ref;
    ref = list.map.get(list.indices.get(pos));
    ListModel.prototype.insert.call(list, pos, ref);
  };

  /**
   * Helper function for dealing with readonly list: Do not call directly
   *
   * @param list
   *          a MapListModel instance
   * @param id
   *          the id to remove
   */
  MapListModel.removeID = function(list, id) {
    ListModel.prototype.remove.call(list, id);
  };

  /**
   * Callback function: called when an 'insert' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  MapListModel.prototype.oninsert = function(emitter, event, data) {
    if (emitter === this.indices) {
      MapListModel.insertID(this, data.id);
    }
  };

  /**
   * Callback function: called when a 'remove' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  MapListModel.prototype.onremove = function(emitter, event, data) {
    if (emitter === this.indices) {
      MapListModel.removeID(this, data.id);
    }
  };

  /**
   * Callback function: called when a 'reset' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  MapListModel.prototype.onreset = function(emitter, event, data) {
    if (emitter === this.indices) {
      this.emit(event, data);
    }
  };

  /*
   * Note to self:
   *
   * There's no need to intercept onresize, because the remove and insert
   * functions automatically emit resize events.
   */

  return MapListModel;
});

/**
 * ReadonlyListModel
 *
 * @return ReadonlyListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/readonlylistmodel',['lib/extend', './model', './listmodel'], function(extend, Model,
    ListModel) {
  /**
   * Constructor
   *
   * @param list
   *          another ListModel instance
   */
  function ReadonlyListModel(list) {
    ReadonlyListModel.superconstructor.call(this);

    this.list = list;
    this.length = this.list.length;

    this.list.registerListener(this);
  }
  extend(ReadonlyListModel, Model);

  ReadonlyListModel.prototype.EVENTS = ListModel.prototype.EVENTS;

  ReadonlyListModel.prototype.get = function() {
    return this.list.get.apply(this.list, arguments);
  };

  ReadonlyListModel.prototype.indexOf = function() {
    return this.list.indexOf.apply(this.list, arguments);
  };

  ReadonlyListModel.prototype.map = function() {
    return this.list.map.apply(this, arguments);
  };

  ReadonlyListModel.prototype.asArray = function() {
    return this.list.asArray.apply(this.list, arguments);
  };

  ReadonlyListModel.prototype.updateLength = function() {
    this.length = this.list.length;
  };

  /**
   * Callback function: called when an 'insert' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReadonlyListModel.prototype.oninsert = function(emitter, event, data) {
    this.emit(event, data);
  };

  /**
   * Callback function: called when a 'remove' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReadonlyListModel.prototype.onremove = function(emitter, event, data) {
    this.emit(event, data);
  };

  /**
   * Callback function: called when a 'reset' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReadonlyListModel.prototype.onreset = function(emitter, event, data) {
    this.emit(event, data);
  };

  /**
   * Callback function: called when a 'reset' event is emitted
   *
   * @param emitter
   * @param event
   * @param data
   */
  ReadonlyListModel.prototype.onresize = function(emitter, event, data) {
    this.updateLength();
    this.emit(event, data);
  };

  return ReadonlyListModel;
});

/**
 * TournamentModel: An abstract tournament class which provides the basic
 * functions, such as ranking, team lists, invalidation, caching and a reference
 * name.
 *
 * TournamentModel implements the IndexedModel interface, although it's no
 * direct descendant. This is to ensure the encapsulation in IndexedListModels.
 *
 * @return TournamentModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tournamentmodel',['lib/extend', './propertymodel', './listmodel', './uniquelistmodel',
    './rankingmapper', './statevaluemodel', './matchmodel', './matchresult',
    'ui/listcollectormodel', './listener', './rankingmodel',
    './referencelistmodel', './maplistmodel', './valuemodel',
    './readonlylistmodel', 'options', './indexedmodel', './correctionmodel',
    './matchreferencemodel', './resultreferencemodel', 'core/type',
    './correctionreferencemodel', './sortedreferencelistmodel',
    './combinedreferencelistmodel', './byeresult'], function(extend,
    PropertyModel, ListModel, UniqueListModel, RankingMapper, StateValueModel,
    MatchModel, MatchResult, ListCollectorModel, Listener, RankingModel,
    ReferenceListModel, MapListModel, ValueModel, ReadonlyListModel, Options,
    IndexedModel, CorrectionModel, MatchReferenceModel, ResultReferenceModel,
    Type, CorrectionReferenceModel, SortedReferenceListModel,
    CombinedReferenceListModel, ByeResult) {
  var STATETRANSITIONS, INITIALSTATE;

  /*
   * STATES lists the possible states.The following states are possible:
   *
   * 'initial': for player/team registration before the first match. Can be
   * followed by 'running' and 'finished'. Initial state. In some tournament
   * systems, registration is only possible during 'initial' state.
   *
   * 'running': there are open matches. Preceded by 'initial' or 'idle', can be
   * followed by 'idle' and 'finished'
   *
   * 'idle': all previous matches have been finished, but new matches can still
   * be generated. Preceded by 'running', followed by 'running' or 'finished'.
   * Interaction required for state transition.
   *
   * 'finished': all matches are finished, no matches can be created anymore. No
   * registration possible. Preceded by 'running' or 'idle'. Final and constant
   * state.
   *
   */
  STATETRANSITIONS = {
    'initial': ['running'],
    'running': ['idle', 'finished'],
    'idle': ['running', 'finished'],
    'finished': []
  };
  INITIALSTATE = 'initial';

  /**
   * Constructor
   *
   * @param rankingorder
   *          an array of ranking orders, e.g. ['wins', 'buchholz']
   */
  function TournamentModel(rankingorder) {
    var collector;

    TournamentModel.superconstructor.call(this);
    IndexedModel.call(this);

    // TODO initialize with properties

    // rankingorder default: sort by entry order
    rankingorder = rankingorder || ['id'];

    this.state = new StateValueModel(INITIALSTATE, STATETRANSITIONS);
    this.teams = new UniqueListModel();
    this.matches = new ListModel();
    this.ranking = new RankingModel(rankingorder, 0, this.RANKINGDEPENDENCIES);
    this.votes = TournamentModel.initVoteLists(this.VOTES);
    this.history = new ListModel();
    this.corrections = new ListModel();
    this.name = new ValueModel(this.SYSTEM);

    // singletons for the getters(), in order to not bloat the listener
    // arrays
    this.singletons = {};

    // initial properties
    this.setProperty('addteamrunning', false);
    this.setProperty('addteamidle', false);

    // listen to the matches
    collector = new ListCollectorModel(this.matches, MatchModel);
    collector.registerListener(this);

    // print error messages to the output
    Listener.bind(this, 'error', function(emitter, event, message) {
      console.error(message);
    });
  }
  extend(TournamentModel, PropertyModel);

  /**
   * a unique name for the tournament mode, e.g. 'ko' or 'tacteam'
   */
  TournamentModel.prototype.SYSTEM = 'undefined';

  /**
   * send event on state change
   */
  TournamentModel.prototype.EVENTS = {
    'state': true,
    'error': true,
    'update': true
  };

  /**
   * Array of additional ranking dependencies, e.g. ['matchmatrix']
   */
  TournamentModel.prototype.RANKINGDEPENDENCIES = [];

  /**
   * an array of required vote lists
   */
  TournamentModel.prototype.VOTES = ['bye'];

  /**
   * @param types
   *          an array of vote types
   * @return a dictionary of vote lists
   */
  TournamentModel.initVoteLists = function(types) {
    var votes;

    votes = {};

    types.forEach(function(type) {
      votes[type] = new ListModel();
    });

    return votes;
  };

  /**
   * automatically check if the tournament is supposed to be in an idle state
   * and transition to the idle state if necessary
   */
  TournamentModel.prototype.checkIdleState = function() {
    if (this.state.get() === 'running' && this.matches.length === 0) {

      // TODO add votes to history

      // clear votes
      Object.keys(this.votes).forEach(function(key) {
        this.votes[key].clear();
      }, this);

      // apply idle state
      this.state.set('idle');
    }
  };

  /**
   * change the ranking order after tournament creation
   *
   * TODO write unit test
   *
   * @param rankingorder
   *          an array of ranking order component names
   * @return true on success, false otherwise
   */
  TournamentModel.prototype.setRankingOrder = function(rankingorder) {
    if (this.state.get() !== 'initial') {
      this.emit('error',
          'cannot change ranking order after starting a tournament');
      return undefined;
    }

    this.ranking.reset();
    return this.ranking.init(rankingorder || ['id'], this.teams.length,
        this.RANKINGDEPENDENCIES);
  };

  /**
   * add a team id to the tournament. Teams can only be entered once.
   *
   * Undefined behaviour if the tournament has already started.
   *
   * TODO use some configuration object to determine
   *
   * @param teamid
   *          the external id of a team
   * @return true on success, false if the team already exists. undefined if the
   *         team cannot be added in the current state
   */
  TournamentModel.prototype.addTeam = function(teamid) {
    // TODO isNumber() check
    switch (this.state.get()) {
    case 'initial':
      break;
    case 'running':
      if (!this.getProperty('addteamrunning')) {
        return undefined;
      }
      break;
    case 'idle':
      if (!this.getProperty('addteamidle')) {
        return undefined;
      }
      break;
    case 'finished':
      this.emit('error', 'cannot enter add a team to a finished tournament');
      return undefined;
    }

    if (this.teams.push(teamid) !== undefined) {
      this.ranking.resize(this.teams.length);
      return true;
    }

    return false;
  };

  /**
   * Retrieve the state of the tournament as a ValueModel instance, which emits
   * update events and provides a get() function for the state
   *
   * @return a readonly ValueModel instance of the state. use the get() function
   *         to retrieve the current value of the state
   */
  TournamentModel.prototype.getState = function() {
    if (this.singletons.state === undefined) {
      this.singletons.state = new ValueModel(this.state.get());
      this.singletons.state.bind(this.state);
    }
    return this.singletons.state;
  };

  /**
   * @return a ListModel of the registered teams.
   */
  TournamentModel.prototype.getTeams = function() {
    if (this.singletons.teams === undefined) {
      this.singletons.teams = new ReadonlyListModel(this.teams);
    }
    return this.singletons.teams;
  };

  /**
   * @return ListModel of the running matches, with global team ids
   */
  TournamentModel.prototype.getMatches = function() {
    if (this.singletons.matches === undefined) {
      this.singletons.matches = new ReferenceListModel(
          new SortedReferenceListModel(this.matches,
              TournamentModel.matchCompare), this.teams, MatchReferenceModel);
    }
    return this.singletons.matches;
  };

  /**
   * compare the groups and ids of two matches
   *
   * @param a
   *          the first match
   * @param b
   *          the second match
   * @return the order relation: 0, >0 or <0
   */
  TournamentModel.matchCompare = function(a, b) {
    return (a.getGroup() - b.getGroup()) || (a.getID() - b.getID());
  };

  /**
   * @return ListModel of the running matches, with global team ids
   */
  TournamentModel.prototype.getHistory = function() {
    if (this.singletons.history === undefined) {
      this.singletons.history = new ReferenceListModel(
          new SortedReferenceListModel(this.history,
              TournamentModel.matchCompare), this.teams, ResultReferenceModel);
    }
    return this.singletons.history;
  };

  /**
   * @return ListModel of the running matches, with global team ids
   */
  TournamentModel.prototype.getCombinedHistory = function() {
    // prepare this.singletons.sortedRawHistory

    if (this.singletons.combinedHistory === undefined) {
      // combine matches and history into a single list
      this.singletons.combinedRawHistory = new CombinedReferenceListModel(
          this.matches, this.history);
      // sort the combined list
      this.singletons.sortedCombinedRawHistory = new SortedReferenceListModel(
          this.singletons.combinedRawHistory, TournamentModel.matchCompare);
      // reference the combined list and map the teams
      this.singletons.combinedHistory = new ReferenceListModel(
          this.singletons.sortedCombinedRawHistory, this.teams,
          ResultReferenceModel);
    }
    return this.singletons.combinedHistory;
  };

  /**
   * @return ListModel of the running matches, with global team ids
   */
  TournamentModel.prototype.getCorrections = function() {
    if (this.singletons.corrections === undefined) {
      this.singletons.corrections = new ReferenceListModel(this.corrections,
          this.teams, CorrectionReferenceModel);
    }
    return this.singletons.corrections;
  };

  /**
   * retrieve vote lists for the current 'running' state (i.e. current round)
   *
   * @param type
   *          the vote type, i.e. 'bye', 'up', 'down', ...
   * @return a readonly listmodel of team ids which received the specified, or
   *         undefined if the vote type doesn't exist
   */
  TournamentModel.prototype.getVotes = function(type) {
    if (!type || this.votes[type] === undefined) {
      this.emit('error', 'vote type "' + type
          + '" does not exist for this tournament type');
      return undefined;
    }

    if (this.singletons.votes === undefined) {
      this.singletons.votes = {};
    }

    if (this.singletons.votes[type] === undefined) {
      this.singletons.votes[type] = new MapListModel(this.votes[type],
          this.teams);
    }

    return this.singletons.votes[type];
  };

  TournamentModel.prototype.getName = function() {
    if (this.singletons.name === undefined) {
      this.singletons.name = new ValueModel();
      this.singletons.name.bind(this.name);
      this.name.bind(this.singletons.name);
    }

    return this.singletons.name;
  };

  /**
   * retrieve a dynamic ranking object from which the ranking can be read with
   * global ids
   *
   * @return a RankingMapper instance, which emits 'update' and provides get()
   */
  TournamentModel.prototype.getRanking = function() {
    if (this.singletons.ranking === undefined) {
      this.singletons.ranking = new RankingMapper(this.ranking, this.teams);
    }
    return this.singletons.ranking;
  };

  /**
   * runs the tournament by creating matches and transitioning into 'running'
   * state, if possible.
   *
   * @return true on success, undefined otherwise
   */
  TournamentModel.prototype.run = function() {
    switch (this.state.get()) {
    case 'initial':
      if (this.initialMatches()) {
        break;
      }
      this.emit('error', 'initialMatches() failed');
      return undefined;
    case 'idle':
      if (this.idleMatches()) {
        break;
      }
      this.emit('error', 'idleMatches() failed');
      return undefined;
    case 'running':
      this.emit('error', 'tournament is already running');
      return undefined;
    case 'finished':
      this.emit('error', 'tournament is already finished');
      return undefined;
    }

    if (this.matches.length > 0) {
      this.state.set('running');
    } else {
      throw new Error('tournament is running, but no games have been created');
    }
    return true;
  };

  /**
   * manually finish a tournament, which is in 'idle' state (or 'initial' state)
   *
   * @return true on success, false otherwise
   */
  TournamentModel.prototype.finish = function() {
    switch (this.state.get()) {
    case 'idle':
      this.state.set('finished');
      return true;
    case 'finished':
      return true;
    case 'initial':
      this.state.set('finished');
      return true;
    case 'running':
      this.emit('error', 'cannot finish a running tournament');
      break;
    }

    return false;
  };

  /**
   * validate and process a match result
   *
   * @param emitter
   *          the emitter, i.e. the collector. no use.
   * @param event
   *          the event, i.e. 'finish'. no use.
   * @param matchresult
   *          a matchresult instance, which has been enhanced with a 'source'
   *          attribute, which is a reference to the original MatchModel
   *          instance
   */
  TournamentModel.prototype.onfinish = function(emitter, event, matchresult) {
    var match;

    match = matchresult.source;

    if (this.matches.indexOf(match) === -1) {
      this.emit('error',
          'onfinish: match is not open anymore or does not exist');
      return;
    }

    if (!this.validateMatchResult(matchresult)) {
      this.emit('error', 'onfinish: match result fails validation test');
      return;
    }

    this.matches.erase(match);

    this.history.push(matchresult);

    this.ranking.result(matchresult);

    this.postprocessMatch(matchresult);

    this.checkIdleState();
  };

  /*****************************************************************************
   * ABSTRACT FUNCTIONS
   ****************************************************************************/

  /**
   * Validate a match result before accepting it. If validation fails, the
   * result is discarded and the match is supposed to stay open.
   *
   * @param matchresult
   *          a MatchResult instance
   * @return true if the result is valid, false otherwise
   */
  TournamentModel.prototype.validateMatchResult = function(matchresult) {
    var valid;

    valid = matchresult.score.every(function(score) {
      return score >= Options.minpoints && score <= Options.maxpoints;
    });

    return valid;
  };

  /**
   * Validate a result before accepting it. If the validation fails, the
   * correction is discarded and the result remains the way it was.
   *
   * @param correction
   *          a CorrectionModel instance
   * @return true on success, false otherwise
   */
  TournamentModel.prototype.validateCorrection = function(correction) {
    return true;
  };

  /**
   * perform additional functions after a match has been finished and its result
   * has been written to history and ranking. Can be used to start new matches
   * or adjust the tournament state to 'finished'.
   *
   * @param matchresult
   *          a valid and accepted match result
   */
  TournamentModel.prototype.postprocessMatch = function(matchresult) {
    // Default: Do nothing.
  };

  /**
   * perform additional functions after a result has been corrected. This may
   * include reverting to a previous state and re-rolling the entire tournament
   * from this point on, or doing nothing since most cases are already handled
   * by the ranking
   *
   * @param correction
   *          the applied correction
   */
  TournamentModel.prototype.postprocessCorrection = function(correction) {
    // Default: Do nothing.
  };

  /**
   * create matches from an initial state (first round)
   *
   * @return true on success (i.e. valid matches have been created), false or
   *         undefined otherwise
   */
  TournamentModel.prototype.initialMatches = function() {
    // create matches here

    if (this.teams.length < 3) {
      return false;
    }

    this.matches.push(new MatchModel([0, 1], 1, 0));
    this.votes.bye.push(2);

    return true;
  };

  /**
   * create matches from an idle state (subsequent rounds)
   *
   * @return true on success (i.e. valid matches have been created), false or
   *         undefined otherwise
   */
  TournamentModel.prototype.idleMatches = function() {
    // create matches here

    this.matches.push(new MatchModel([1, 2], 1, 0));
    this.votes.bye.push(0);

    return true;
  };

  /**
   * Properly add a ByeResult to this.votes, this.ranking and this.history.
   *
   * @param byeResultOrTeamID
   *          Either a proper byeResult, or the team ID
   * @param matchID
   * @param round
   */
  TournamentModel.prototype.addBye = function(byeResultOrTeamID, matchID, //
  round) {
    var i, teamID, byeResult;

    if (arguments.length == 1 && (Type instanceof ByeResult)) {
      byeResult = byeResultOrTeamID;
    } else if (arguments.length == 3 && Type.isNumber(byeResultOrTeamID)
        && Type.isNumber(matchID) && Type.isNumber(round)) {
      teamID = byeResultOrTeamID;
      byeResult = new ByeResult(teamID, [Options.byepointswon,
          Options.byepointslost], matchID, round);
    } else {
      console.error(arguments);
      throw new Error("addBye isn't provided the correct arguments");
    }

    this.votes.bye.push(teamID);
    this.ranking.bye(teamID);
    this.history.push(byeResult);

    return byeResult;
  };

  /**
   * correct a previous result by replacing it with a new result and updating
   * all of the necessary data.
   *
   * @param result
   *          the external result, as read from the getHistory() list
   * @param newScore
   *          the new score. Right now, only scores can be changed. This might
   *          change with the support for more complicated tournament systems
   *
   * @return true on success, false otherwise
   */
  TournamentModel.prototype.correct = function(result, newScore) {
    var index, correction, newResult, baseResult;

    baseResult = result;
    while (baseResult.result !== undefined) {
      if (baseResult.hasReversedTeams) {
        newScore.reverse();
      }
      baseResult = baseResult.result;
    }

    index = this.history.indexOf(baseResult);
    if (index === -1) {
      this.emit('error', 'correct(): result does not exist in history');
      return false;
    }

    newResult = new MatchResult(baseResult, newScore);
    if (!this.validateMatchResult(newResult)) {
      this.emit('error', 'correction has invalid score');
      return false;
    }

    correction = new CorrectionModel(baseResult, newResult);

    if (!this.validateCorrection(correction)) {
      this.emit('error', 'correction is invalid, although the score is fine');
      return false;
    }

    this.ranking.correct(correction);
    this.corrections.push(correction);
    this.history.set(index, correction.after);

    this.postprocessCorrection(correction);

    return true;
  };

  /**
   * prepares a serializable data object, which can later be used for restoring
   * the current state using the restore() function
   *
   * @return a serializable data object, which can be used for restoring
   */
  TournamentModel.prototype.save = function() {
    var data = TournamentModel.superclass.save.call(this);

    data.sys = this.SYSTEM;
    data.id = this.id;
    data.name = this.name.get();
    data.state = this.state.get();
    data.teams = this.teams.asArray();
    data.matches = this.matches.save();
    data.history = this.history.save();
    data.corrections = this.corrections.save();
    data.ranking = this.ranking.save();
    data.votes = {};
    this.VOTES.forEach(function(votetype) {
      data.votes[votetype] = this.votes[votetype].save();
    }, this);

    return data;
  };

  /**
   * restore a previously saved state from a serializable data object
   *
   * @param data
   *          a data object, that was previously written by save()
   * @return true on success, false otherwise
   */
  TournamentModel.prototype.restore = function(data) {
    if (this.SYSTEM !== data.sys) {
      this.emit('error', 'TournamentModel.restore() error: System mismatch');
      return false;
    }

    if (!TournamentModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.id = data.id;

    this.name.set(data.name || this.SYSTEM);

    if (!this.state.forceState(data.state)) {
      this.emit('error',//
      'TournamentModel.restore(): invalid tournament state');
      return false;
    }

    if (!this.teams.restore(data.teams)) {
      this.emit('error',//
      'TournamentModel.restore(): cannot restore teams');
      return false;
    }

    if (!this.matches.restore(data.matches, MatchModel)) {
      this.emit('error', 'TournamentModel.restore(): cannot restore matches');
      return false;
    }

    if (!this.history.restore(data.history, MatchResult)) {
      this.emit('error', 'TournamentModel.restore(): cannot restore history');
      return false;
    }

    if (!this.corrections.restore(data.corrections, CorrectionModel)) {
      this.emit('error',
          'TournamentModel.restore(): cannot restore corrections');
      return false;
    }

    if (!this.ranking.restore(data.ranking)) {
      this.emit('error', 'TournamentModel.restore(): cannot restore ranking');
      return false;
    }

    if (!this.VOTES.every(function(votetype) {
      this.votes[votetype].clear();
      if (data.votes[votetype]) {
        this.votes[votetype].restore(data.votes[votetype]);
      }
      return true;
    }, this)) {
      this.emit('error', 'TournamentModel.restore(): cannot restore votes');
      return false;
    }

    return true;
  };

  /**
   * mimic an IndexedModel
   */
  TournamentModel.prototype.getID = IndexedModel.prototype.getID;
  TournamentModel.prototype.setID = IndexedModel.prototype.setID;

  // TODO use constructor references (MatchModel.SAVEFORMAT) instead of
  // "Object"
  TournamentModel.prototype.SAVEFORMAT = Object
      .create(TournamentModel.superclass.SAVEFORMAT);
  TournamentModel.prototype.SAVEFORMAT.sys = String;
  TournamentModel.prototype.SAVEFORMAT.id = Number;
  TournamentModel.prototype.SAVEFORMAT.name = String;
  TournamentModel.prototype.SAVEFORMAT.state = String;
  TournamentModel.prototype.SAVEFORMAT.teams = [Number];
  TournamentModel.prototype.SAVEFORMAT.matches = [Object];
  TournamentModel.prototype.SAVEFORMAT.history = [Object];
  TournamentModel.prototype.SAVEFORMAT.corrections = [Object];
  TournamentModel.prototype.SAVEFORMAT.ranking = Object;
  TournamentModel.prototype.SAVEFORMAT.votes = Object;

  return TournamentModel;
});

/**
 * a MWC random number generator. Not the best one, but it's sufficient for
 * tournaments. We're not carrying out scientific calculations, after all.
 *
 * @return Random
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/random',[],function() {
  /**
   * constructor
   *
   * @param x
   *          Optional. the value seed. Defaults to a value derived from the
   *          millisecond-exact date
   * @param c
   *          Optional. the initial carry seed. Defaults to a value derived from
   *          the millisecond-exact date, but is guaranteed to differ from x
   */
  var Random = function(x, c) {
    var date;

    if (x !== undefined && c !== undefined) {
      this.x = x;
      this.c = c;
    } else {
      date = new Date();

      this.x = date.getTime() & 0xFFFF;
      this.c = (date.getTime() >> 16) & 0xFFFF;
    }
  };

  /**
   * highest integer number
   */
  Random.prototype.maxInt = 0x10000;

  /**
   * retrieve the next random int value
   *
   * @param top
   *          Optional. Return a value inside [0, top). Defaults to maxInt.
   * @return a random integer inside [0, top), if top is set, or [0, maxInt)
   *         otherwise
   */
  Random.prototype.nextInt = function(top) {
    if (top !== undefined) {
      return Math.floor(this.nextDouble() * top);
    }

    this.x = 65184 * this.x + this.c;
    this.c = this.x >> 16;
    this.x = this.x & 0xFFFF;

    return this.x;
  };

  /**
   * @return a random double value inside [0, 1)
   */
  Random.prototype.nextDouble = function() {
    return this.nextInt() / this.maxInt;
  };

  /**
   * @param array
   *          an array. Function may throw exceptions if array is not an array
   * @return a random element from the array
   */
  Random.prototype.pick = function(array) {
    return array[this.nextInt(array.length)];
  };

  /**
   * pick and remove an element from an array
   *
   * @param array
   *          an array. Function may throw exceptions if array is not an array
   * @return a randomly removed element from the array
   */
  Random.prototype.pickAndRemove = function(array) {
    return array.splice(this.nextInt(array.length), 1)[0];
  };

  return Random;
});

/**
 * Test presets. like boule, but with every possible ranking component.
 *
 * @return Presets
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('presets',['core/rankingcomponentindex'], function(RankingComponentIndex) {
  var Presets;

  Presets = {
    target: 'test',
    systems: {
      swiss: {
        ranking: ['wins', 'buchholz', 'finebuchholz', 'saldo'],
        mode: 'wins'
      },
      ko: {
        mode: 'matched'
      },
      round: {
        ranking: ['wins', 'sonneborn']
      }
    },
    ranking: {
      components: RankingComponentIndex.components
    },
    registration: {
      minteamsize: 1,
      maxteamsize: 3,
      teamsizeicon: true
    },
    names: {
      playernameurl: '',
      dbplayername: 'testplayers',
      apitoken: 'apitoken',
      teamsfile: 'tuvero-anmeldungen.txt'
    }
  };

  return Presets;
});

/**
 * KOTournamentModel
 *
 * @return KOTournamentModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/kotournamentmodel',['lib/extend', './tournamentmodel', 'core/random', './type',
    './matchmodel', './byeresult', 'options', 'presets'], function(extend,
    TournamentModel, Random, Type, MatchModel, ByeResult, Options, Presets) {
  var rng = new Random();

  /**
   * Constructor
   */
  function KOTournamentModel() {
    KOTournamentModel.superconstructor.call(this, ['ko']);

    this.setProperty('komode', (Presets.systems.ko && Presets.systems.ko.mode)
        || KOTournamentModel.MODES.matched);
    this.setProperty('komaxgroup', 1);
    this.setProperty('initialbyes', false);
  }
  extend(KOTournamentModel, TournamentModel);

  KOTournamentModel.prototype.SYSTEM = 'ko';

  KOTournamentModel.MODES = {
    ordered: 'ordered',
    matched: 'matched',
    shuffled: 'shuffled'
  };

  /**
   * create the initial matches for the registered teams
   *
   * @return true on success, false otherwise
   */
  KOTournamentModel.prototype.initialMatches = function() {
    var mode, indices, indexFunction, matchID, roundID, match, teams;

    mode = this.getProperty('komode');
    indexFunction = KOTournamentModel[mode + 'Indices'];
    if (!Type.isFunction(indexFunction)) {
      this.emit('error', 'unknown KO mode: ' + mode);
      return false;
    }

    indices = indexFunction(this.teams.length);

    roundID = KOTournamentModel.initialRoundForTeams(this.teams.length);
    if (roundID < 0) {
      this.emit('error', 'not enough players for KO tournament');
      return false;
    }
    matchID = KOTournamentModel.firstMatchIDOfRound(roundID);

    this.createPlaceholderMatches();

    while (indices.length > 0) {
      teams = indices.splice(0, 2);

      if (teams[1] === undefined) {
        match = new ByeResult(teams[0], [Options.byepointswon,
            Options.byepointslost], matchID, 0);
        this.checkForFollowupMatches(match);
        if (this.getProperty('initialbyes')) {
          this.history.push(match);
        }
      } else {
        match = new MatchModel(teams, matchID, 0);
        this.matches.push(match);
      }

      matchID += 1;
    }

    return true;
  };

  /**
   * should never be called since KO tournaments can't be idle, only finished
   */
  KOTournamentModel.prototype.idleMatches = function() {
    throw new Error('KO Tournaments cannot be in idle state.'
        + ' This function can never be called by the TournamentModel.');
  };

  /**
   * create subsequent matches in the KO tree
   *
   * @param matchresult
   */
  KOTournamentModel.prototype.postprocessMatch = function(matchresult) {
    this.checkForFollowupMatches(matchresult);

    if (this.matches.length === 0) {
      this.state.set('finished');
    }
  };

  /**
   * search the current matches for the required match
   *
   * @param group
   *          the match group
   * @param id
   *          the match id
   * @return the match (MatchModel) on success, undefined otherwise
   */
  KOTournamentModel.prototype.findMatch = function(group, id) {
    var index, match;

    for (index = 0; index < this.matches.length; index += 1) {
      match = this.matches.get(index);

      if (match.getID() === id && match.getGroup() === group) {
        return match;
      }
    }

    return undefined;
  };

  /**
   * find a match in the history
   *
   * @param group
   *          the match group
   * @param id
   *          the match id
   * @return the match on success (MatchResult or ByeResult), undefined
   *         otherwise
   */
  KOTournamentModel.prototype.findMatchInHistory = function(group, id) {
    var index, match;

    for (index = 0; index < this.history.length; index += 1) {
      match = this.history.get(index);

      if (match.getID() === id && match.getGroup() === group) {
        return match;
      }
    }

    return undefined;
  };

  /**
   * create all placeholder matches
   */
  KOTournamentModel.prototype.createPlaceholderMatches = function() {
    var groups, groupMatchIDLimit, id, maxgroup, existingMatches;

    maxgroup = Math.min(this.getProperty('komaxgroup'),
        (this.teams.length - 1) / 2);

    groups = [];
    while (groups.length <= maxgroup) {
      groups.push(groups.length);
    }

    groupMatchIDLimit = groups.map(function(group) {
      return KOTournamentModel.firstMatchIDOfRound(KOTournamentModel
          .roundsInGroup(group));
    });

    existingMatches = groups.map(function() {
      return [];
    });

    this.matches.map(function(match) {
      existingMatches[match.getGroup()][match.getID()] = match;
    });

    this.history.map(function(match) {
      existingMatches[match.getGroup()][match.getID()] = match;
    });

    id = KOTournamentModel.firstMatchIDOfRound(KOTournamentModel
        .initialRoundForTeams(this.teams.length)) - 1;
    for (; id > 0; id -= 1) {
      groupMatchIDLimit.forEach(function(matchIDLimit, group) {
        if (id < matchIDLimit && existingMatches[group][id] === undefined) {
          this.matches.push(new MatchModel([undefined, undefined], id, group));
        }
      }, this);
    }
  };

  /**
   * looks for missing "waiting" matches, i.e. matches in which one team waits
   * for another team to finish a match in the previous round. This is intended
   * to be used for repairs only.
   */
  KOTournamentModel.prototype.createWaitingMatches = function() {
    var teamMatches, lastresults;

    teamMatches = this.teams.map(function() {
      return undefined;
    });

    this.matches.map(function(match) {
      match.teams.forEach(function(teamID) {
        teamMatches[teamID] = match;
      });
    });

    lastresults = [];

    teamMatches.forEach(function(team, teamid) {
      var lastHistoryResult = undefined;

      if (team === undefined) {
        this.history.map(function(result) {
          if (result.teams.indexOf(teamid) !== -1) {
            if (lastHistoryResult === undefined
                || lastHistoryResult.getID() < result.getID()) {
              lastHistoryResult = result;
            }
          }
        });

        if (lastresults.indexOf(lastHistoryResult) === -1) {
          lastresults.push(lastHistoryResult);
        }
      }
    }, this);

    lastresults.forEach(function(result) {
      this.checkForFollowupMatches(result);
    }, this);
  };

  /**
   * after a match has been finished or a bye has been issued, this function
   * checks for possible subsequent matches and create them
   *
   * @param result
   *          a MatchResult (or MatchModel or ByeResult)
   */
  KOTournamentModel.prototype.checkForFollowupMatches = function(result) {
    var currentMatchID, nextMatchID, winnergroup, losergroup, winner, loser;

    currentMatchID = result.getID();
    if (currentMatchID === 0) {
      // don't advance beyond the finale
      return;
    }

    // calculate the IDs
    nextMatchID = KOTournamentModel.nextRoundMatchID(currentMatchID);
    winnergroup = result.getGroup();
    losergroup = KOTournamentModel.loserGroupID(winnergroup, currentMatchID);

    // get winners
    if (result.isBye()) {
      winner = result.getTeamID(0);
      loser = undefined;
    } else {
      if (result.score[0] < result.score[1]) {
        winner = result.getTeamID(1);
        loser = result.getTeamID(0);
      } else {
        winner = result.getTeamID(0);
        loser = result.getTeamID(1);
      }
    }

    // create matches
    this.createFollowupMatch(winner, nextMatchID, winnergroup, result);
    this.createFollowupMatch(loser, nextMatchID, losergroup, result);
  };

  /**
   * create a followup match, i.e. a match to which a team from a previous match
   * is assigned
   *
   * @param teamID
   *          the ID of the team which advanced to this round
   * @param nextMatchID
   *          the ID of the next match
   * @param nextGroupID
   *          the group of the next match
   * @param currentMatch
   *          the current match, which has just ended
   */
  KOTournamentModel.prototype.createFollowupMatch = function(teamID,
      nextMatchID, nextGroupID, currentMatch) {
    var opponent, match, complementaryMatchID, currentMatchID, currentGroupID;

    currentMatchID = currentMatch.getID();
    currentGroupID = currentMatch.getGroup();

    if (currentMatchID <= 1) {
      return;
    }

    if (nextGroupID > this.getProperty('komaxgroup')) {
      return;
    }

    if (teamID !== undefined) {
      match = this.findMatch(nextGroupID, nextMatchID);

      if (match) {
        if (match.isRunningMatch()) {
          console.warn('trying to overwrite existing match!');
        } else {
          opponent = match.getTeamID(0);
          if (opponent === undefined) {
            opponent = match.getTeamID(1);
          }
          this.matches.remove(this.matches.indexOf(match));
          teams = [teamID, opponent];
          if (KOTournamentModel.isSecondInNextRound(currentMatchID)) {
            teams.reverse();
          }
          match = new MatchModel(teams, nextMatchID, nextGroupID);
          this.matches.push(match);
          // if (opponent === undefined && nextMatchID !== 0) {
          // this.checkForFollowupMatches(match);
          // }
        }
      } else {
        complementaryMatchID = KOTournamentModel
            .complementaryMatchID(currentMatchID);
        complementaryMatchGroup = currentGroupID;

        match = this.findMatch(currentGroupID, complementaryMatchID);
        if (!match) {
          match = this.findMatchInHistory(currentGroupID, //
          complementaryMatchID);
        }

        if ((match && match.isResult() && match.isBye())) {
          match = this.addBye(teamID, nextMatchID, nextGroupID);
          this.checkForFollowupMatches(match);
        } else if (match.getTeamID(0) === undefined
            && match.getTeamID(1) === undefined) {
          match = new MatchModel([teamID, undefined], nextMatchID, //
          nextGroupID);
          this.matches.push(match);
        }
      }
    }
  };

  /**
   * @param length
   *          the number of teams
   * @return an array of team indices for a matched tournament
   */
  KOTournamentModel.matchedIndices = function(length) {
    var indices, index, value, length2;

    if (length === 1) {
      indices = [0];
    } else if (length > 1) {
      length2 = KOTournamentModel.ceilPowerOfTwo(length);
      indices = KOTournamentModel.matchedIndices(length2 >> 1);

      for (index = indices.length - 1; index >= 0; index -= 1) {
        value = indices[index];
        value = length2 - value - 1;
        if (value >= length) {
          value = undefined;
        }
        indices.splice(index + 1, 0, value);
      }
    } else {
      indices = [];
    }

    return indices;
  };

  /**
   * @param length
   *          the number of teams
   * @return an array of teamIDs and 'undefined' values which give a matching
   *         for the init function
   */
  KOTournamentModel.orderedIndices = function(length) {
    var indices, length2, index;

    length2 = KOTournamentModel.ceilPowerOfTwo(length);

    indices = [];
    while (indices.length < length) {
      indices.push(indices.length);
    }

    for (index = indices.length; indices.length < length2; index -= 1) {
      indices.splice(index, 0, undefined);
    }

    return indices;
  };

  /**
   *
   * @param length
   *          the number of teams
   * @return an array of teamIDs and placeholders for the initial set of ko
   *         matches
   */
  KOTournamentModel.shuffledIndices = function(length) {
    var indices, length2, index, teamids;

    length2 = KOTournamentModel.ceilPowerOfTwo(length);

    teamids = [];
    while (teamids.length < length) {
      teamids.push(teamids.length);
    }

    indices = [];
    while (teamids.length > 0) {
      indices.push(rng.pickAndRemove(teamids));
    }

    for (index = indices.length; indices.length < length2; index -= 1) {
      indices.splice(index, 0, undefined);
    }

    return indices;
  };

  /**
   * @param number
   * @return the ceiling-rounded number, to the power of two
   */
  KOTournamentModel.ceilPowerOfTwo = function(number) {
    return 1 << Math.ceil(Math.log(number) / Math.LN2);
  };

  /**
   * @param currentMatchID
   *          match ID
   * @return the next match ID the teams will play
   */
  KOTournamentModel.nextRoundMatchID = function(currentMatchID) {
    return currentMatchID >> 1;
  };

  /**
   * @param matchID
   *          the match ID
   * @return true if the teams of this match will be the second player of their
   *         next match, false otherwise
   */
  KOTournamentModel.isSecondInNextRound = function(matchID) {
    return matchID % 2 === 1 && matchID !== 1;
  };

  /**
   * @param matchID
   *          a match ID
   * @return the ID of the match from which the next opponents are drawn
   */
  KOTournamentModel.complementaryMatchID = function(matchID) {
    return matchID ^ 0x1;
  };

  /**
   * @param round
   *          the round ID
   * @return the ID of the first match in the round
   */
  KOTournamentModel.firstMatchIDOfRound = function(round) {
    return 1 << round;
  };

  /**
   * @param round
   *          the round ID
   * @return the number of matches in this round
   */
  // coincidentally, the two functions are the same
  KOTournamentModel.numMatchesInRound = KOTournamentModel.firstMatchIDOfRound;

  /**
   * @param matchID
   * @return the round of this match
   */
  KOTournamentModel.roundOfMatchID = function(matchID) {
    if (matchID <= 0) {
      matchID = 1;
    }
    return Math.floor(Math.log(matchID) / Math.LN2);
  };

  /**
   * @param groupID
   *          the current group ID
   * @param lostMatchID
   *          the ID of the just lost match
   * @return the next group ID
   */
  KOTournamentModel.loserGroupID = function(groupID, lostMatchID) {
    var round = KOTournamentModel.roundOfMatchID(lostMatchID);
    if (round === 0) {
      return groupID;
    }
    return groupID + (1 << (round - 1));
  };

  /**
   * @param group
   *          a group ID
   * @return the parent group ID, i.e. where the matches come from
   */
  KOTournamentModel.parentGroup = function(group) {
    if (group === 0) {
      return 0;
    }

    return group - (1 << (KOTournamentModel.roundsInGroup(group) - 1));
  };

  /**
   * @param numTeams
   *          number of Teams
   * @return the initial round ID for the given number of teams
   */
  KOTournamentModel.initialRoundForTeams = function(numTeams) {
    if (numTeams <= 0) {
      numTeams = 1;
    }
    return Math.ceil(Math.log(numTeams) / Math.LN2) - 1;
  };

  /**
   * @param group
   *          the id of the group
   * @return the number of rounds which are played exclusively in this group
   */
  KOTournamentModel.roundsInGroup = function(group) {
    var rounds;

    if (group === 0) {
      return 30;
    }

    for (rounds = 0; rounds < 30; rounds += 1) {
      if ((group & (1 << rounds)) !== 0) {
        break;
      }
    }

    return rounds + 1;
  };

  return KOTournamentModel;
});

/**
 * LengthModel: binds to a ListModel instance and always evaluates to its length
 *
 * @return LengthModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/lengthmodel',['lib/extend', './valuemodel'], function(extend, ValueModel) {
  /**
   * Constructor
   *
   * @param list
   *          a ListModel instance
   */
  function LengthModel(list) {
    LengthModel.superconstructor.call(this, list.length);

    list.registerListener(this);
  }
  extend(LengthModel, ValueModel);

  /**
   * callback listener
   *
   * @param list
   *          the emitter, i.e. the ListModel instance
   */
  LengthModel.prototype.onresize = function(list) {
    LengthModel.superclass.set.call(this, list.length);
  };

  /**
   * disable the set() function. This is a passive ValueModel
   */
  LengthModel.prototype.set = undefined;

  return LengthModel;
});

/**
 * ListExclusionListener: Strange name, but it's supposed to listen for a
 * boolean ValueModel instance and push an element to a list if its value
 * evaluates to true, and remove it otherwise.
 *
 * TODO find a better name
 *
 * @return ListExclusionListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/listexclusionlistener',['lib/extend', './listener'], function(extend, Listener) {
  /**
   * Constructor
   *
   * @param trigger
   *          the ValueModel instance to listen to
   * @param list
   *          the list to add to/remove from
   * @param value
   *          the value to add/remove
   */
  function ListExclusionListener(trigger, list, value) {
    ListExclusionListener.superconstructor.call(this, trigger);

    this.trigger = trigger;
    this.list = list;
    this.value = value;
  }
  extend(ListExclusionListener, Listener);

  /**
   * push the value, if it's not in the list already
   */
  ListExclusionListener.prototype.add = function() {
    var index;

    index = this.list.indexOf(this.value);

    if (index === -1) {
      this.list.push(this.value);
    }
  };

  /**
   * remove all appearances of the value from the list
   */
  ListExclusionListener.prototype.remove = function() {
    var index;

    while ((index = this.list.indexOf(this.value)) !== -1) {
      this.list.remove(index);
    }
  };

  /**
   * Callback listener for the trigger. Call add()/remove() accordingly
   */
  ListExclusionListener.prototype.onupdate = function() {
    if (this.trigger.get()) {
      this.add();
    } else {
      this.remove();
    }
  };

  return ListExclusionListener;
});

/**
 * OrderListModel: a ListModel, for which an order can be enforced. This was
 * first introduced to convert RankingModel.get().displayOrder into a ListModel
 * of TeamIDs for later visualization, hence the name "OrderListModel".
 *
 * The promise is to enforce ordered lists while minimizing insert/remove
 * operations
 *
 * @return OrderListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/orderlistmodel',['lib/extend', './listmodel', 'lib/diff'], function(extend, ListModel,
    diff) {

  /**
   * get a diffresult of two integer arrays
   *
   * @param a
   *          the first array of integers
   * @param b
   *          the second array of integers
   * @return a diffresult array, where each element contains a value, removed and
   *          added property. The value property is an array of numbers, while
   *          the removed/added properties are true if the values need to be
   *          removed/added
   */
  function getdiff(a, b) {
    var diffresult;
    a = a.join('\n');
    if (a.length > 0) {
      a += '\n';
    }
    b = b.join('\n');
    if (b.length > 0) {
      b += '\n';
    }
    diffresult = diff.diffLines(a, b);
    diffresult.forEach(function(lines) {
      lines.value = lines.value.replace(/\n$/, '').split('\n').map(Number);
    });
    return diffresult;
  }

  /**
   * Constructor
   */
  function OrderListModel() {
    OrderListModel.superconstructor.call(this);
    this.makeReadonly();
  }
  extend(OrderListModel, ListModel);

  /**
   * insert/remove elements to match the given order. Use as few
   * insertions/removals as possible
   *
   * @param order
   *          The wanted end result
   */
  OrderListModel.prototype.enforceOrder = function(order) {
    var index, diffresult;

    diffresult = getdiff(this.list, order);

    index = 0;
    diffresult.forEach(function(lines) {
      lines.value.forEach(function(value) {
        if (lines.added) {
          OrderListModel.superclass.insert.call(this, index, value);
        } else if (lines.removed) {
          OrderListModel.superclass.remove.call(this, index);
          index -= 1;
        }
        index += 1;
      }, this);
    }, this);
  };

  return OrderListModel;
});

/**
 * PositiveMatrix: return only positive values
 *
 * @return PositiveMatrix
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/positivematrix',['lib/extend', './delegatematrix'], function(extend, DelegateMatrix) {
  /**
   * Constructor
   * @param matrix the matrix to bind itself to
   */
  function PositiveMatrix(matrix) {
    PositiveMatrix.superconstructor.call(this, matrix);
  }
  extend(PositiveMatrix, DelegateMatrix);

  /**
   * return only positive values
   *
   * @param row
   *          the row
   * @param col
   *          the column
   * @return 0 if the actual value is negative, the value otherwise. undefined
   *          on error
   */
  PositiveMatrix.prototype.get = function(row, col) {
    var value = this.superget(row, col);
    if (value < 0) {
      return 0;
    }
    return value;
  };

  return PositiveMatrix;
});

/**
 * PropertyValueModel
 *
 * @return PropertyValueModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/propertyvaluemodel',['lib/extend', './valuemodel', './listener'], function(extend,
    ValueModel, Listener) {
  /**
   * Constructor
   *
   * @param model
   *          a PropertyModel instance
   * @param prop
   *          the name of the property
   */
  function PropertyValueModel(model, prop) {
    PropertyValueModel.superconstructor.call(this, model.getProperty(prop));

    this.prop = prop;

    model.registerListener(this);

    Listener.bind(this, 'update', function() {
      model.setProperty(prop, this.get());
    }, this);
  }
  extend(PropertyValueModel, ValueModel);

  PropertyValueModel.prototype.onupdate = function(emitter, event, data) {
    if (data.key === this.prop) {
      this.set(data.value);
    }
  };

  return PropertyValueModel;
});

/**
 * RoundTournamentModel
 *
 * @return RoundTournamentModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/roundtournamentmodel',['lib/extend', './tournamentmodel', './matchmodel', './byeresult',
    'options', './type'], function(extend, TournamentModel, MatchModel,
    ByeResult, Options, Type) {
  /**
   * Constructor
   *
   * @param rankingorder
   *          the order of the ranking
   */
  function RoundTournamentModel(rankingorder) {
    RoundTournamentModel.superconstructor.call(this, rankingorder);
    this.round = -1;
  }
  extend(RoundTournamentModel, TournamentModel);

  RoundTournamentModel.prototype.SYSTEM = 'round';

  /**
   * create all matches during the initial->running transition
   *
   * @return true on success, false otherwise
   */
  RoundTournamentModel.prototype.initialMatches = function() {
    this.round = 0;

    if (this.teams.length < 2) {
      return false;
    }

    RoundTournamentModel.generateSlideSystemMatches.call(this);

    return true;
  };

  /**
   * create all matches during the idle->running transition
   *
   * @return true on success, false otherwise
   */
  RoundTournamentModel.prototype.idleMatches = function() {
    this.round += 1;

    RoundTournamentModel.generateSlideSystemMatches.call(this);

    return true;
  };

  /**
   * use the slide system to generate a roundtournament. "this" is required to
   * be a RoundTournamentModel instance.
   */
  RoundTournamentModel.generateSlideSystemMatches = function() {
    var slideList, teamA, teamB, id;

    slideList = RoundTournamentModel.generateSlideList(this.teams.length,
        this.round);

    if (slideList.length % 2) {
      // TODO use a function to auto-create all bye conditions. DRY principle.
      if (this.round == slideList.length - 1) {
        teamB = slideList.shift();
      } else {
        teamB = slideList.pop();
      }
      id = slideList.length >> 1;

      this.addBye(teamB, id, this.round);
    }

    id = 0;

    while (slideList.length > 1) {
      teamA = slideList.shift();
      teamB = slideList.pop();

      this.matches.push(new MatchModel([teamA, teamB], id, this.round));

      id += 1;
    }
  };

  /**
   * @param numteams
   *          the number of teams
   * @param round
   *          the round, starting with 0.
   * @return an array of teams in a clockwise slide order, starting with the
   *         first team. Undefined on error.
   */
  RoundTournamentModel.generateSlideList = function(numteams, round) {
    var teams, slideteam;

    if (!Type.isNumber(numteams) || !Type.isNumber(round)) {
      return undefined;
    }

    if (round <= 0) {
      teams = [];
      while (teams.length < numteams) {
        teams.push(teams.length);
      }
      return teams;
    }

    teams = RoundTournamentModel.generateSlideList(numteams, round - 1);

    slideteam = teams.splice(numteams - 1, 1)[0];
    teams.splice(1, 0, slideteam);

    return teams;
  };

  /**
   *
   * @param matchresult
   *          Ignored.
   */
  RoundTournamentModel.prototype.postprocessMatch = function(matchresult) {
    if (this.matches.length === 0) {
      if (this.round === this.numRounds() - 1) {
        this.state.set('finished');
      }
    }
  };

  /**
   * @return the current or recently finished round. returns -1 if the
   *         tournament hasn't been started yet
   */
  RoundTournamentModel.prototype.getRound = function() {
    return this.round;
  };

  /**
   * @return the total number of rounds.
   */
  RoundTournamentModel.prototype.numRounds = function() {
    if (this.teams.length % 2) {
      // tournaments with odd teams take one round longer due to the byes
      return this.teams.length;
    }
    return this.teams.length - 1;
  };

  /**
   * write the round to the data object
   *
   * @return a serializable data object
   */
  RoundTournamentModel.prototype.save = function() {
    var data = RoundTournamentModel.superclass.save.call(this);
    data.round = this.round;
    return data;
  };

  /**
   * restore the state form a data object, including this.round
   *
   * @param data
   *          a deserialized data object
   * @return true on success, false otherwise
   */
  RoundTournamentModel.prototype.restore = function(data) {
    if (!RoundTournamentModel.superclass.restore.call(this, data)) {
      return false;
    }
    this.round = data.round;
    return true;
  };

  /**
   * add "round" to the data object
   */
  RoundTournamentModel.prototype.SAVEFORMAT = Object
      .create(RoundTournamentModel.superclass.SAVEFORMAT);
  RoundTournamentModel.prototype.SAVEFORMAT.round = Number;

  return RoundTournamentModel;
});

/**
 * SwissTournamentModel
 *
 * @return SwissTournamentModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/swisstournamentmodel',['lib/extend', './roundtournamentmodel', 'core/random', './matchmodel',
    './byeresult', 'options', 'presets'], function(extend,
    RoundTournamentModel, Random, MatchModel, ByeResult, Options, Presets) {
  var rng = new Random();
  /**
   * Constructor
   *
   * @param rankingorder
   */
  function SwissTournamentModel(rankingorder) {
    SwissTournamentModel.superconstructor.call(this, rankingorder);

    this.setProperty('swissmode',
        (Presets.systems.swiss && Presets.systems.swiss.mode)
            || SwissTournamentModel.MODES.ranks);
    this.setProperty('swissshuffle', true);
    this.setProperty('swisstranspose', false);

    this.setProperty('byeafterbye', false);
    this.setProperty('byeafterup', true);
    this.setProperty('byeafterdown', true);

    this.setProperty('upafterbye', true);
    this.setProperty('upafterup', false);
    this.setProperty('upafterdown', true);

    this.setProperty('downafterbye', true);
    this.setProperty('downafterup', true);
    this.setProperty('downafterdown', false);

    this.setProperty('enableupdown', this.getProperty('swissmode') === 'wins');
  }
  extend(SwissTournamentModel, RoundTournamentModel);

  SwissTournamentModel.prototype.SYSTEM = 'swiss';

  SwissTournamentModel.prototype.RANKINGDEPENDENCIES = ['votes', 'gamematrix'];

  /**
   * an array of required vote lists
   */
  SwissTournamentModel.prototype.VOTES = ['bye', 'up', 'down'];

  SwissTournamentModel.MODES = {
    all: 'all',
    halves: 'halves',
    ranks: 'ranks',
    wins: 'wins',
    individual: 'individual',
    // TODO enable the use of global team ids (rangliste, elo, ...)
    globalteamid: undefined
  };

  /**
   * creates new matches depending on the current ranking within the tournament
   *
   * @return true on success, false otherwise
   */
  SwissTournamentModel.prototype.idleMatches = function() {
    var rankGroups, matches, votes, mode;

    /*
     * validate swiss mode
     */
    mode = this.getProperty('swissmode');

    if (SwissTournamentModel.MODES[mode] === undefined) {
      this.emit('error', 'invalid mode: ' + mode);
      return false;
    }

    rankGroups = SwissTournamentModel.getGroups(this.ranking.get(), mode);

    /*
     * shuffle if wanted
     */
    if (this.getProperty('swissshuffle') === true) {
      rankGroups = SwissTournamentModel.shuffleGroupTeams(rankGroups);
    }

    /*
     * transpose if wanted
     */
    if (this.getProperty('swisstranspose') === true) {
      rankGroups = SwissTournamentModel.transposeGroups(rankGroups);
    }

    /*
     * use awesome algorithm to find an allowed solution
     */
    matches = [];
    votes = {};
    if (!this.findSwissByesAndMatches(matches, votes, rankGroups)) {
      this.emit('error', 'cannot find unique byes and matches');
      return false;
    }

    /*
     * advance the round index
     */
    this.round += 1;

    votes.ups.forEach(function(upTeamID) {
      this.votes.up.push(upTeamID);
      this.ranking.upvotes
          .set(upTeamID, this.ranking.upvotes.get(upTeamID) + 1);
    }, this);

    votes.downs.forEach(function(upTeamID) {
      this.votes.down.push(upTeamID);
      this.ranking.downvotes.set(upTeamID,
          this.ranking.downvotes.get(upTeamID) + 1);
    }, this);

    /*
     * add the byes and matches to the current tournament
     */
    votes.byes.forEach(function(byeTeamID, byeIndex) {
      this.addBye(byeTeamID, matches.length + byeIndex, this.round);
    }, this);

    matches.forEach(function(matchTeams, matchid) {
      this.matches.push(new MatchModel(matchTeams, matchid, this.round));
    }, this);

    this.ranking.invalidate();

    return true;
  };

  /**
   * creates new matches depending on the initial within the tournament
   *
   * @return true on success, false otherwise
   */
  SwissTournamentModel.prototype.initialMatches = function() {
    this.correctWinGroupRankingOrder();
    return this.idleMatches();
  };

  SwissTournamentModel.prototype.correctWinGroupRankingOrder = function() {
    var components, windex;

    components = this.ranking.componentnames;

    if (this.getProperty('swissmode') === 'wins' && components[0] != 'wins') {
      windex = components.indexOf('wins');

      if (windex !== -1) {
        components.splice(windex, 1);
      }

      components.unshift('wins');

      this.setRankingOrder(components);
    }
  };

  /**
   * Internal function.
   *
   * Transposes the groups: takes one element from each group and places them
   * into a new group, in order.
   *
   * shuffle first, if you need to.
   *
   * @param groups
   *          2d groups array
   * @return a 2d groups array where the groups are transposed
   */
  SwissTournamentModel.transposeGroups = function(groups) {
    var transposed = [];

    groups.forEach(function(group) {
      group.forEach(function(teamid, index) {
        if (transposed[index] === undefined) {
          transposed[index] = [];
        }
        transposed[index].push(teamid);
      });
    });

    return transposed;
  };

  /**
   * Internal Function. creates a 2d array of groups for match creation
   *
   * @param ranking
   *          a RankingModel instance
   * @param mode
   *          one of the SwissTournamentModel.MODES
   * @return an array of arrays, where the inner array contains team ids which
   *         have the same rank, and outer array is ordered from best to worst
   *         rank
   */
  SwissTournamentModel.getGroups = function(ranking, mode) {
    var allGroups, currentGroup, lastID, getID;

    /*
     * build different getIDs for different models
     */
    getID = undefined;
    switch (mode) {
    case SwissTournamentModel.MODES.all:
      getID = function(rankingid) {
        return 0;
      };
      break;
    case SwissTournamentModel.MODES.halves:
      getID = function(rankingid) {
        return rankingid < (ranking.displayOrder.length >> 1);
      };
      break;
    case SwissTournamentModel.MODES.wins:
      getID = function(rankingid) {
        return ranking.wins[ranking.displayOrder[rankingid]];
      };
      break;
    case SwissTournamentModel.MODES.ranks:
      getID = function(rankingid) {
        return ranking.ranks[rankingid];
      };
      break;
    case SwissTournamentModel.MODES.individual:
      getID = function(rankingid) {
        return rankingid;
      };
      break;
    default:
      console.error('invalid mode');
      return undefined;
    }

    currentGroup = [];
    allGroups = [currentGroup];
    lastID = undefined;

    ranking.displayOrder.forEach(function(teamid, rankingid) {
      var id = getID(rankingid);
      if (id !== lastID) {
        lastID = id;
        if (currentGroup && currentGroup.length) {
          currentGroup = [];
          allGroups.push(currentGroup);
        }
      }
      currentGroup.push(teamid);
    });

    return allGroups;
  };

  /**
   * Internal Function
   *
   * in every rank group, randomize the team order
   *
   * @param rankGroups
   *          a getGroups() result
   * @return a rankGroup 2d array where the order of the inner arrays is random
   */
  SwissTournamentModel.shuffleGroupTeams = function(rankGroups) {
    return rankGroups.map(function(group) {
      var newgroup;
      newgroup = [];

      while (group.length) {
        newgroup.push(rng.pickAndRemove(group));
      }

      return newgroup;
    });
  };

  /**
   * Internal Function.
   *
   * Find a valid bye if necessary, and a valid match for every team in the
   * rankGroups list
   *
   * @param outMatches
   *          an array into which the matches are written (int[][2])
   * @param outVotes
   *          an empty object. The vote output arrays are written here
   * @param rankGroups
   *          a 2d groups array
   * @return true on success, false otherwise
   */
  SwissTournamentModel.prototype.findSwissByesAndMatches = function(outMatches,
      outVotes, rankGroups) {
    var reverseRankGroups;

    outVotes.byes = [];
    outVotes.ups = [];
    outVotes.downs = [];

    if (SwissTournamentModel.getGroupsTeamCount(rankGroups) % 2) {
      reverseRankGroups = rankGroups.slice(0).reverse();

      if (!reverseRankGroups.some(function(group) {
        return group.slice(0).reverse().some(function(teamid) {
          var index;
          if (!this.canGetBye(teamid)) {
            return false;
          }

          index = group.indexOf(teamid);
          group.splice(index, 1);

          if (this.prefilterSwissMatches(rankGroups)) {
            if (this.findSwissMatches(outMatches, outVotes, rankGroups)) {
              outVotes.byes.push(teamid);
              return true;
            }
          }

          group.splice(index, 0, teamid);

          return false;
        }, this);
      }, this)) {
        return false;
      }
    }

    if (this.findSwissMatches(outMatches, outVotes, rankGroups)) {
      return true;
    }

    return false;
  };

  /**
   * counts the number of teams remaining in the rank groups
   *
   * @param rankGroups
   *          a rankGroups object, as returned by getGroups
   * @return the number of teams in the rank group
   */
  SwissTournamentModel.getGroupsTeamCount = function(rankGroups) {
    var sum = 0;

    rankGroups.forEach(function(group) {
      sum += group.length;
    });

    return sum;
  };

  /**
   * quick-check whether the up/downvotes can be applied. This is not a complete
   * test, it just checks for obvious errors (are there any upvotes/downvotes in
   * the group?)
   *
   * @param rankGroups
   *          a 2D array of rank groups
   * @return true if there's no obvious error, false otherwise
   */
  SwissTournamentModel.prototype.prefilterSwissMatches = function(rankGroups) {
    var downvote = false;

    // verify up/downvotes
    if (this.getProperty('enableupdown')) {
      if (!rankGroups.every(function(group) {
        var teams = group.length;
        if (downvote) {
          // upvote required
          if (!group.some(this.canGetUpvote.bind(this))) {
            return false;
          }

          downvote = false;
          teams -= 1;
        }

        if (teams % 2 != 0) {
          // downvote required
          if (!group.some(this.canGetDownvote.bind(this))) {
            return false;
          }
          downvote = true;
        }

        return true;
      }, this)) {
        return false;
      }
    }

    return true;
  };

  /**
   * @param outMatches
   *          Output. An array into which the matches are written.
   * @param outVotes
   *          Output. A pre-initialized object of arrays into which the votes
   *          are written for output.
   * @param rankGroups
   *          The rank groups.
   * @return true on success, false otherwise
   */
  SwissTournamentModel.prototype.findSwissMatches = function(outMatches,
      outVotes, rankGroups) {
    var currentGroup, teamA, teamB, updown;

    // console.log(getGroupsTeamCount(rankGroups));
    // console.log(JSON.stringify(rankGroups));

    currentGroup = undefined;

    // get firstGroupIndex by searching for the first non-empty group
    if (!rankGroups.some(function(group) {
      currentGroup = group;
      return group.length > 0;
    })) {
      // success! there's no team left
      return true;
    }

    // verify eventual downvote
    if (currentGroup.length == 1 && this.getProperty('enableupdown')) {
      if (!this.canGetDownvote(currentGroup[0])) {
        return false;
      }
    }

    teamA = currentGroup.shift();
    teamB = undefined;
    updown = false; // whether the next non-empty group has already been tried

    // try to find a match in any subsequent group, or just this or the one
    // after.
    if (rankGroups.some(function(group) {
      if (group.length === 0) {
        return false;
      }

      if (this.getProperty('enableupdown')) {
        if (updown) {
          return false;
        }

        if (group !== currentGroup) {
          updown = true;
        }
      }

      return group.some(function(team, index) {
        var secondGroup, teamBindex;

        if (this.canPlayMatch(teamA, team, updown)) {
          secondGroup = group;
          teamB = team;
          teamBindex = index;

          if (updown) {
            outVotes.downs.push(teamA);
            outVotes.ups.push(teamB);
          }
          secondGroup.splice(teamBindex, 1);

          if (this.findSwissMatches(outMatches, outVotes, rankGroups)) {
            return true;
          }

          secondGroup.splice(teamBindex, 0, teamB);
          if (updown) {
            outVotes.downs.pop();
            outVotes.ups.pop();
          }
        }
        return false;
      }, this);
    }, this)) {
      // don't use push, because the best-ranked team should be listed in
      // the first match
      outMatches.unshift([teamA, teamB]);
      return true;
    }

    currentGroup.unshift(teamA);

    return false;
  };

  /**
   * @param teamid
   *          the id of the team
   * @return true if the team already has a bye
   */
  SwissTournamentModel.prototype.hasBye = function(teamid) {
    return this.ranking.byes.get(teamid) != 0;
  };

  /**
   * @param teamid
   *          the id of the team
   * @return true if the team already has an upvote
   */
  SwissTournamentModel.prototype.hasUpvote = function(teamid) {
    return this.ranking.upvotes.get(teamid) != 0;
  };

  /**
   * @param teamid
   *          the id of the team
   * @return true if the team already has a downvote
   */
  SwissTournamentModel.prototype.hasDownvote = function(teamid) {
    return this.ranking.downvotes.get(teamid) != 0;
  };

  /**
   * checks all conditions and returns true if a bye can be issued
   *
   * @param teamid
   *          the prospective team id
   * @return true if the bye would be valid, false otherwise
   */
  SwissTournamentModel.prototype.canGetBye = function(teamid) {
    if (!this.getProperty('byeafterbye') && this.hasBye(teamid)) {
      return false;
    }

    if (!this.getProperty('byeafterup') && this.hasUpvote(teamid)) {
      return false;
    }

    if (!this.getProperty('byeafterdown') && this.hasDownvote(teamid)) {
      return false;
    }

    return true;
  };

  /**
   * checks all upvote conditions and returns true if an upvote is allowed
   *
   * @param teamid
   *          the prospective team id
   * @return true if the upvote is allowed, false otherwise
   */
  SwissTournamentModel.prototype.canGetUpvote = function(teamid) {
    if (!this.getProperty('upafterup') && this.hasUpvote(teamid)) {
      return false;
    }

    if (!this.getProperty('upafterbye') && this.hasBye(teamid)) {
      return false;
    }

    if (!this.getProperty('upafterdown') && this.hasDownvote(teamid)) {
      return false;
    }

    return true;
  };

  /**
   * checks all downvote conditions and returns true if a downvote is allowed
   *
   * @param teamid
   *          the prospective team id
   * @return true if the downvote is allowed, false otherwise
   */
  SwissTournamentModel.prototype.canGetDownvote = function(teamid) {
    if (!this.getProperty('downafterdown') && this.hasDownvote(teamid)) {
      return false;
    }

    if (!this.getProperty('downafterbye') && this.hasBye(teamid)) {
      return false;
    }

    if (!this.getProperty('downafterup') && this.hasUpvote(teamid)) {
      return false;
    }

    return true;
  };

  /**
   * @param teamA
   *          index of team A
   * @param teamB
   *          index of team B
   * @param updown
   *          if true, teamA is checked for downvotes and teamB for downvotes
   * @return true if they can play a match, false otherwise
   */
  SwissTournamentModel.prototype.canPlayMatch = function(teamA, teamB, updown) {
    if (this.ranking.gamematrix.get(teamA, teamB) !== 0) {
      return false;
    }

    if (updown) {
      if (!this.canGetDownvote(teamA) || !this.canGetUpvote(teamB)) {
        return false;
      }
    }

    return true;
  };

  return SwissTournamentModel;
});

/**
 * SymmetricMatrixModel is a MatrixModel subclass which maps write and read
 * access to a triangular portion of the matrix, thereby maintaining symmetry.
 *
 * The restrictions are imposed by overloading the get() and set() functions,
 * which in turn call the superclass functions if the range is within the
 * writable limits.
 *
 * @return SymmetricMatrixModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/symmetricmatrixmodel',['lib/extend', './matrixmodel'], function(extend, MatrixModel) {
  /**
   * Constructor
   *
   * @param size
   *          size of the matrix. defaults to 0
   */
  function SymmetricMatrixModel(size) {
    SymmetricMatrixModel.superconstructor.call(this, size);
  }
  extend(SymmetricMatrixModel, MatrixModel);

  /**
   * get() function, which maps super-diagonal elements to a lower triangular
   * matrix
   *
   * @param row
   *          row
   * @param col
   *          column
   * @return the stored value
   */
  SymmetricMatrixModel.prototype.get = function(row, col) {
    if (row < col) {
      return SymmetricMatrixModel.superclass.get.call(this, col, row);
    }

    return SymmetricMatrixModel.superclass.get.call(this, row, col);
  };

  /**
   * set() function, which maps super-diagonal writes to the lower triangular
   * matrix
   *
   * @param row
   *          row
   * @param col
   *          column
   * @param value
   *          value
   * @return this on success, undefined otherwise
   */
  SymmetricMatrixModel.prototype.set = function(row, col, value) {
    if (row < col) {
      return SymmetricMatrixModel.superclass.set.call(this, col, row, value);
    }

    return SymmetricMatrixModel.superclass.set.call(this, row, col, value);
  };

  return SymmetricMatrixModel;
});

/**
 * TabImageView:display the tab image
 *
 * @return TabImageView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tabimageview',['lib/extend', './view'], function(extend, View) {
  /**
   * Constructor
   *
   * @param tabname
   *          the base name of the tab
   * @param model
   *          a ValueModel instance. The value will be appended to the base name
   *          to create the image descriptor
   * @param $view
   *          the associated view
   */
  function TabImageView(tabname, model, $view) {
    TabImageView.superconstructor.call(this, model, $view);

    this.tabname = tabname;

    this.update();
  }
  extend(TabImageView, View);

  /**
   * update the image to the given parameters
   */
  TabImageView.prototype.update = function() {
    this.$view.attr('data-img', this.tabname + this.model.get());
  };

  /**
   * Callback function for the associated ValueModel
   */
  TabImageView.prototype.onupdate = function() {
    this.update();
  };

  return TabImageView;
});

/**
 * TabMenuController
 *
 * @return TabMenuController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tabmenucontroller',['jquery', 'lib/extend', './controller', './listener'], function($,
    extend, Controller, Listener) {
  /**
   * Constructor
   *
   * @param view
   *          the associated TabMenuView
   */
  function TabMenuController(view) {
    var model, listener;

    TabMenuController.superconstructor.call(this, view);

    model = this.model;

    function followHash() {
      model.set(window.location.hash.replace(/^#/, ''));
    }

    // move to current location, if available
    $(window).on('hashchange', followHash);

    // follow the hash if the tab accessibility has changed in our favor
    listener = new Listener(this.view.tabnames);
    listener.oninsert = followHash;

    // follow the hash now
    followHash();
  }
  extend(TabMenuController, Controller);

  /**
   * focus a tab using the hard way: location change.
   *
   * @param tabname
   *          the tab to focus
   */
  TabMenuController.prototype.focus = function(tabname) {
    window.location.hash = '#' + tabname;
  };

  return TabMenuController;
});

/**
 * TabModel: control the visibility and accesibility state of a tab
 *
 * @return TabModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tabmodel',['lib/extend', './model', './valuemodel'], function(extend, Model,
    ValueModel) {
  /**
   * Constructor
   */
  function TabModel() {
    TabModel.superconstructor.call(this);

    this.visibility = new ValueModel(true);
    this.accessibility = new ValueModel(true);
    this.imgParam = new ValueModel('');
  }
  extend(TabModel, Model);

  return TabModel;
});

/**
 * TabMenuView: manage the visibility of tabs and show a tab menu. This class
 * does not work with ids and targets directly, so multiple instances are
 * possible, but still discouraged.
 *
 * This class is supposed to avoid the css :target attribute for a multitude of
 * reasons. First, :target is not as cross-browser-compatible as required: Most
 * browsers cannot print :target-displayed elements. :target-displayed elements
 * will force the scroll position on reload, which "hides" the tabmenu. Also,
 * using the history (back/forward feature) of the browser, it's possible to
 * move to an already closed or non-existant tab. Worst of all, the tabmenu has
 * to be hidden behind its containing tab by using a lower z-index, which
 * renders the tabmenu unclickable in Internet Explorer.
 *
 * By using CSS classes to show/hide tabs, all of the above errors are avoided.
 *
 * @return TabMenuView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tabmenuview',['jquery', 'lib/extend', './view', './tabmenucontroller', './listmodel',
    './selectionvaluemodel', './tabmodel', './classview', './tabimageview',
    './listexclusionlistener'], function($, extend, View, TabMenuController,
    ListModel, SelectionValueModel, TabModel, ClassView, TabImageView,
    ListExclusionListener) {
  /**
   * Constructor
   *
   * @param $view
   *          associated DOM element
   */
  function TabMenuView($view) {
    this.tabnames = new ListModel();
    TabMenuView.superconstructor.call(this, new SelectionValueModel(undefined,
        this.tabnames), $view);

    this.keys = {};
    this.$tabs = {};
    this.$tabicons = {};
    this.tabmodels = {};
    this.$menu = undefined;
    this.tabmodels = {};

    this.initTabs();

    this.controller = new TabMenuController(this);
  }
  extend(TabMenuView, View);

  /**
   * Perform all initializations
   */
  TabMenuView.prototype.initTabs = function() {
    this.extractTabNames();
    this.createTabMenu();
    this.createTabModels();
    this.readDefaultTab();
  };

  /**
   * read the data-tab of the tabs, remove them and store them in tabnames
   */
  TabMenuView.prototype.extractTabNames = function() {
    var tabnames, $tabs, keys;

    tabnames = this.tabnames;
    $tabs = this.$tabs;
    keys = this.keys;

    this.$view.find('> div').each(function(index) {
      var $this, tabname;
      $this = $(this);
      tabname = $this.attr('data-tab');

      keys[tabname] = $this.attr('accesskey');
      $this.removeAttr('accesskey');

      $tabs[tabname] = $this;
      tabnames.push(tabname);
    });
  };

  /**
   * For every extracted tabname, create and bind a TabModel which controls the
   * visibility, accessibility and image parameter
   */
  TabMenuView.prototype.createTabModels = function() {
    this.tabnames.map(function(tabname) {
      /*
       * Using a throwaway tmp variable to avoid unjustified Lint warnings, but
       * keep them active for other parts of the code. This is bad coding, but I
       * don't want another reference outside of emitters and listeners.
       */
      var tmp, model;

      model = new TabModel();
      this.tabmodels[tabname] = model;

      tmp = new ClassView(model.visibility, this.$tabicons[tabname], undefined,
          'hidden');
      tmp = new TabImageView(tabname, model.imgParam, this.$tabicons[tabname]);
      tmp = new ListExclusionListener(model.accessibility, this.tabnames,
          tabname);

      return tmp;
    }, this);
  };

  /**
   * use the first tab as the default tab.
   *
   * Side note: The "first tab" is the first tab in the list, not the first tab
   * on the page. Right after starting the software, they coincide, but this can
   * change when the first tab is made unaccessible. Though this is unwanted
   * behaviour,it's good enough for Tuvero. Just don't hide the start page.
   *
   * If you do, I urge you to adjust the code somehow. Hook into the events of
   * this.tabnames or this.model to get a new default tab.
   */
  TabMenuView.prototype.readDefaultTab = function() {
    // This implicitly calls onupdate()
    this.model.setDefault(this.tabnames.get(0));
  };

  /**
   * Retrieve the controlling TabModel instances
   *
   * @param tabname
   *          the tab name
   * @return undefined on failure, the associated tab model otherwise
   */
  TabMenuView.prototype.getTabModel = function(tabname) {
    return this.tabmodels[tabname];
  };

  /**
   * create and add the menu to the DOM
   */
  TabMenuView.prototype.createTabMenu = function() {

    this.$menu = $('<span>').addClass('tabmenu');

    this.tabnames.map(function(tabname) {
      var $tab = $('<a>').attr('tabindex', -1);
      $tab.attr('href', '#' + tabname);
      if (this.keys[tabname]) {
        $tab.attr('accesskey', this.keys[tabname]);
      }
      this.$tabicons[tabname] = $tab;
      this.$menu.append($tab);
    }, this);

    this.$view.before(this.$menu);
  };

  /**
   * shows the currently active tab
   */
  TabMenuView.prototype.update = function() {
    var tabname;

    // guaranteed to be a valid index, because of SelectionValueModel
    tabname = this.model.get();

    this.$view.find('>.open').removeClass('open');
    this.$menu.find('>.open').removeClass('open');
    this.$tabs[tabname].addClass('open');
    this.$tabicons[tabname].addClass('open');
  };

  /**
   * Callback Listener for SelectionValueModel changes
   */
  TabMenuView.prototype.onupdate = function() {
    this.update();
  };

  /**
   * Delegate the focus request all the way to the controller
   *
   * @param tabname
   *          the tab to focus
   */
  TabMenuView.prototype.focus = function(tabname) {
    this.controller.focus(tabname);
  };

  return TabMenuView;
});

/**
 * TournamentIndex: An object with which tournaments can be instantiated from
 * system strings, instead of knowing the constructor in advance.
 *
 * @return TournamentIndex;
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tournamentindex',['./type', './roundtournamentmodel', './swisstournamentmodel',
    './kotournamentmodel'], function(Type) {
  var TournamentIndex, tournamentSystems, i, sys;

  tournamentSystems = {};
  // i starts at 1 to ignore the "Type" object
  for (i = 1; i < arguments.length; i += 1) {
    sys = arguments[i].prototype.SYSTEM;
    if (tournamentSystems[sys]) {
      console.error('ERROR: duplicate tournament sys: ' + sys);
    }
    tournamentSystems[sys] = arguments[i];
  }

  TournamentIndex = {
    /**
     * creates a tournament
     *
     * @param system
     *          a string which corresponds to a TournamentModel.SYSTEM string
     * @param rankingorder
     *          a ranking order
     * @return a TournamentModel instance on success, or undefined on failure
     *         (e.g. if the system doesn't exist)
     */
    createTournament: function(system, rankingorder) {
      if (Type.isString(system)) {
        // default instantiation by name
        if (tournamentSystems[system]) {
          return new tournamentSystems[system](rankingorder);
        }
      } else if (Type.isObject(system)) {
        // "restore"-instantiation from savedata
        return TournamentIndex.createTournament(system.sys);
      }

      console.error('TournamentIndex: system not found: ' + system);
      return undefined;
    },
    systems: Object.keys(tournamentSystems).sort()
  };

  return TournamentIndex;
});

/**
 * TournamentListModel: A list of tournaments, which can be used to determine
 * the current tournament and global rank for each player.
 *
 * @return TournamentListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/tournamentlistmodel',['lib/extend', './indexedlistmodel', './listmodel', './uniquelistmodel',
    './tournamentindex', './listener', './model'], function(extend,
    IndexedListModel, ListModel, UniqueListModel, TournamentIndex, Listener,
    Model) {
  /**
   * Constructor
   */
  function TournamentListModel() {
    TournamentListModel.superconstructor.call(this);

    this.startIndex = new ListModel();
    this.closedTournaments = new UniqueListModel();

    this.rankingCache = undefined;

    this.setListeners();
  }
  extend(TournamentListModel, IndexedListModel);

  TournamentListModel.prototype.EVENTS = {
    'update': true,
    'reset': true,
    'insert': true,
    'remove': true,
    'resize': true
  };

  /**
   * TODO should use the event system. Benchmark first!
   *
   * @return an array of tournament IDs for every team in a tournament
   */
  TournamentListModel.prototype.tournamentIDsForEachTeam = function() {
    var ids = [];

    this.map(function(tournament) {
      if (tournament.getState().get() != 'finished') {
        tournament.getTeams().map(function(team) {
          ids[team] = tournament.getID();
        });
      }
    });

    return ids;
  };

  /**
   * force a recalculation of the global Ranking and emit 'update'
   */
  TournamentListModel.prototype.invalidateGlobalRanking = function() {
    this.rankingCache = undefined;
    this.emit('update');
  };

  /**
   * @param tournamentID
   * @return true on success, false otherwise.
   */
  TournamentListModel.prototype.closeTournament = function(tournamentID) {
    if (this.get(tournamentID) === undefined) {
      console.error('tournament ID ' + tournamentID + ' is undefined');
      return false;
    }

    if (!this.closedTournaments.push(tournamentID)) {
      console.error('tournament ID ' + tournamentID + ' is already closed');
      return false;
    }

    this.invalidateGlobalRanking();

    return true;
  };

  /**
   * @return an array with a 'true' or 'false' entry for every tournament.
   */
  TournamentListModel.prototype.areTournamentsClosed = function() {
    var closed;

    closed = [];
    while (closed.length < this.length) {
      closed.push(false);
    }

    this.closedTournaments.map(function(tournamentID) {
      closed[tournamentID] = true;
    });

    return closed;
  };

  /**
   * create a global ranking object, which includes the tournament IDs, team
   * IDs, global display order, tournament ranks and global ranks.
   *
   * @param numTeams
   *          the number of teams
   * @return a globalRanking object
   */
  TournamentListModel.prototype.getGlobalRanking = function(numTeams) {
    var teams, undefinedTeams, zeroTeams;

    if (numTeams === undefined || numTeams < 0) {
      console.error('invalid numTeams parameter');
      return undefined;
    }

    if (this.rankingCache && this.rankingCache.displayOrder
        && this.rankingCache.displayOrder.length === numTeams) {
      return this.rankingCache;
    }

    teams = [];
    while (teams.length < numTeams) {
      teams.push(teams.length);
    }

    undefinedTeams = teams.map(function() {
      return undefined;
    });

    zeroTeams = teams.map(function() {
      return 0;
    });

    // initialize empty object, but with correct team sizes
    this.rankingCache = {
      // index: rank
      displayOrder: teams.slice(0),
      // index: teamid
      globalRanks: zeroTeams.slice(0),
      tournamentRanks: zeroTeams.slice(0),
      tournamentIDs: undefinedTeams.slice(0),
      tournamentOffsets: this.startIndex.asArray()
    };

    // apply all tournaments in order, just like they were played.
    this.map(function(tournament) {
      this.applyTournamentToRanks(tournament, this.rankingCache);
    }, this);

    this.calculateGlobalRanks(this.rankingCache);

    return this.rankingCache;
  };

  /**
   * apply a single tournament to a global ranking object, in order to
   * manipulate the ranking so that this tournament is considered part of it.
   * Sounds strange, but it mainly reorders the teams by the tournament ranks
   * and sets the tournament ranks. Doesn't take care of the global ranks.
   *
   * @param tournament
   *          a TournamentModel instance
   * @param globalRanking
   *          a globalRanking object.
   */
  TournamentListModel.prototype.applyTournamentToRanks = function(tournament,
      globalRanking) {
    var tournamentID, tournamentRanking, startIndex, isClosed;

    tournamentID = tournament.getID();
    tournamentRanking = tournament.getRanking().get();
    length = tournamentRanking.displayOrder.length;
    startIndex = this.startIndex.get(tournamentID);

    isClosed = this.closedTournaments.indexOf(tournamentID) !== -1;

    tournamentRanking.displayOrder.map(function(tournamentTeamID, displayID) {
      var globalTeamID, globalDisplayID, tournamentRank;

      globalTeamID = tournamentRanking.ids[tournamentTeamID];
      globalDisplayID = startIndex + displayID;
      tournamentRank = tournamentRanking.ranks[tournamentTeamID];

      globalRanking.displayOrder[globalDisplayID] = globalTeamID;
      globalRanking.tournamentRanks[globalTeamID] = tournamentRank;

      if (isClosed) {
        globalRanking.tournamentIDs[globalTeamID] = undefined;
      } else {
        globalRanking.tournamentIDs[globalTeamID] = tournamentID;
      }
    }, this);
  };

  /**
   * after all tournaments have been applied to a bare global ranking, this
   * function calculates the global ranks from the given information
   *
   * @param ranking
   *          a global ranking object, as will be returned by getGlobalRanking()
   */
  TournamentListModel.prototype.calculateGlobalRanks = function(ranking) {
    var lastTournamentID, lastTournamentRank, rank;

    lastTournamentID = undefined;
    lastTournamentRank = 0;
    rank = undefined;

    ranking.displayOrder.map(function(teamID, displayID) {
      var tournamentID, tournamentRank;

      tournamentID = ranking.tournamentIDs[teamID];
      tournamentRank = ranking.tournamentRanks[teamID];

      if (rank === undefined || tournamentID !== lastTournamentID
          || lastTournamentRank !== tournamentRank) {
        rank = displayID;
        lastTournamentRank = tournamentRank;
        lastTournamentID = tournamentID;
      }

      ranking.globalRanks[teamID] = rank;
    });
  };

  /**
   * add a new tournament to the list, but also remember its starting index. The
   * starting index is required for the calculation of the global ranking
   *
   * @param tournament
   *          a TournamentModel instance
   * @param startIndex
   *          the index of the first team in the global Ranking. Used for global
   *          ranking calculations
   * @return true on success, false or undefined otherwise. See ListModel.push()
   */
  TournamentListModel.prototype.push = function(tournament, startIndex) {
    if (this.length == this.startIndex.length) {
      this.startIndex.push(startIndex || 0);
    }

    return TournamentListModel.superclass.push.call(this, tournament);
  };

  /*
   * TODO don't allow insert, remove, clear and whatever else could mess up the
   * global ranking
   */

  /**
   * forward ranking updates to external listeners
   *
   * @param emitter
   *          the emitter
   * @param event
   *          the event name
   * @param data
   *          an optional data object
   */
  TournamentListModel.prototype.onupdate = function(emitter, event, data) {
    this.invalidateGlobalRanking();
  };

  /**
   * helper function to set all anonymous Listeners
   *
   * @param list
   *          a TournamentListModel instance
   */
  TournamentListModel.prototype.setListeners = function() {
    Listener.bind(this, 'insert', function(emitter, event, data) {
      if (emitter === this) {
        data.object.getRanking().registerListener(this);
        data.object.getState().registerListener(this);
        this.invalidateGlobalRanking();
      }
    }, this);

    Listener.bind(this, 'remove', function(emitter, event, data) {
      if (emitter === this) {
        data.object.getRanking().unregisterListener(this);
        data.object.getState().unregisterListener(this);
        this.invalidateGlobalRanking();
      }
    }, this);
  };

  /**
   * clear everything
   */
  TournamentListModel.prototype.clear = function() {
    if (!this.isRestoring) {
      this.startIndex.clear();
      this.closedTournaments.clear();
    }
    TournamentListModel.superclass.clear.call(this);
  };

  TournamentListModel.prototype.save = function() {
    var data = Model.prototype.save.call(this);

    data.tournaments = TournamentListModel.superclass.save.call(this);
    data.startIndex = this.startIndex.save();
    data.closedTournaments = this.closedTournaments.save();

    return data;
  };

  /**
   * restores tournaments from savedata objects. This function is used to
   * enforce the usage of TournamentIndex.createTournament as a factory. The
   * other logic is embedded into ListModel, which in turn constructs
   * TournamentModel instances.
   *
   * @param data
   *          a data object, as returned from this.save();
   * @return true on success, false otherwise
   */
  TournamentListModel.prototype.restore = function(data) {
    if (!Model.prototype.restore.call(this, data)) {
      return false;
    }

    this.isRestoring = true;

    if (!this.startIndex.restore(data.startIndex)) {
      console.error('TournamentListModel: cannot restore closedTournaments');
      return false;
    }

    if (!this.closedTournaments.restore(data.closedTournaments)) {
      console.error('TournamentListModel: cannot restore closedTournaments');
      return false;
    }

    if (!TournamentListModel.superclass.restore.call(this, data.tournaments,
        TournamentIndex.createTournament)) {
      console.error('TournamentListModel: cannot restore "this"');
      return false;
    }

    delete this.isRestoring;

    return true;
  };

  TournamentListModel.prototype.SAVEFORMAT = {
    tournaments: [Object],
    startIndex: [Number],
    closedTournaments: [Number]
  };

  return TournamentListModel;
});

/**
 * TransposeDifferenceMatrix: the difference of a matrix and its transpose.
 *
 * If the matrix is a "winsmatrix", its TransposeDifferenceMatrix shows who has
 * won. get(i,k) > 0: i has won. get(i,k) < 0: k has won. Otherwise: draw.
 *
 * @return TransposeDifferenceMatrix
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/transposedifferencematrix',['lib/extend', './delegatematrix'], function(extend, DelegateMatrix) {
  /**
   * Constructor
   *
   * @param matrix
   *          the matrix to bind itself to
   */
  function TransposeDifferenceMatrix(matrix) {
    TransposeDifferenceMatrix.superconstructor.call(this, matrix);
  }
  extend(TransposeDifferenceMatrix, DelegateMatrix);

  /**
   * return only positive values
   *
   * @param row
   *          the row
   * @param col
   *          the column
   * @return get(row, col)+get(col, row), i.e. (A + A^T)
   */
  TransposeDifferenceMatrix.prototype.get = function(row, col) {
    var v1, v2;
    v1 = this.superget(row, col);
    v2 = this.superget(col, row);
    if (v1 === undefined || v2 === undefined) {
      return undefined;
    }
    return v1 - v2;
  };

  return TransposeDifferenceMatrix;
});

/**
 * TriangleMatrixModel is a MatrixModel subclass which restricts write access to
 * the main diagonal and sub-diagonal elements, yielding a lower triangular
 * matrix class.
 *
 * The restrictions are imposed by overloading the get() and set() functions,
 * which in turn call the superclass functions if the range is within the
 * writable limits
 *
 *
 * @return TriangleMatrixModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/trianglematrixmodel',['lib/extend', './matrixmodel'], function(extend, MatrixModel) {
  /**
   * Constructor
   *
   * @param size
   *          size of the matrix. defaults to 0
   */
  function TriangleMatrixModel(size) {
    TriangleMatrixModel.superconstructor.call(this, size);
  }
  extend(TriangleMatrixModel, MatrixModel);

  /**
   * get() function, which ignores super-diagonal elements
   *
   * @param row
   *          row
   * @param col
   *          column
   * @return 0 if reading a super-diagonal element, the stored value otherwise
   */
  TriangleMatrixModel.prototype.get = function(row, col) {
    if (row < col) {
      return 0;
    }

    return TriangleMatrixModel.superclass.get.call(this, row, col);
  };

  /**
   * set() function, which ignores super-diagonal positions
   *
   * @param row
   *          row
   * @param col
   *          column
   * @param value
   *          value
   * @return this on success, undefined otherwise
   */
  TriangleMatrixModel.prototype.set = function(row, col, value) {
    if (row < col) {
      return undefined;
    }

    return TriangleMatrixModel.superclass.set.call(this, row, col, value);
  };

  return TriangleMatrixModel;
});

/**
 * KeyModel: Represents a key for use with Query, RefLog and Commit. Keys
 * contain a target, a startDate and a saveDate with millisecond-accuracy.
 *
 * Keys can be either root keys (startDate == saveDate), or child keys
 * (startDate < saveDate)
 *
 * This implementation tries to be as careful as possible with the formats to
 * avoid lost orphans, hence errors are thrown at the first sign of trouble.
 *
 * @return KeyModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/keymodel',['lib/extend', 'core/model', 'core/type', 'presets'], function(extend,
    Model, Type, Presets) {
  var delimiter, dateRegexSource, dateRegex, keyRegex, tuveroKeyRegex;

  /*
   * local regexes, which are used internally for format validation
   */
  delimiter = '_';
  dateRegexSource = '[0-9]{4}-[0-9]{2}-[0-9]{2}'
      + 'T[0-9]{2}:[0-9]{2}:[0-9]{2}\.[0-9]{3}Z';
  dateRegex = new RegExp('^' + dateRegexSource + '$');
  targetRegex = new RegExp('^(' + Presets.target + ')' + delimiter);
  keyRegex = new RegExp(targetRegex.source + '(' + dateRegexSource + ')'
      + delimiter + '(' + dateRegexSource + ')$');
  tuveroKeyRegex = new RegExp('^([a-z]*)' + delimiter + '(' + dateRegexSource
      + ')' + delimiter + '(' + dateRegexSource + ')$');

  /**
   * Constructor. Constructs a new key from the current target (Presets.target),
   * the given startDate and saveDate. The dates are checked for strict
   * ISO8601-compliance, including millisecond digits. The ECMA 5 standard
   * dictates that Date.prototype.toISOString() matches this format.
   *
   * @param startDate
   *          Any start date
   * @param saveDate
   *          Any save date. Must be later than startDate
   */
  function KeyModel(startDate, saveDate) {
    KeyModel.superconstructor.call(this);

    if (!dateRegex.test(startDate)) {
      throw new Error('startDate is no valid ISO8601. toISOString() failure?');
    }
    if (!dateRegex.test(saveDate)) {
      throw new Error('saveDate is no valid ISO8601. toISOString() failure?');
    }
    if (saveDate < startDate) {
      throw new Error('saveDate is earlier than startDate!');
    }

    this.target = Presets.target;
    this.startDate = startDate;
    this.saveDate = saveDate;

    if (!KeyModel.isValidKey(this)) {
      throw new Error(
          'Critical error: serialized key is not valid. Call Erik E. Lorenz!');
    }
  }
  extend(KeyModel, Model);

  /**
   * Converts the Key to a localStorage-compatible string representation.
   * Performs additional format checks.
   *
   * @return a localStorage-compatible string representation of the key
   */
  KeyModel.prototype.toString = function() {
    var key = [this.target, this.startDate, this.saveDate].join(delimiter);

    if (!keyRegex.test(key)) {
      throw new Error('created KeyModel does not match format: ' + key);
    }

    return key;
  };

  /**
   * Test whether the key is valid and a root key, i.e. both dates match
   *
   * @return true if valid and an root key, false otherwise
   */
  KeyModel.prototype.isRoot = function() {
    return this.startDate == this.saveDate;
  };

  /**
   * Test whether the key is somehow related to this key, i.e. whether the start
   * date and target match. This does not test whether they're in the same
   * branch, since only the keys are tested, not their relations.
   *
   * If used as an Array.filter() function, you must use the bind() function!
   *
   * @param key
   * @return true if target and start date match, false otherwise.
   */
  KeyModel.prototype.isRelated = function(key) {
    var relatedRegex;

    relatedRegex = new RegExp(targetRegex.source + '(' + this.startDate + ')'
        + delimiter + '(' + dateRegexSource + ')$', 'i');

    return relatedRegex.test(key.toString());
  };

  /**
   * @param key
   *          a key string or instance
   * @return true if both keys match, false otherwise
   */
  KeyModel.prototype.isEqual = function(key) {
    return this.toString() == key.toString();
  };

  /**
   * Test whether the given key is valid and can be processed by this target.
   * This does not test the stored content, only the key strings, so invalid
   * dates can still fall through.
   *
   * @param key
   *          a string representation of a key
   * @return true if key matches the key format and currently open target, false
   *         otherwise
   */
  KeyModel.isValidKey = function(key) {
    return keyRegex.test(key.toString());
  };

  /**
   * Test whether the date string is a compatible ISO8601-string.
   *
   * @param isoDateString
   *          a string representation of a date. Should be ISO8601 including
   *          milliseconds.
   * @return true if key matches the required date format. See
   *         Date.prototype.toISOString for more information
   */
  KeyModel.isValidDate = function(isoDateString) {
    return dateRegex.test(isoDateString);
  };

  /**
   * Test whether the given key could in theory be used for another target
   * (Basic, Boule, TAC, ...)
   *
   * @param key
   *          a string representation of a key
   * @return true if key matches the tuvero key format, regardless of the target
   */
  KeyModel.isTuveroKey = function(key) {
    return tuveroKeyRegex.test(key.toString());
  };

  /**
   * create a new key which is related to the parent key (see isRelated()).
   * Apart from the key relation, no other parenting is applied.
   *
   * Extra care is taken when getting a new saveDate as to not accidentally
   * create the parentKey again. This could in theory happen if the childKey is
   * created less than a millisecond after the parentKey, but it's rather
   * unlikely in everyday use.
   *
   * NOTE: If the browser doesn't update the millisecond-portion of the Date,
   * this could potentially result in an infinite loop, or be stuck for a whole
   * second.
   *
   * @param parentKey
   *          a parent key
   * @return a new key with a later saveDate but the same startDate
   */
  KeyModel.createChild = function(parentKey) {
    var startDate, saveDate;

    if (!KeyModel.isValidKey(parentKey) || !Type.isObject(parentKey)) {
      throw new Error('createChild(): parentKey is not valid');
    }

    startDate = parentKey.startDate;

    /*
     * Avoid creating an identical key by accidentally having the exact same
     * millisecond-precise date. Stall code execution for a millisecond instead
     * to get a slightly different key. We could also modify the dates manually,
     * but a millisecond won't even be noticed.
     *
     * Normally, you don't create two keys that close to another, and even then
     * it's only max. 200 loop executions.
     */
    do {
      saveDate = (new Date()).toISOString();
    } while (saveDate === startDate);

    return new KeyModel(startDate, saveDate);
  };

  /**
   * read startDate and saveString from the keyString and make sure that the
   * targets match.
   *
   * @param keyString
   * @return a KeyModel instance with the extracted startDate and saveDate.
   */
  KeyModel.fromString = function(keyString) {
    var startDate, saveDate, matches;

    if (!targetRegex.test(keyString)) {
      throw new Error('KeyModel reference string has wrong target: '
          + keyString);
    }

    matches = keyRegex.exec(keyString);
    if (!matches) {
      throw new Error('KeyModel reference string does not match format');
    }
    if (matches.length != 4) {
      throw new Error('Regex Error? wrong number of captures (not 3): '
          + matches.join(','));
    }

    startDate = matches[2];
    saveDate = matches[3];

    return new KeyModel(startDate, saveDate);
  };

  /**
   * create a new root key
   *
   * @return a new root key with the current date
   */
  KeyModel.createRoot = function() {
    var startDate = (new Date()).toISOString();

    return new KeyModel(startDate, startDate);
  };

  /**
   * a sort function for KeyModels. Sorts by target, startDate and saveDate, all
   * in ascending order.
   *
   * @param keyA
   * @param keyB
   * @return -1, 0 or 1, depending on the keys.
   */
  KeyModel.sortFunction = function(keyA, keyB) {
    return keyA.toString().localeCompare(keyB.toString());
  };

  return KeyModel;
});

/**
 * Query searches the localStorage for keys related to tuvero
 *
 * @return Query
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/query',['timemachine/keymodel', 'core/type'], function(KeyModel, Type) {
  /**
   * Constructor. Constructs a new query, but does not apply the filter. A query
   * reads the localStorage for entries, regardless of the RefLog.
   *
   * The reference can be a key, in which case only related keys are returned by
   * the filter() function, or one of the logical constants, i.e. one of
   * Query.ALLKEYS/ROOTKEYS/LASTKEYS/LATESTSAVE/ALLTUVEROKEYS.
   *
   * Query.ALLKEYS filters all keys for the current target
   *
   * Query.ROOTKEYS filters only the root keys
   *
   * Query.LASTKEYS filters the last saved keys for every root key
   *
   * Query.LATESTSAVE filters the single key with the highest save date
   *
   * Query.ALLTUVEROKEYS filters all keys of any possible target.
   *
   * @param reference
   *          a KeyModel instance/string (=> related keys) or one of the static
   *          members of Query (e.g. Query.ALLKEYS). Defaults to Query.ALLKEYS
   *
   */
  function Query(reference) {
    this.reference = reference;
    if (reference === Query.ALLKEYS) {
    } else if (reference === Query.ROOTKEYS) {
    } else if (reference === Query.LASTKEYS) {
    } else if (reference === Query.LATESTSAVE) {
    } else if (reference === Query.ALLTUVEROKEYS) {
    } else if (Type.isString(reference)) {
      this.referenceKey = KeyModel.fromString(reference);
    } else if (reference instanceof KeyModel) {
      this.referenceKey = reference;
    } else {
      throw new Error('Query: reference has unknown type: ' + reference);
    }
  }

  Query.ALLKEYS = undefined; // --> default behaviour
  Query.ROOTKEYS = {};
  Query.LASTKEYS = {};
  Query.LATESTSAVE = {};
  Query.ALLTUVEROKEYS = {};

  /**
   * reads the localStorage for valid keys and filters them by the given
   * reference. See Query() for a full list of possible references.
   *
   * You can apply filter() as often as you want. There is no caching involved.
   *
   * @return an array of stored key strings which match the selection
   */
  Query.prototype.filter = function() {
    var keys, trees, last, lastDate;
    if (window.localStorage) {
      keys = Object.keys(window.localStorage);
    } else {
      keys = [];
    }

    if (this.reference === Query.ALLTUVEROKEYS) {
      keys = keys.filter(KeyModel.isTuveroKey);
    } else {
      keys = keys.filter(KeyModel.isValidKey);
    }

    if (keys.length === 0) {
      return [];
    }

    switch (this.reference) {
    case Query.ALLKEYS:
    case Query.ALLTUVEROKEYS:
      // Nothing to do here. keys already contains all keys.
      break;
    case Query.ROOTKEYS:
      keys = keys.filter(function(keyString) {
        var key = new KeyModel.fromString(keyString);
        return key.isRoot();
      });
      break;
    case Query.LASTKEYS:
      trees = {};
      keys.forEach(function(keyString) {
        var startDate = (KeyModel.fromString(keyString)).startDate;
        if (!trees[startDate] || trees[startDate] < keyString) {
          trees[startDate] = keyString;
        }
      });

      keys = Object.keys(trees).map(function(key) {
        return trees[key];
      });
      break;
    case Query.LATESTSAVE:
      last = undefined;
      keys.forEach(function(keyString) {
        var saveDate = (KeyModel.fromString(keyString)).saveDate;
        if (!last || lastDate < saveDate) {
          last = keyString;
          lastDate = saveDate;
        }
      });

      keys = [last];
      break;
    default:
      if (!this.referenceKey) {
        throw new Error('Query:'
            + ' this.referenceKey could not be extracted from this.reference');
      }

      keys = keys.filter(this.referenceKey.isRelated.bind(this.referenceKey));

      break;
    }

    return keys.sort();
  };

  return Query;
});

/**
 * RefLogModel: A reference log of storage keys.
 *
 * RefLogModel does not use ValueModel, ListModel and the like because it has to
 * be periodically synchronized between multiple instances, and because the
 * Model.save() mechanism isn't sophisticated enough for the data object due to
 * its usage of dynamic keys.
 *
 * Instead, a 2D data object is used, with the startdate as the outer key and
 * the savedate as the inner key. Inside the start-object, there's a 'name'
 * property, too. The value inner savedate-objects are the name of their
 * previous key, e.g. another savedate-key or the startdate-key. This yields a
 * tree-like structure.
 *
 * @return RefLogModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/reflog',['lib/extend', 'core/model', 'presets', 'timemachine/query',
    'core/listmodel', 'core/listener', 'timemachine/keymodel'], function(
    extend, Model, Presets, Query, ListModel, Listener, KeyModel) {
  var RefLog;

  /**
   * Constructor of the singleton. Don't expose.
   */
  function RefLogModel() {
    RefLogModel.superconstructor.call(this);

    this.source = undefined;
    this.data = {};
    this.storageKey = this.formatTargetKey(Presets.target);

    Listener.bind(this, 'error', function(event, emitter, message) {
      console.error(message);
    });

    this.refresh();
  }
  extend(RefLogModel, Model);

  RefLogModel.prototype.EVENTS = {
    'error': true,
    'rename': true,
    'refresh': true,
    'reset': true
  };

  /**
   * re-read the RefLog from localStorage.
   *
   * @return true on success, false otherwise
   */
  RefLogModel.prototype.refresh = function() {
    var newSource, newData;

    if (window.localStorage) {
      newSource = window.localStorage[this.storageKey];
    } else {
      newSource = this.source;
    }

    if (!newSource) {
      console.log('creating new reflog');
      newSource = '{}';
    } else if (this.source === newSource || newSource === 'undefined') {
      return true;
    }

    try {
      newData = JSON.parse(newSource);
    } catch (e) {
      console.error(e.stack);
      this.emit('error', 'cannot JSON-parse reflog from localStorage.');
      return false;
    }

    if (!newData) {
      this.emit('error', 'RefLog from localStorage contains no data.');
      return false;
    }

    this.data = newData;
    this.source = newSource;

    this.store();
    this.emit('refresh');

    return true;
  };

  /**
   * save the current reflog to localStorage.
   *
   * FIXME REALLY enable multiple parallel tournaments by just changing the
   * currently opened tournament, not others.
   */
  RefLogModel.prototype.store = function() {
    var dataString;

    if (!this.isValid()) {
      this.emit('error', 'RefLogModel: this.data is not valid!');
      return false;
    }

    dataString = JSON.stringify(this.data);

    if (window.localStorage) {
      window.localStorage[this.storageKey] = dataString;
      return window.localStorage[this.storageKey] === dataString;
    }

    return false;
  };

  /**
   * @return true if the reflog data is valid, false otherwise
   */
  RefLogModel.prototype.isValid = function() {
    if (!this.data) {
      return false;
    }

    // TODO check format!
    return true;
  };

  /**
   * creates a new child key under the parent key and registers it in the reflog
   *
   * @param parentKey
   *          the parent key
   * @return the new key. Returns undefined on error.
   */
  RefLogModel.prototype.newSaveKey = function(parentKey) {
    var newKey, startDate, refDate, saveDate;

    if (!parentKey) {
      this.emit('error', 'newSaveKey: no parent key given');
      return undefined;
    }

    newKey = KeyModel.createChild(parentKey);

    if (!parentKey.isRelated(newKey)) {
      this.emit('error', 'unexpected error: newKey is unrelated to parentKey');
      return undefined;
    }

    startDate = parentKey.startDate;
    refDate = parentKey.saveDate;
    saveDate = newKey.saveDate;

    if (!this.contains(parentKey)) {
      this.emit('error', 'newSaveKey(): parentKey is not in reflog!');
      return undefined;
    }

    this.data[startDate][saveDate] = refDate;

    this.store();

    return newKey;
  };

  /**
   * @return a new root key which hasn't been in the reflog before
   */
  RefLogModel.prototype.newInitKey = function(name) {
    var newKey;

    /*
     * Creating keys within milliseconds of another can cause rootkey collision
     *
     * Reading the reflog takes care of that.
     */
    do {
      newKey = KeyModel.createRoot();
    } while (this.contains(newKey));

    this.data[newKey.startDate] = {
      name: name
    };

    this.store();

    return newKey;
  };

  /**
   * @param refKey
   *          a reference key
   * @return true if refKey is contained in the reflog, false otherwise
   */
  RefLogModel.prototype.contains = function(refKey) {
    this.refresh();

    if (!this.data) {
      this.emit('error', 'reflog contains no data!');
      return false;
    }

    if (!this.data[refKey.startDate]) {
      return false;
    }

    if (refKey.isRoot()) {
      return true;
    }

    if (!this.data[refKey.startDate][refKey.saveDate]) {
      return false;
    }

    return true;
  };

  /**
   * @return a list of start dates. returns an empty array if the reflog is
   *         empty
   */
  RefLogModel.prototype.listStartDates = function() {
    this.refresh();

    if (!this.data) {
      return [];
    }

    return Object.keys(this.data).filter(KeyModel.isValidDate);
  };

  /**
   * @param startDate
   *          the start date for which to list the save dates (excluding the
   *          start date itself)
   * @return a list of save dates under the start date. Excludes the start date
   *         itself.
   */
  RefLogModel.prototype.listSaveDates = function(startDate) {
    this.refresh();

    if (!this.data || !this.data[startDate]) {
      this.emit('error', 'reflog does not contain start Date ' + startDate);
      return [];
    }

    return Object.keys(this.data[startDate]).filter(KeyModel.isValidDate);
  };

  /**
   * retrieve the name of the whole tree
   *
   * @param key
   *          a KeyModel instance
   * @return the name of the root element of the tree
   */
  RefLogModel.prototype.getName = function(key) {
    if (!this.contains(key)) {
      key = new KeyModel(key.startDate, key.startDate);
      if (!this.contains(key)) {
        this.emit('error', 'reflog does not contain key for name query');
        return '';
      }
    }

    return this.data[key.startDate].name || '';
  };

  /**
   * @param key
   *          any key of the tree for which to change the name
   * @param name
   *          the new name
   * @return true if the tree now carries the new name, false otherwise
   */
  RefLogModel.prototype.setName = function(key, name) {
    if (!this.contains(key)) {
      key = new KeyModel(key.startDate, key.startDate);
      if (!this.contains(key)) {
        this.emit('error', 'RefLog does not contain key for name setting');
        return false;
      }
    }

    if (name === this.getName(key)) {
      return true;
    }

    this.data[key.startDate].name = name;
    if (!this.store()) {
      this.emit('error', 'RefLog: store() error during name change');
      return false;
    }
    this.emit('rename', key);
    return true;
  };

  /**
   * @param refKey
   *          a KeyModel instance
   * @return a KeyModel instance of the parent key. Returns undefined if the key
   *         is a root key (has no parent)
   */
  RefLogModel.prototype.getParent = function(refKey) {
    if (!this.contains(refKey)) {
      this.emit('error', 'reflog does not contain key for parent search!');
      return undefined;
    }

    if (refKey.isRoot()) {
      return undefined;
    }

    return new KeyModel(refKey.startDate,
        this.data[refKey.startDate][refKey.saveDate]);
  };

  /**
   * @param refKey
   *          a parent key
   * @return an array of children. Returns an empty array if the parent key is
   *         not in the reflog
   */
  RefLogModel.prototype.getChildren = function(refKey) {
    if (!this.contains(refKey)) {
      this.emit('error', 'reflog does not contain key for children search');
      return [];
    }

    return this.listSaveDates(refKey.startDate).filter(function(saveDate) {
      var parentDate = this.data[refKey.startDate][saveDate];
      return parentDate === refKey.saveDate;
    }, this).map(function(saveDate) {
      return new KeyModel(refKey.startDate, saveDate);
    });
  };

  /**
   * @return an array of all keys in the reflog.
   */
  RefLogModel.prototype.getAllKeys = function() {
    var keys;

    keys = this.getInitKeys();

    this.listStartDates().forEach(function(startDate) {
      this.listSaveDates(startDate).forEach(function(saveDate) {
        keys.push(new KeyModel(startDate, saveDate));
      });
    }, this);

    return keys.sort();
  };

  /**
   * @return an array of all root keys in the reflog
   */
  RefLogModel.prototype.getInitKeys = function() {
    return this.listStartDates().sort().map(function(startDate) {
      return new KeyModel(startDate, startDate);
    });
  };

  /**
   * @return the youngest key in the whole reflog. Should be the key of the
   *         latest save state
   */
  RefLogModel.prototype.getLatestGlobalKey = function() {
    var data, latestKey;

    latestKey = this.listStartDates().map(function(startDate) {
      var saveDate = this.listSaveDates(startDate).sort().pop() || startDate;
      return new KeyModel(startDate, saveDate);
    }, this).sort(KeyModel.sortFunction).pop();

    if (!latestKey) {
      // this.emit('error', 'no latest key found');
      return undefined;
    }

    return latestKey;
  };

  /**
   * @param refKey
   *          a key in a tree
   * @return the youngest key in the whole tree
   */
  RefLogModel.prototype.getLatestRelatedKey = function(refKey) {
    var startDate, saveDate, latestKey, rootKey;

    if (!KeyModel.isValidKey(refKey)) {
      this.emit('error', 'getLatestRelatedKey(): refKey is invalid');
      return undefined;
    }

    startDate = refKey.startDate;

    if (!this.contains(refKey)) {
      rootKey = new KeyModel(startDate, startDate);
      if (!this.contains(rootKey)) {
        this.emit('error', 'root key is missing in reflog');
        return undefined;
      }
    }

    saveDate = this.listSaveDates(startDate).sort().pop() || startDate;

    return new KeyModel(startDate, saveDate);
  };

  /**
   * if the reflog is not empty, it's reset to an empty object. Emits 'remove'
   */
  RefLogModel.prototype.reset = function() {
    this.refresh();

    if (!this.data) {
      this.emit('error', 'RefLog.reset(): data is undefined');
      this.data = {};
      return;
    }

    if (this.listStartDates().length === 0) {
      // data is already empty. Nothing to do here. (Don't overwrite storage!)
      return;
    }

    this.data = {};

    this.emit('reset');

    this.store();
  };

  /**
   * Deletes the whole tree with the startDate of refKey
   *
   * @param refKey
   *          any key in the tree, not necessarily the root key
   */
  RefLogModel.prototype.deleteTree = function(refKey) {
    if (!this.contains(refKey)) {
      if (!this.contains(new KeyModel(refKey.startDate, refKey.startDate))) {
        // Nothing to do here. It's already deleted
        return;
      }
    }

    delete this.data[refKey.startDate];

    this.store();
  };

  /**
   * Deletes a single key and sets its children's parent to its parent
   *
   * @param refKey
   *          save key. root keys cannot be deleted.
   */
  RefLogModel.prototype.deleteKey = function(refKey) {
    var parentKey, children;

    if (refKey.isRoot()) {
      this.emit('error', 'cannot delete a single init key. '
          + 'use deleteTree() instead');
      return;
    }

    if (!this.contains(refKey)) {
      // this.emit('error', 'deleteKey(): refKey is not in reflog!');
      return;
    }

    parentKey = this.getParent(refKey);
    if (!parentKey) {
      this.emit('error', 'deleteKey(): parent key is not in reflog!');
      return;
    }

    children = this.getChildren(refKey);
    if (children === undefined) {
      this.emit('error', 'deleteKey(): Children cannot be extracted!');
      return;
    }

    children.forEach(function(child) {
      this.data[refKey.startDate][child.saveDate] = parentKey.saveDate;
    }, this);

    delete this.data[refKey.startDate][refKey.saveDate];

    this.store();
  };

  /**
   * converts the whole reflog to a single JSON string.
   *
   * @return a serialized representation of the RefLog
   */
  RefLogModel.prototype.toString = function() {
    return JSON.stringify(this.data);
  };

  /**
   * @param target
   *          a target name, e.g 'basic' or 'tac'
   * @return the key of the target's reflog in the localStorage
   */
  RefLogModel.prototype.formatTargetKey = function(target) {
    return target + '-reflog';
  };

  /*
   * RefLog is a singleton. Since we're dealing with localStorage, it wouldn't
   * make sense to use multiple of them, anyway
   */
  RefLog = new RefLogModel();

  return RefLog;
});

/**
 * CommitModel
 *
 * @return CommitModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/commitmodel',['lib/extend', 'core/model', 'timemachine/reflog', 'core/type',
    'timemachine/keymodel', 'timemachine/query'], function(extend, Model,
    RefLog, Type, KeyModel, Query) {

  /**
   * Constructor. Constructs a CommitModel from a KeyModel, regardless of the
   * presence in the localStorage or the RefLog
   *
   * @param key
   *          a KeyModel instance
   */
  function CommitModel(key) {
    CommitModel.superconstructor.call(this);

    if (Type.isString(key)) {
      key = KeyModel.fromString(key);
    }

    RefLog.registerListener(this);

    this.key = key;
  }
  extend(CommitModel, Model);

  CommitModel.prototype.EVENTS = {
    'remove': true,
    'rename': true
  };

  /**
   * @return true if the key is valid, is in the RefLog and is in the
   *         localStorage, false otherwise
   */
  CommitModel.prototype.isValid = function() {
    return !!this.key && KeyModel.isValidKey(this.key)
        && RefLog.contains(this.key)
        && (!window.localStorage || !!window.localStorage[this.key]);
  };

  /**
   * @return true if the key is a root key (has no parent and dates match),
   *         false otherwise
   */
  CommitModel.prototype.isRoot = function() {
    return this.key.isRoot();
  };

  /**
   * @return an array of CommitModels of children of this commit. If there's no
   *         child, the array is empty.
   */
  CommitModel.prototype.getChildren = function() {
    if (!RefLog.contains(this.key)) {
      return [];
    }
    return RefLog.getChildren(this.key).map(function(key) {
      return new CommitModel(key);
    }).sort(CommitModel.sortFunction);
  };

  /**
   * traverses the RefLog to find the youngest ancestor (highest save date)
   *
   * @return the youngest ancestor of this commit
   */
  CommitModel.prototype.getYoungestDescendant = function() {
    var children, youngestChild;

    children = this.getChildren();

    if (children.length === 0) {
      return undefined;
    }

    youngestChild = children[children.length - 1];

    children.forEach(function(child) {
      var youngestGrandChild = child.getYoungestDescendant();
      if (!youngestGrandChild) {
        return;
      }
      if (CommitModel.sortFunction(youngestGrandChild, youngestChild) === 1) {
        youngestChild = youngestGrandChild;
      }
    });

    return youngestChild;
  };

  /**
   * @return the parent if this commit. If this is a root commit, undefined is
   *         returned
   */
  CommitModel.prototype.getParent = function() {
    if (this.isRoot()) {
      return undefined;
    }

    return new CommitModel(RefLog.getParent(this.key));
  };

  /**
   * @return a new CommitModel instance of the root of this tree
   */
  CommitModel.prototype.getRoot = function() {
    var rootKey;

    if (this.isRoot()) {
      return this;
    }

    rootKey = new KeyModel(this.key.startDate, this.key.startDate);

    return new CommitModel(rootKey);
  };

  /**
   * @return the name of this tree
   */
  CommitModel.prototype.getTreeName = function() {
    return RefLog.getName(this.key);
  };

  /**
   * @param name
   *          the new name of the whole tree
   * @return true on success, false otherwise
   */
  CommitModel.prototype.setTreeName = function(name) {
    return RefLog.setName(this.key, name);
  };

  /**
   * @param commit
   *          a CommitModel instance
   * @return true if the keys are equal, false otherwise
   */
  CommitModel.prototype.isEqual = function(commit) {
    return !!commit && this.key.isEqual(commit.key);
  };

  /**
   * @param descendant
   *          a CommitModel instance which might be a descendant of this commit
   * @return true if 'this' is in the parent chain of descendant, false
   *         otherwise
   */
  CommitModel.prototype.isAncestorOf = function(descendant) {
    var parent;

    if (!descendant || this.isRoot()) {
      return false;
    }

    if (this.key.isRelated(descendant.key)) {
      return false;
    }

    for (parent = descendant.getParent(); parent; parent = parent.getParent()) {
      if (this.isEqual(parent)) {
        return true;
      }
    }

    return false;
  };

  /**
   * Removes all descendant and itself. Emits 'remove' on all removed elements.
   *
   * If eraseTree is called on a root commit, orphans with the same startDate
   * are cleaned up, too.
   */
  CommitModel.prototype.eraseTree = function() {
    var query;

    // first: properly delete all children to send the proper events
    this.getChildren().forEach(function(child) {
      child.eraseTree();
    });

    if (this.isRoot()) {
      // delete eventual orphans (Won't send remove events)
      query = new Query(this.key);
      if (window.localStorage) {
        query.filter().forEach(
            window.localStorage.removeItem.bind(window.localStorage));
      }
      RefLog.deleteTree(this.key);
      this.emit('remove');
    } else {
      // only delete everything that's depending on this commit
      this.remove();
    }
  };

  /**
   * removes this commit from the RefLog and localStorage and emits 'remove'.
   *
   * If a root commit is removed, the whole tree is removed. See eraseTree()
   */
  CommitModel.prototype.remove = function() {
    if (this.isRoot()) {
      // removing the root commit necessarily removes everything else, too,
      // since every tree needs a root in the reflog
      this.eraseTree();
    } else {
      if (window.localStorage) {
        window.localStorage.removeItem(this.key.toString());
      }
      RefLog.deleteKey(this.key);

      this.emit('remove');
    }
  };

  /**
   * read the contents of the localStorage under this key
   *
   * @return the locally stored data of this commit
   */
  CommitModel.prototype.load = function() {
    if (this.isValid()) {
      if (window.localStorage) {
        return window.localStorage[this.key];
      }
    }
    return undefined;
  };

  /**
   * Creates a Child commit and saves data on it. Properly deals with the RefLog
   * and the localStorage.
   *
   * @param data
   *          the data to store locally under a new key
   * @return the newly created child commit
   */
  CommitModel.prototype.createChild = function(data) {
    var newKey = RefLog.newSaveKey(this.key);

    if (window.localStorage) {
      window.localStorage[newKey] = data;
    }

    return new CommitModel(newKey);
  };

  /**
   * initialize a new commit with the given data. A root key will be created,
   * which serves as the root of the commit tree
   *
   * @param data
   *          the data do store locally under a new key
   * @return the newly created root commit
   */
  CommitModel.createRoot = function(data, name) {
    var newKey = RefLog.newInitKey(name);

    if (window.localStorage) {
      window.localStorage[newKey] = data;
    }

    return new CommitModel(newKey);
  };

  /**
   * a sort function for CommitModels
   *
   * @param commitA
   * @param commitB
   * @return -1, 0, or 1, depending on the sort relation between the two
   */
  CommitModel.sortFunction = function(commitA, commitB) {
    return KeyModel.sortFunction(commitA.key, commitB.key);
  };

  CommitModel.prototype.onrename = function(event, emitter, treeKey) {
    if (this.key.isRelated(treeKey)) {
      this.emit('rename');
    }
  };

  return CommitModel;
});

/**
 * TimeMachineModel
 *
 * TODO TEST!
 *
 * @return TimeMachineModelModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/timemachine',['lib/extend', 'core/model', 'timemachine/reflog',
    'timemachine/keymodel', 'timemachine/commitmodel', 'core/listmodel',
    'timemachine/query', 'core/sortedreferencelistmodel',
    'ui/listcollectormodel', 'presets', 'core/valuemodel'], function(extend,
    Model, RefLog, KeyModel, CommitModel, ListModel, Query,
    SortedReferenceListModel, ListCollectorModel, Presets, ValueModel) {
  var TimeMachine;

  /**
   * Constructor
   */
  function TimeMachineModel() {
    var latestKey;
    TimeMachineModel.superconstructor.call(this);

    latestKey = RefLog.getLatestGlobalKey();

    /*
     * unsortedRoots: base list
     */
    this.unsortedRoots = new ListModel();

    /*
     * roots: reference list. Use this one :-)
     */
    this.roots = new SortedReferenceListModel(this.unsortedRoots,
        CommitModel.sortFunction);

    this.rootsCollector = new ListCollectorModel(this.unsortedRoots,
        CommitModel);
    this.rootsCollector.registerListener(this);

    RefLog.registerListener(this);

    this.updateRoots();

    /*
     * commit is the current commit.
     */
    this.commit = new ValueModel(undefined);
    if (latestKey) {
      this.commit.set(new CommitModel(latestKey));
    } else {
      console.warn('No saved tournament found.');
    }
  }
  extend(TimeMachineModel, Model);

  TimeMachineModel.prototype.EVENTS = {
    'init': true,
    'save': true,
    'cleanup': true,
    'load': true,
    'unload': true
  };

  /**
   * re-read the roots from the reflog and update this.unsortedRoots, which
   * reflects on this.roots
   */
  TimeMachineModel.prototype.updateRoots = function() {
    var rootCommits, rootKeyStrings, index, keyString;

    rootCommits = RefLog.getInitKeys().map(function(key) {
      return new CommitModel(key);
    });
    rootKeyStrings = rootCommits.map(function(commit) {
      return commit.key.toString();
    });

    /*
     * remove old commits
     */
    for (index = this.unsortedRoots.length - 1; index >= 0; index -= 1) {
      keyString = this.unsortedRoots.get(index).key.toString();
      if (rootKeyStrings.indexOf(keyString) === -1) {
        this.unsortedRoots.get(index).destroy();
        this.unsortedRoots.remove(index);
      }
    }

    /*
     * add new commits
     */
    rootKeyStrings = this.unsortedRoots.map(function(commit) {
      return commit.key.toString();
    });
    rootCommits.forEach(function(commit) {
      keyString = commit.key.toString();
      if (rootKeyStrings.indexOf(keyString) === -1) {
        this.unsortedRoots.push(commit);
      }
    }, this);
  };

  /**
   * store the given state under a fresh commit as the root of a new tree
   *
   * @param state
   *          the string to save
   * @return the associated root commit
   */
  TimeMachineModel.prototype.init = function(state, name) {
    this.commit.set(CommitModel.createRoot(state, name || Presets.target));

    this.emit('init', this.commit.get());

    this.updateRoots();

    return this.commit.get();
  };

  /**
   * stores the given state under a new commit, which is a descendant of the
   * active commit
   *
   * @param state
   *          the string to save
   * @param parentKey
   *          the key of any parent in the same tree
   *
   * @return the generated key
   */
  TimeMachineModel.prototype.save = function(state) {
    if (this.commit.get() && this.commit.get().isValid()) {
      if (state === this.commit.get().load()) {
        return this.commit.get(); // no change in data. Nothing to save here.
      }
      this.commit.set(this.commit.get().createChild(state));
    } else {
      this.commit.set(undefined);
      return undefined;
    }

    this.emit('save', this.commit.get());

    return this.commit.get();
  };

  /**
   * load another commit from localStorage
   *
   * @param commit
   *          a CommitModel instance to load
   * @return undefined on load error, the localStorage content otherwise
   *         (serialized save state)
   */
  TimeMachineModel.prototype.load = function(commit) {
    var data;

    if (commit === undefined && this.isInitialized()) {
      return this.commit.get().load();
    }

    this.unload();

    if (!(commit instanceof CommitModel) || !commit.isValid()) {
      return undefined;
    }

    data = commit.load();
    if (data) {
      this.commit.set(commit);
      this.emit('load', data);
    }
    return data;
  };

  /**
   * resets the currently active commit.
   */
  TimeMachineModel.prototype.unload = function() {
    this.commit.set(undefined);
    this.emit('unload');
  };

  TimeMachineModel.prototype.getOrphans = function() {
    var query, orphanedCommits;

    /*
     * check all localStorage keys
     */
    query = new Query(Query.ALLKEYS);
    orphanedCommits = query.filter().map(function(keyString) {
      return new CommitModel(keyString);
    }).filter(function(commit) {
      return !commit.isValid();
    });

    /*
     * check all reflog entries
     */
    orphanedCommits = orphanedCommits.concat(RefLog.getAllKeys().map(
        function(key) {
          return new CommitModel(key);
        }).filter(function(commit) {
      return !commit.isValid();
    }));

    return orphanedCommits.sort(CommitModel.sortFunction);
  };

  TimeMachineModel.prototype.isInitialized = function() {
    return !!this.commit.get();
  };

  TimeMachineModel.prototype.isActive = function(commit) {
    return !!this.commit.get() && !!commit
        && this.commit.get().key.isEqual(commit.key);
  };

  TimeMachineModel.prototype.isRelatedToActive = function(commit) {
    return !!this.commit.get() && !!commit
        && this.commit.get().key.isRelated(commit.key);
  };

  /**
   * get the used amount of localStorage, in unicode symbols, which is used by
   * the tree associated with the commit
   *
   * @param commit
   *          any commit of the tree to investigate
   * @return the size in the localStorage, in unicode symbols.
   */
  TimeMachineModel.prototype.usedRelatedStorage = function(commit) {
    var total, query;

    total = 0;
    query = new Query(commit.key);

    query.filter().forEach(function(key) {
      var data;
      if (window.localStorage) {
        data = window.localStorage[key] || '';
      } else {
        data = '';
      }
      total += data.length;
    });

    return total;
  };

  /**
   * Calculate the size of each target in the localStorage.
   *
   * @return an object, where object[target] == size for each of the currently
   *         stored targets, and where object.total is the total of all targets
   */
  TimeMachineModel.prototype.usedStorage = function() {
    var tuveroQuery, keys, targetSizes, total;

    targetSizes = {};

    tuveroQuery = new Query(Query.ALLTUVEROKEYS);
    tuveroQuery.filter().forEach(function(key) {
      var target, data;

      target = key.split('_')[0];
      if (window.localStorage) {
        data = window.localStorage[key] || '';
      } else {
        data = '';
      }

      targetSizes[target] = (targetSizes[target] || 0) + data.length;
    });

    total = 0;
    if (window.localStorage) {
      Object.keys(targetSizes).forEach(
          function(target) {
            targetSizes[target] += (window.localStorage[RefLog
                .formatTargetKey(target)] || '').length;
            total += targetSizes[target];
          });
    }
    targetSizes.total = total;

    return targetSizes;
  };

  /**
   * Removes all keys until keepNum keys are left, excluding the root and the
   * latest key, starting with the oldest key.
   *
   * Example: If you want to keep the root, latest and the key before the latest
   * key
   *
   * @param relatedCommit
   *          any commit within the tree. Required!
   * @param keepNum
   *          the number of commits to keep, excluding root and latest
   */
  TimeMachineModel.prototype.cleanup = function(relatedCommit, keepNum) {
    var query, relatedKeys;

    if (!(relatedCommit instanceof CommitModel) || !relatedCommit.isValid()) {
      return;
    }

    query = new Query(relatedCommit.key);
    relatedKeys = query.filter();

    relatedKeys.shift(); // don't delete the root key
    relatedKeys.pop(); // don't delete the latest key

    while (relatedKeys.length > keepNum) {
      (new CommitModel(relatedKeys.shift())).remove();
    }

    this.emit('cleanup', relatedCommit);
  };

  /**
   * update this.roots whenever a root is deleted (which is performed via a
   * function of the CommitModel API)
   *
   * @param event ==
   *          'remove'
   * @param emitter ==
   *          this.rootsCollector
   * @param data
   *          {source: removed_commit}
   */
  TimeMachineModel.prototype.onremove = function(event, emitter, data) {
    if (data.source.isRoot()) {
      var index = this.unsortedRoots.indexOf(data.source);
      this.unsortedRoots.get(index).destroy();
      this.unsortedRoots.remove(index);
    }
  };

  TimeMachineModel.prototype.onrefresh = function(event, emitter, data) {
    this.updateRoots();
  };

  TimeMachine = new TimeMachineModel();
  return TimeMachine;
});

/**
 * A AttributeValueView, which updates the value of ValueModel to the DOM
 *
 * @return AttributeValueView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/attributevalueview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance, which implements get() and emits update
   * @param $view
   *          the associated DOM element
   */
  function AttributeValueView(model, $view, attribute) {
    AttributeValueView.superconstructor.call(this, model, $view);

    this.attribute = attribute;

    this.update();
  }
  extend(AttributeValueView, View);

  /**
   * write the contents of get() to the DOM
   */
  AttributeValueView.prototype.update = function() {
    this.$view.attr(this.attribute, this.model.get());
  };

  /**
   * Callback listener
   */
  AttributeValueView.prototype.onupdate = function() {
    this.update();
  };

  return AttributeValueView;
});

/**
 * A Toast is a small text which is visible for a short period of time before
 * disappearing.
 *
 * You can supply a jquery object handle as str if you want to insert an html
 * node instead of text.
 *
 * Toast duration can be set at Toast construction or controlled via a close()
 * function
 *
 * @return Toast
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/toast',['jquery', 'core/type'], function($, Type) {
  var initialized, pending;

  // pending toasts which have been issued before jquery was available
  initialized = false;
  pending = [];

  /**
   * read the transition durations
   */
  function getTransitionDuration() {
    var transition;

    transition = Toast.$template.css('transition');

    if (transition === undefined) {
      console.error('could not read any transition lengths. '
          + "What's your browser?");
      return 0.2;
    }

    // return duration
    return Number(transition.replace(/^[^0-9]*([0-9.]+)s.*$/, '$1'));
  }

  /**
   * toast constructor
   *
   * @param str
   *          the string of the toast
   * @param seconds
   *          Toast duration in seconds. See Toast.SHORT, Toast.LONG and
   *          Toast.INFINITE. Defaults to Toast.SHORT.
   */
  function Toast(message, seconds) {
    this.message = message;
    this.duration = seconds || Toast.SHORT;

    this.$toast = undefined;

    if (initialized) {
      this.display();
    } else {
      pending.push(this);
    }
  }

  Toast.fadeinDuration = 0.2;
  Toast.fadeoutDuration = 0.2;
  Toast.$container = undefined;
  Toast.$template = undefined;

  /**
   * display a toast
   */
  Toast.prototype.display = function() {
    var $toast;

    if (!initialized) {
      console.error('Cannot display Toast: '
          + 'Toast.init() has not been called yet.');
      return;
    }

    if (this.$toast) {
      console.error('toast is already visible');
      return;
    }

    $toast = this.$toast = Toast.$template.clone().removeClass('hidden');

    // decide between text and jquery object handle
    if (Type.isString(this.message)) {
      this.$toast.text(this.message);
    } else {
      this.$toast.append(this.message);
    }

    // insert the toast and a line break
    Toast.$container.append(this.$toast);
    Toast.$container.append('<br>');

    // let the toast fade in
    window.setTimeout(function() {
      $toast.addClass('toast');
    }, 10);

    // Let the toast fade out if it's not infinite
    if (this.duration > 0) {
      window.setTimeout(this.close.bind(this),
          1000 * (this.duration + Toast.fadeinDuration));
      $toast.addClass('temporary');
    } else {
      $toast.addClass('infinite');
    }
  };

  /**
   * create a function which closes the toast
   *
   * @param id
   *          the toast id
   * @return a close function
   */
  Toast.prototype.close = function() {
    var i, $alltoasts, $toast;

    if (initialized && this.$toast) {
      $toast = this.$toast;

      // let the toast fade out
      $toast.removeClass('toast');

      // remove the toast after fadeout
      window.setTimeout(function() {
        $toast.next().remove();
        $toast.remove();
      }, 1000 * Toast.fadeoutDuration);

      // forbid the close function from fading out a second time
      this.$toast = undefined;
    } else if (pending && pending.indexOf(this) !== -1) {
      pending.splice(pending.indexOf(this), 1);
    }
  };

  /**
   * initialize the toast. This function has to be called explicitly, or the
   * unit tests show toasts for every error.
   */
  Toast.init = function() {
    var transition, duration, id;
    // create toast container
    Toast.$container = $('<div id="toasts">');
    Toast.$template = $('<div class="hidden">ERROR</div>');
    Toast.$container.append(Toast.$template);
    $('body').append(Toast.$container);

    // abort if the style is not set
    if ($('#toasts').css('position') !== 'fixed') {
      console.error('Toast: stylesheet not found. Initialization failed.');
    } else {
      Toast.fadeoutDuration = getTransitionDuration();
      Toast.$template.addClass('toast');
      Toast.fadeinDuration = getTransitionDuration();

      if (Toast.fadeinDuration != Number(Toast.fadeinDuration)
          || !isFinite(Toast.fadeinDuration) || isNaN(Toast.fadeinDuration)) {
        console.error('Toast.fadeinDuration: not a valid number: '
            + Toast.fadeinDuration);
        Toast.$template.removeClass('hidden');
      }

      if (Toast.fadeoutDuration != Number(Toast.fadeoutDuration)
          || !isFinite(Toast.fadeoutDuration) || isNaN(Toast.fadeoutDuration)) {
        console.error('Toast.fadeoutDuration: not a valid number: '
            + Toast.fadeoutDuration);
        Toast.$template.removeClass('hidden');
      }
    }

    initialized = true;

    // issue any pending toasts
    pending.forEach(function(toast) {
      toast.display();
    }, this);

    pending = undefined;
  };

  Toast.closeTemporaryToasts = function() {
    Toast.$container.find('.toast.temporary').map(function() {
      var $toast = $(this);
      $toast.next().hide();
      $toast.hide();
    });
  };

  Toast.SHORT = 2;
  Toast.LONG = 5;
  Toast.INFINITE = -1;

  // remember: return by reference. The new function will replace the old
  // one
  return Toast;
});

/**
 * No Description
 *
 * @return LocalString
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('strings',[],function() {
  return {
    teamsicon: 'teams2',
    variant: 'Test'
  };
});

/**
 * Strings for Toasts, headers, default contents and whatever you can think of.
 *
 * TODO (in the reference:) show where and how each string is used
 *
 * @return Strings
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/strings',['strings'], function(LocalStrings) {
  var Strings;

  Strings = {
    autosaveoff: 'Automatisches  Speichern aus',
    autosaveon: 'Automatisches Speichern an',
    autoupdateoff: 'Automatische Aktualisierung aus',
    autoupdateon: 'Automatische Aktualisierung an',
    clearstorage: 'Wirklich alle Turniere löschen?',
    confirmtreeremoval: 'Das Turnier "%s" wirklich löschen?',
    confirmactivetreeremoval: 'Das laufende Turnier "%s" wirklich löschen?',
    confirmleave: 'Fenster schließen, ohne das Turnier zu speichern?',
    upvote: '▲',
    downvote: '▼',
    byevote: '∅',
    byename: 'Freilos',
    byeid: '∅',
    onlyonefile: 'Zu viele Dateien. Bitte nur eine Datei laden',
    nofiles: 'Keine Dateien ausgewählt',
    fileabort: 'Lesen abgebrochen',
    fileerror: 'Lesefehler',
    filenotfound: 'Datei wurde nicht gefunden',
    filenotreadable: 'Datei ist nicht lesbar',
    gamefinished: 'Spiel beendet',
    invalidresult: 'Ungültiges Ergebnis',
    loaded: 'Turnier geladen',
    loadfailed: 'Ladevorgang fehlgeschlagen!',
    newtournament: 'Neues Turnier begonnen',
    notournament: 'Noch kein Turnier gestartet',
    notimplemented: 'Funktion noch nicht verfügbar',
    pageload: 'Seite geladen',
    pointchangeaborted: 'Änderung verworfen',
    pointchangeapplied: 'Änderung gespeichert',
    toolatetournamentfinished: 'Neues Ergebnis beeinflusst Folgerunden nicht!',
    rankingupdate: 'Ranking wurde berechnet',
    roundfailed: 'Auslosung fehlgeschlagen',
    roundfinished: '%s. Runde abgeschlossen',
    roundstarted: '%s. Runde ausgelost',
    roundrunning: 'Runde %s läuft',
    registrationclosed: 'Registrierung geschlossen',
    saved: 'gespeichert',
    savefailed: 'Speichern fehlgeschlagen',
    exportfailed: 'Export fehlgeschlagen',
    startfailed: 'Auslosung fehlgeschlagen. Zu wenige Teams?',
    teamadded: 'Team %s registriert',
    notenoughteams: 'Zu wenige Teams',
    teamtext: 'Spieler',
    teamstext: 'Spieler',
    namechanged: 'Umbenannt: %s',
    namechangeaborted: 'Name verworfen',
    teamsnotempty: 'Teilnehmer wurden schon eingetragen',
    emptyname: 'N.N.',
    differentteamsizes: 'Teams haben unterschiedliche Größe',
    invalidteamsize: 'Unzulässige Spielerzahl pro Team',
    alltabsreloaded: 'Alle Tabs neu geladen',
    modsvariableadded: 'window.mods erstellt',
    tournamentfinished: 'Turnier beendet',
    autocompleteloaded: 'Namensvorschläge geladen',
    autocompletereloadfailed: 'Konnte Namensvorschläge nicht laden',
    fileempty: 'Datei ist leer',
    teamdeleted: 'Anmeldung %s gelöscht',
    deleteallteamsconfirmation: 'Wirklich alle Anmeldungen löschen?',
    nofilereader: 'Dieser Browser kann keine Speicherstände laden!',
    nojson: 'Dieser Browser kann keine Speicherstände erstellen!',
    nostorage: 'Dieser Browser kann keine Spielstände speichern!',
    updatedownloading: 'Neue Version wird geladen...',
    updatefailed: 'Fehler beim Download der neuen Version',
    updateavailable: 'Neu laden für neue Version',
    dev: 'Entwicklerversion',
    rc: 'Versionsvorschau',
    reset: 'Gespeicherte Daten gelöscht',
    defaultnameswiss: 'Schweizer System',
    defaultnameko: 'KO-Turnier',
    defaultnamepoule: 'Poule-System',
    defaultnameround: 'Rundenturnier',
    defaultnamesupermelee: 'Supermelee',
    offlineconfirmexit: 'Tuvero ist gerade nicht offline verfügbar. Beenden?',
    winstatustrue: 'S',
    winstatusfalse: 'N',
    winstatusundefined: '',
    nomanifest: 'Offline-Modus deaktiviert',
    tournamentalreadyfinished: 'Turnier ist schon beendet',
    gamesstillrunning: 'Es gibt noch offene Spiele',
    tournamentstarted: 'Turnier gestartet',
    tabupdateerror: 'Fehler bei Aktualisierung vom %s-Tab',
    tab_teams: 'Mannschaften',
    tab_new: 'Turniersysteme',
    tab_games: 'Laufende Spiele',
    tab_ranking: 'Platzierungen',
    tab_history: 'Spielverlauf',
    tab_debug: 'Debugging Console',
    tab_settings: 'Optionen und Einstellungen',
    tab_about: 'Über...',
    nodata: 'Keine Daten',
    svgns: 'http://www.w3.org/2000/svg',
    firstplace: '1. Platz',
    thirdplace: '3. Platz',
    ranking_numgames: 'Spiele',
    ranking_wins: 'Siege',
    ranking_points: 'Kleine Punkte',
    ranking_lostpoints: 'Gegnerpunkte',
    ranking_saldo: 'Saldo-Punkte',
    ranking_buchholz: 'Buchholz-Punkte',
    ranking_finebuchholz: 'Feinbuchholz-Punkte',
    ranking_sonneborn: 'Sonneborn-Berger-Zahl',
    ranking_id: 'Startnummer',
    ranking_ko: 'KO-Wertung',
    ranking_headtohead: 'Direkter Vergleich',
    ranking_tac: 'TAC-Punkte',
    ranking_votes: 'Lose (nur Anzeige)',
    ranking_ranks: 'Platz',
    ranking_short_numgames: 'Sp.',
    ranking_short_wins: 'S',
    ranking_short_points: 'P',
    ranking_short_lostpoints: 'GP',
    ranking_short_saldo: 'SP',
    ranking_short_buchholz: 'BH',
    ranking_short_finebuchholz: 'FBH',
    ranking_short_sonneborn: 'SB',
    ranking_short_id: 'No.',
    ranking_short_ko: 'KO',
    ranking_short_headtohead: 'VGL',
    ranking_short_tac: 'TAC',
    ranking_short_votes: 'L',
    ranking_short_ranks: 'Pl.',
    ranking_medium_numgames: 'Spiele',
    ranking_medium_wins: 'Siege',
    ranking_medium_points: 'Punkte',
    ranking_medium_lostpoints: 'Gegnerpunkte',
    ranking_medium_saldo: 'Saldo',
    ranking_medium_buchholz: 'Buchholz',
    ranking_medium_finebuchholz: 'Feinbuchholz',
    ranking_medium_sonneborn: 'SB-Zahl',
    ranking_medium_id: 'Startnummer',
    ranking_medium_ko: 'KO-Wertung',
    ranking_medium_headtohead: 'Vergleich',
    ranking_medium_tac: 'TAC',
    ranking_medium_votes: 'Lose',
    ranking_medium_ranks: 'Platz',
    tournamenterrorprefix: 'Turnierfehler',
    oldsaveformat: 'Fehler beim Umwandeln eines alten 1.4-Speicherstandes',
    tournament_initial: 'Unterturnier erstellt',
    tournament_running: 'Runde gestartet',
    tournament_idle: 'Runde beendet',
    tournament_finished: 'Unterturnier beendet',
    namechangeprompt: 'Neuen Namen eingeben',
    teamdeleteprompt: 'Zum Löschen Team anklicken',
    csvheader_teams: 'No.,Name',
    csvheader_history: 'Runde,Spielno.,"No. 1","No. 2","Punkte 1","Punkte 2"',
    csvheader_ranking: 'Platz,No.',
    popout_adblocked: 'Ein Werbeblocker verhindert das Öffnen eines Fensters',
    display_error: 'Anzeigefehler. Bitte neu laden.'
  };

  Object.keys(LocalStrings).forEach(function(key) {
    Strings[key] = LocalStrings[key];
  });

  return Strings;
});

/**
 * AutocompletionModel
 *
 * @return AutocompletionModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/autocompletionmodel',['lib/extend', 'core/model', 'jquery', 'core/type', './toast',
    'presets', './strings'], function(extend, Model, $, Type, Toast, Presets,
    Strings) {
  /**
   * Constructor
   */
  function AutocompletionModel() {
    AutocompletionModel.superconstructor.call(this);

    this.names = [];
  }
  extend(AutocompletionModel, Model);

  AutocompletionModel.prototype.EVENTS = {
    clear: true,
    update: true
  };

  AutocompletionModel.prototype.download = function(url) {
    var autocomplete = this;

    if (!url) {
      return;
    }

    $.get(url, undefined, function(jsontext, status, response) {
      autocomplete.parse(jsontext);
    }, 'text').fail(
        function() {
          console.error('could not read ' + Presets.names.playernameurl
              + '. Is this a local installation?');
          new Toast(Strings.autocompletereloadfailed, Toast.LONG);
        });
  };

  AutocompletionModel.prototype.parse = function(text) {
    var names;

    if (text.length === 0) {
      new Toast(Strings.fileempty);
    } else {
      try {
        names = JSON.parse(text);

        this.set(names);

        new Toast(Strings.autocompleteloaded);
      } catch (err) {
        console.error(err.stack);
        this.clear();
        new Toast(Strings.autocompletereloadfailed, Toast.LONG);
      }
    }
  };

  AutocompletionModel.prototype.set = function(names) {
    if (!Type.isArray(names)) {
      throw new Error('names is not an array');
    }

    this.clear();

    this.names = names.map(function(name) {
      return name.trim();
    });

    this.emit('update');
  };

  AutocompletionModel.prototype.clear = function() {
    this.names = [];
    this.emit('clear');
  };

  AutocompletionModel.prototype.save = function() {
    var data = AutocompletionModel.superclass.save.call(this);

    data.names = this.names.slice();

    return data;
  };

  AutocompletionModel.prototype.restore = function(data) {
    if (!AutocompletionModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.set(data.names.slice());

    this.emit('update');

    return true;
  };

  AutocompletionModel.prototype.SAVEFORMAT = Object
      .create(AutocompletionModel.superclass.SAVEFORMAT);
  AutocompletionModel.prototype.SAVEFORMAT.names = [String];

  return AutocompletionModel;
});

/**
 * AutocompletionView
 *
 * @return AutocompletionView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/autocompletionview',['lib/extend', 'core/view', 'lib/typeahead'], function(extend, View,
    typeahead) {
  /**
   * Constructor
   */
  function AutocompletionView(model, $view) {
    AutocompletionView.superconstructor.call(this, model, $view);

    this.update();
  }
  extend(AutocompletionView, View);

  AutocompletionView.prototype.update = function() {
    var states;

    this.reset();

    if (!this.$view.typeahead) {
      return;
    }

    if (this.model.names.length === 0) {
      return;
    }

    states = new Bloodhound({
      datumTokenizer: Bloodhound.tokenizers.obj.whitespace('val'),
      queryTokenizer: Bloodhound.tokenizers.whitespace,
      local: this.model.names.map(this.stringToBloodhoundObject)
    });

    states.initialize();

    this.$view.typeahead({
      hint: true,
      highlight: true,
      minLength: 1
    }, {
      name: 'names',
      displayKey: 'val',
      source: states.ttAdapter()
    });
  };

  AutocompletionView.prototype.onupdate = function() {
    this.update();
  };

  AutocompletionView.prototype.onclear = function() {
    if (!this.$view.typeahead) {
      return;
    }
    this.$view.typeahead('val', '');
  };

  AutocompletionView.prototype.reset = function() {
    if (!this.$view.typeahead) {
      return;
    }
    this.$view.typeahead('destroy');
  };

  AutocompletionView.prototype.stringToBloodhoundObject = function(string) {
    return {
      val: string
    };
  };

  AutocompletionView.prototype.destroy = function() {
    AutocompletionView.superclass.destroy.call(this);

    this.reset();
  };

  return AutocompletionView;
});

/**
 * automatically destroy the which have been removed from a list
 *
 * @return ListCleanupListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/listcleanuplistener',['lib/extend', 'core/listener'], function(extend, Listener) {

  /**
   * Constructor
   *
   * @param listmodel
   *          the ListModel instance
   */
  function ListCleanupListener(listmodel) {
    ListCleanupListener.superconstructor.call(this, listmodel);
  }
  extend(ListCleanupListener, Listener);

  /**
   * Callback function, which destroys removed objects
   */

  ListCleanupListener.prototype.onremove = function(emitter, event, data) {
    if (!data) {
      console.warn('ListCleanupListener: no data object emitted');
      return;
    }
    if (!data.object) {
      console.warn('ListCleanupListener: data contains no object property');
      return;
    }
    if (!data.object.destroy) {
      console.warn('ListCleanupListener: data.object has no destroy method');
      return;
    }

    data.object.destroy();
  };

  return ListCleanupListener;
});

/**
 * A Model for each single Player
 *
 * @return PlayerModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/playermodel',['lib/extend', 'core/model'], function(extend, Model) {

  /**
   * remove extra white spaces from a player name
   *
   * @param name
   *          the name
   * @return a trimmed version of the name
   */
  function trimName(name) {
    return name.trim().replace(/\s+/g, ' ');
  }

  /**
   * Constructor
   *
   * @param name
   *          the player name
   */
  function PlayerModel(name) {
    PlayerModel.superconstructor.call(this);
    this.name = PlayerModel.NONAME;
    this.setName(name);
  }
  extend(PlayerModel, Model);
  PlayerModel.NONAME = 'noname';

  /**
   * retrieve a copy of the player name
   *
   * @return a copy of the player name
   */
  PlayerModel.prototype.getName = function() {
    return this.name.slice(0);
  };

  /**
   * change the player name. Invalid player names (empty or whitespace only)
   * will be ignored
   *
   * @param name
   *          the new name
   */
  PlayerModel.prototype.setName = function(name) {
    name = trimName(name || '');
    if (name && name != this.name) {
      this.name = name;
      this.emit('update');
    }
  };

  PlayerModel.prototype.SAVEFORMAT = Object
      .create(PlayerModel.superclass.SAVEFORMAT);
  PlayerModel.prototype.SAVEFORMAT.n = String;

  /**
   * prepares a serializable data object, which can later be used for restoring
   * the current state using the restore() function
   *
   * @return a serializable data object, which can be used for restoring
   */
  PlayerModel.prototype.save = function() {
    var data = PlayerModel.superclass.save.call(this);

    data.n = this.name;

    return data;
  };

  /**
   * restore a previously saved state from a serializable data object
   *
   * @param data
   *          a data object, that was previously written by save()
   * @return true on success, false otherwise
   */
  PlayerModel.prototype.restore = function(data) {
    if (!PlayerModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.setName(data.n);

    return true;
  };

  return PlayerModel;
});

/**
 * A combination of players is a team. A team should contain at least one player *
 *
 * @return TeamModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/teammodel',['lib/extend', 'core/indexedmodel', './playermodel'], function(extend,
    IndexedModel, PlayerModel) {

  /**
   * Constructor
   *
   * @param players
   *          an array of PlayerModel instances
   * @param id
   *          a preferably unique numeric team id
   */
  function TeamModel(players, id) {
    TeamModel.superconstructor.call(this, id);

    this.setPlayers(players);
  }
  extend(TeamModel, IndexedModel);

  /**
   * .length represents the size of the team
   */
  TeamModel.prototype.length = 0;

  /**
   * retrieve a single player. For the number of players, see
   * TeamModel.prototype.length
   *
   * @param id
   *          the index of the player inside the team
   * @return a PlayerModel reference
   */
  TeamModel.prototype.getPlayer = function(id) {
    if (id >= 0 && id < this.length) {
      return this.players[id];
    }
    return undefined;
  };

  /**
   * DO NOT USE DIRECTLY (why not?)
   *
   * @param players
   *          an array of PlayerModel instances
   */
  TeamModel.prototype.setPlayers = function(players) {
    players = players || [];
    if (players.length === 0) {
      players.push(new PlayerModel());
    }
    this.length = players.length;
    this.players = players.slice(0);
    this.players.forEach(function(player) {
      player.registerListener(this);
    }, this);
  };

  /**
   * Callback listener
   *
   * One of the player names was updated. This is passed through to the team
   * event emitter.
   *
   * @param emitter
   *          a PlayerModel instance
   * @param event
   *          the event type
   *
   */
  TeamModel.prototype.onupdate = function(emitter, event) {
    var data;
    data = {
      id: this.players.indexOf(emitter)
    };
    this.emit('update', data);
  };

  TeamModel.prototype.SAVEFORMAT = Object
      .create(TeamModel.superclass.SAVEFORMAT);
  TeamModel.prototype.SAVEFORMAT.p = [Object];

  /**
   * prepares a serializable data object, which can later be used for restoring
   * the current state using the restore() function
   *
   * @return a serializable data object, which can be used for restoring
   */
  TeamModel.prototype.save = function() {
    var data = TeamModel.superclass.save.call(this);

    data.p = this.players.map(function(player) {
      return player.save();
    });

    return data;
  };

  /**
   * restore a previously saved state from a serializable data object
   *
   * @param data
   *          a data object, that was previously written by save()
   * @return true on success, false otherwise
   */
  TeamModel.prototype.restore = function(data) {
    if (!TeamModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.setPlayers(data.p.map(function(player) {
      var p = new PlayerModel();
      p.restore(player);
      return p;
    }));

    return true;
  };

  return TeamModel;
});

/**
 * A class for collecting all necessary state information of one or more running
 * tournaments.
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/statemodel',['lib/extend', 'core/model', 'core/indexedlistmodel', 'core/valuemodel',
    './listcleanuplistener', 'core/tournamentlistmodel', 'options', 'presets',
    './teammodel', 'core/listener'], function(extend, Model, IndexedListModel,
    ValueModel, ListCleanupListener, TournamentListModel, Options, Presets,
    TeamModel, Listener) {

  /**
   * Constructor
   */
  function StateModel() {
    StateModel.superconstructor.call(this);
    // actual state
    this.teams = new IndexedListModel();
    this.teamsize = new ValueModel(3);
    this.tournaments = new TournamentListModel();

    function tabOptionPreset(name, defaultValue) {
      if (!Presets.taboptions || Presets.taboptions[name] === undefined) {
        return new ValueModel(defaultValue);
      }

      // cast to bool, just in case.
      return new ValueModel(!!Presets.taboptions[name]);
    }

    this.tabOptions = {
      showNames: tabOptionPreset('shownames', true),
      nameMaxWidth: tabOptionPreset('namemaxwidth', true),
      teamTable: tabOptionPreset('teamtable', true),
      rankingAbbreviations: tabOptionPreset('rankingabbreviations', false),
      showMatchTables: tabOptionPreset('showmatchtables', false),
      hideFinishedGroups: tabOptionPreset('hidefinishedgroups', false)
    };

    this.initCleanupListeners();

    Listener.bind(this, 'error', function(emitter, event, message) {
      console.error(message);
    });
  }
  extend(StateModel, Model);

  StateModel.prototype.EVENTS = {
    error: true,
    clear: true
  };

  /**
   * whenever an element is removed from those central and elemental lists, call
   * its destroy() function
   */
  StateModel.prototype.initCleanupListeners = function() {
    this.teamscleanuplistener = new ListCleanupListener(this.teams);
    this.tournamentscleanuplistener = new ListCleanupListener(//
    this.tournaments);
  };

  /**
   * reset the state of everything
   */
  StateModel.prototype.clear = function() {
    this.tournaments.clear();
    this.teams.clear();
    Options.reset();
    this.emit('clear');
    // this.teamsize.set(3); // TODO read default team size from options
  };

  StateModel.prototype.SAVEFORMAT = Object
      .create(StateModel.superclass.SAVEFORMAT);
  StateModel.prototype.SAVEFORMAT.options = Object;
  StateModel.prototype.SAVEFORMAT.teams = [Object];
  StateModel.prototype.SAVEFORMAT.teamsize = Number;
  StateModel.prototype.SAVEFORMAT.tournaments = Object;
  StateModel.prototype.SAVEFORMAT.target = String; // e.g. 'tac', 'boule', ...
  StateModel.prototype.SAVEFORMAT.version = String; // e.g. '1.5.0'

  /**
   * prepares a serializable data object, which can later be used for restoring
   * the current state using the restore() function
   *
   * @return a serializable data object, which can be used for restoring
   */
  StateModel.prototype.save = function() {
    var data = StateModel.superclass.save.call(this);

    data.teams = this.teams.save();
    data.teamsize = this.teamsize.get();
    data.tournaments = this.tournaments.save();
    data.options = JSON.parse(Options.toBlob());

    // TODO read from DOM or something
    data.version = '1.5.0-dev';

    // TODO read from DOM or something
    data.target = Presets.target;

    return data;
  };

  /**
   * restore a previously saved state from a serializable data object
   *
   * @param data
   *          a data object, that was previously written by save()
   * @return true on success, false otherwise
   */
  StateModel.prototype.restore = function(data) {
    if (!StateModel.superclass.restore.call(this, data)) {
      this.emit('Wrong data format');
      return false;
    }

    if (Presets.target !== data.target) {
      // TODO somehow send a toast
      this.emit('error', 'Wrong target: ' + data.target + ', expected: '
          + Presets.target);
      return false;
    }

    // TODO perform a version check

    this.clear();

    Options.fromBlob(JSON.stringify(data.options));
    this.teamsize.set(data.teamsize);

    if (!this.teams.restore(data.teams, TeamModel)) {
      this.emit('error', 'error: cannot restore State.teams');
      return false;
    }

    if (!this.tournaments.restore(data.tournaments)) {
      this.emit('error', 'error: cannot restore State.tournaments');
      return false;
    }

    return true;
  };

  return StateModel;
});

/**
 * Create a StateModel singleton
 *
 * Note to self: Avoid DOM manipulations at all costs!
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/state',['ui/statemodel'], function(StateModel) {
  var State;

  State = new StateModel();

  return State;
});

/**
 * LegacyLoaderModel
 *
 * @return LegacyLoaderModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/legacyloadermodel',['lib/extend', 'core/model', 'ui/state', './teammodel',
    './playermodel', 'options', 'presets', 'core/tournamentindex',
    'core/matchmodel', 'core/matchresult', 'core/byeresult',
    'core/correctionmodel', './toast', 'core/rle'], function(extend, Model,
    State, TeamModel, PlayerModel, Options, Presets, TournamentIndex,
    MatchModel, MatchResult, ByeResult, CorrectionModel, Toast, RLE) {
  /**
   * Constructor
   */
  function LegacyLoaderModel() {
    LegacyLoaderModel.superconstructor.call(this);
  }
  extend(LegacyLoaderModel, Model);

  LegacyLoaderModel.prototype.load = function(glob) {
    var tournamentDataArray, tournamentRankingArray;

    State.clear();

    console.log('starting conversion');

    tournamentDataArray = [];
    tournamentRankingArray = [];

    /*
     * Options
     */
    this.loadOptions(glob.options);

    /*
     * Teams
     */
    this.loadTeams(glob.team);

    /*
     * Tournaments
     */
    this.loadTournaments(glob.tournaments, tournamentDataArray,
        tournamentRankingArray);

    /*
     * History
     */
    this.loadHistory(glob.history, tournamentDataArray);

    /*
     * Votes
     */
    this.loadVotes(tournamentDataArray, tournamentRankingArray);

    /*
     * additional missing objects, e.g. placeholder matches
     */
    this.createMissingObjects();
    console.log('conversion to format 1.5.0 successful');

    return true;
  };

  LegacyLoaderModel.prototype.loadTeams = function(blob) {
    var teams;

    console.log('converting teams');

    teams = JSON.parse(blob);

    teams.forEach(function(teamData) {
      var players, team;

      players = teamData.names.map(function(playername) {
        return new PlayerModel(playername);
      });

      team = new TeamModel(players);

      State.teams.push(team);

      console.log('converting team ' + team.getID() + ': '
          + teamData.names.join(', '));
    });

    console.log('conversion finished: ' + State.teams.length
        + ' teams converted');
  };

  LegacyLoaderModel.prototype.loadOptions = function(blob) {
    var optionsData;

    optionsData = JSON.parse(blob);
    if (optionsData.savefile === undefined) {
      if (Presets.target !== 'boule') {
        new Toast('cannot load pre-1.4 saves with this target: '
            + Presets.target, Toast.LONG);
        throw new Error('cannot load pre-1.4 saves with this target: '
            + Presets.target);
      }
    } else {
      if (optionsData.savefile !== Presets.target + '.json') {
        new Toast('cannot convert '
            + optionsData.savefile.replace(/.json$/, '') + ' to '
            + Presets.target, Toast.LONG);
        throw new Error('cannot convert '
            + optionsData.savefile.replace(/.json$/, '') + ' to '
            + Presets.target);
      }
    }

    console.log('converting options');

    Options.fromBlob(blob);

    console.log('converting teamsize');
    State.teamsize.set(Options.teamsize || 1);

    console.log('conversion finished: options');
  };

  LegacyLoaderModel.prototype.loadTournaments = function(blob,
      tournamentDataArray, tournamentRankingArray) {
    var tournaments, parents;

    console.log('converting tournaments');

    tournaments = JSON.parse(blob);
    parents = [];

    subtournamentOffsets = [];

    tournaments.forEach(function(data, tournamentID) {
      var tournament, system, name, blob, teams, ranking, parent, //
      rankingorder, tournamentData, startIndex;

      system = data[0];
      name = data[1];
      blob = data[2];
      teams = data[3];
      ranking = data[4];
      parent = data[5];

      console.log('converting tournament ' + tournamentID + ': ' + name);

      if (blob) {
        tournamentData = JSON.parse(blob);
      } else {
        tournamentData = undefined;
      }

      tournamentDataArray[tournamentID] = tournamentData;
      tournamentRankingArray[tournamentID] = ranking;

      rankingorder = {
        swiss: ['wins', 'buchholz', 'finebuchholz', 'saldo', 'votes'],
        ko: ['ko']
      }[system];

      // create tournament
      tournament = TournamentIndex.createTournament(system, rankingorder);
      if (!tournament) {
        console.error('TOURNAMENT SYSTEM NOT SUPPORTED YET: ' + system);
        return;
      }

      // name and teams
      tournament.getName().set(name);
      teams.forEach(tournament.addTeam.bind(tournament));

      if (tournamentData) {
        // set state
        if (tournamentData.games && tournamentData.games.length > 0) {
          tournament.state.forceState('running');
        } else {
          tournament.state.forceState('initial');
        }

        // set round
        if (system === 'swiss') {
          tournament.round = tournamentData.round - 1;
        } else {
          // no tournament round..
        }

        console.log('converting tournament matches');

        // add matches
        tournamentData.games.forEach(function(data) {
          var teams, match, id, group;

          teams = [data.teams[0][0], data.teams[1][0]];
          id = data.id;

          if (system === 'swiss') {
            group = tournament.round;
          } else {
            group = tournamentData.roundids[teams[0]];
            id += 1;
          }
          match = new MatchModel(teams, id, group);

          console.log('converting match ' + group + ':' + id + ': '
              + teams.join(' vs. '));

          tournament.matches.push(match);
        });

      } else {
        tournament.state.forceState('finished');
      }

      console.log('converted tournament state: ' + tournament.state.get());

      // convert the parent properties to startIndex
      if (parent === undefined || parent === null) {
        startIndex = 0;
      } else {
        console.log("converted tournament's parent: " + parent);
        startIndex = subtournamentOffsets[parent];
        subtournamentOffsets[parent] += tournament.getTeams().length;
      }
      subtournamentOffsets[tournamentID] = startIndex;

      console.log('converted tournament range: ' + startIndex + '-'
          + (startIndex + tournament.getTeams().length));

      // push tournaments. Also sets the ID. Arrays are dense (not sparse)
      State.tournaments.push(tournament, startIndex);

      // close tournament if necessary
      if (!blob) {
        console.log('closing tournament ' + tournamentID);
        State.tournaments.closeTournament(tournamentID);
      }
    });

    console.log('conversion finished: tournaments');
  };

  LegacyLoaderModel.prototype.loadHistory = function(blob, //
  tournamentDataArray) {
    var history = JSON.parse(blob);

    console.log('converting history');

    history.forEach(function(tournamenthistory, tournamentID) {
      var tournament, round, tournamentData, system;

      console.log('converting history for tournament ' + tournamentID);

      tournamentData = tournamentDataArray[tournamentID];
      tournament = State.tournaments.get(tournamentID);
      round = tournament.round;
      system = tournament.SYSTEM;

      function restoreMatchResult(match) {
        var result, teams, score, id, group;

        teams = [match[0], match[1]];
        score = [match[2], match[3]];
        group = match[4];
        id = match[5];

        if (group > round) {
          round = group;
        }

        if (system === 'ko') {
          id += 1;
        }

        teams = teams.map(tournament.teams.indexOf.bind(tournament.teams));

        match = new MatchModel(teams, id, group);
        result = new MatchResult(match, score);

        return result;
      }

      /*
       * Matches
       */
      if (tournamenthistory.games && tournamenthistory.games.length > 0) {
        if (tournament.state.get() === 'initial') {
          tournament.state.forceState('idle');
        }

        tournamenthistory.games.forEach(function(match) {
          var result = restoreMatchResult(match);

          console.log('converting match result ' + result.getID() + ': '
              + result.teams.join(' vs. ') + ':  ' + result.score.join(':'));

          tournament.history.push(result);
          tournament.ranking.result(result);
        });

        console.log('conversion: ' + tournament.history.length
            + ' results converted');

        // TODO restore half-filled KO matches

        // TODO fill in placeholder matches

        if (tournament.SYSTEM === 'swiss' && round > tournament.round) {
          tournament.round = round;
        }
      }

      /*
       * Corrections
       */
      if (tournamenthistory.corrections) {
        tournamenthistory.corrections.forEach(function(correctionData, id) {
          var before, after;

          before = restoreMatchResult(correctionData[0]);
          after = restoreMatchResult(correctionData[1]);

          correction = new CorrectionModel(before, after);

          console.log('converting correction ' + id + ': '
              + before.teams.join(' vs. ') + ': ');

          tournament.corrections.push(correction);
        });
      }

      console.log('conversion finished: ' + tournament.corrections.length
          + ' corrections converted');

      /*
       * Votes
       */
      tournamenthistory.votes.forEach(function(data) {
        var type, teamid, round, vote, id;

        type = data[0];
        teamid = data[1];
        round = data[2];
        id = tournament.getTeams().length >> 1;

        if (type === 0) {
          // bye
          vote = new ByeResult(teamid, [Options.byepointswon,
              Options.byepointslost], id, round);

          console.log('converting bye for team ' + teamid);

          tournament.history.push(vote);
          if (tournament.SYSTEM === 'swiss' //
              && round === tournament.getRound()) {
            tournament.votes.bye.push(teamid);
          }
          tournament.ranking.bye(teamid);
        }
      });
    });

    console.log('conversion finished: history');
  };

  LegacyLoaderModel.prototype.createMissingObjects = function() {
    console.log('conversion: creating missing tournament objects');

    State.tournaments.map(function(tournament) {
      this['createMissingObjects' + tournament.SYSTEM](tournament);
    }, this);

    console.log('conversion finished: missing tournament objects');
  };

  LegacyLoaderModel.prototype.createMissingObjectsko = function(tournament) {
    var teams, lastresults;

    console.log('conversion: creating missing objects for tournament '
        + tournament.getID() + ' (' + tournament.getName().get() + ')');

    console.log('conversion: finding dangling teams');
    tournament.createWaitingMatches();

    console.log('conversion: creating missing ko placeholder matches');
    tournament.createPlaceholderMatches();
  };

  LegacyLoaderModel.prototype.createMissingObjectsswiss = function(tournament) {
    console.log('conversion: no need missing objects for swiss tournament '
        + tournament.getID() + ' (' + tournament.getName().get() + ')');
  };

  LegacyLoaderModel.prototype.loadVotes = function(tournamentDataArray,
      tournamentRankingArray) {

    console.log('converting votes');

    tournamentDataArray.forEach(function(tournamentData, tournamentID) {
      var tournament, system, ranking, upvoteArray, downvoteArray;

      console.log('converting votes of tournament ' + tournamentID);

      tournament = State.tournaments.get(tournamentID);
      ranking = tournamentRankingArray[tournamentID];
      displayOrder = tournament.getRanking().get().displayOrder;

      system = tournament.SYSTEM;

      if (tournamentData) {
        console.log('converting votes from tournament data');

        if (tournamentData.upvote) {
          upvoteArray = RLE.decode(tournamentData.upvote);
        }

        if (tournamentData.downvote) {
          upvoteArray = RLE.decode(tournamentData.downvote);
        }

      } else if (ranking) {
        console.log('converting votes from ranking cache');

        upvoteArray = ranking.upvote;
        downvoteArray = ranking.downvote;

      } else {
        new Toast('tournament ' + tournamentID
            + ' contains neither tournament nor ranking blob', Toast.LONG);
        throw new Error('tournament ' + tournamentID
            + ' contains neither tournament nor ranking blob');
      }

      if (system === 'swiss') {
        if (tournament.ranking.upvotes && upvoteArray) {
          upvoteArray.forEach(function(upvotes, displayID) {
            var teamID = displayOrder[displayID];

            if (upvotes > 0) {
              console.log('converting ' + upvotes + ' upvotes for team '
                  + teamID);

              tournament.ranking.upvotes.set(teamID, tournament.ranking.upvotes
                  .get(teamID)
                  + upvotes);
            }
          });
        }

        if (tournament.ranking.downvotes && downvoteArray) {
          downvoteArray.forEach(function(downvotes, displayID) {
            var teamID = displayOrder[displayID];

            if (downvotes > 0) {
              console.log('converting ' + downvotes + ' downvotes for team '
                  + teamID);

              tournament.ranking.downvotes.set(teamID,
                  tournament.ranking.downvotes.get(teamID) + downvotes);
            }
          });
        }
      }

      console.log('conversion finished: votes of tournament ' + tournamentID);

      console.log('updating the ranking. You know... for safety and stuff.');
      console.log('');
      console.log('ok, I admit it. It is for the upvotes and downvotes.');

      tournament.ranking.emit('recalc');
      tournament.ranking.invalidate();
    });

    console.log('conversion finished: votes');
  };

  return LegacyLoaderModel;
});

/**
 * LegacyStorageKeyConverter: Convert old savestate keys from the localStorage
 * to the new TimeMachine/KeyModel keys
 *
 * @return LegacyStorageKeyConverter
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/legacystoragekeyconverter',['timemachine/commitmodel', 'presets'], function(CommitModel, Presets) {
  var keyRegex = new RegExp('^' + Presets.target + 's?tournament$');

  /**
   * Constructor. Does nothing.
   */
  function LegacyStorageKeyConverter() {
  }

  /**
   * Find all legacy keys in the local storage for the current target and
   * convert them.
   */
  LegacyStorageKeyConverter.prototype.convertAll = function() {
    var allKeys, legacyKeys;

    if (window.localStorage) {
      allKeys = Object.keys(window.localStorage);
    } else {
      allKeys = [];
    }

    legacyKeys = allKeys.filter(keyRegex.test.bind(keyRegex));

    legacyKeys.forEach(this.convert.bind(this));
  };

  /**
   * move a single legacy key to the reflog if it is in the local storage and
   * contains data. No tests are performed for the fitness of the data itself.
   *
   * @param legacyKey
   *          e.g. 'boulestournament' or 'tactournament'
   * @return true on success, false otherwise
   */
  LegacyStorageKeyConverter.prototype.convert = function(legacyKey) {
    var storedString, commit;

    if (!legacyKey) {
      return true;
    }

    if (!window.localStorage) {
      return false;
    }

    storedString = window.localStorage[legacyKey];
    if (!storedString) {
      window.localStorage.removeItem(legacyKey);
      return true;
    }

    commit = CommitModel.createRoot(storedString, 'imported_' + legacyKey);

    if (commit && commit.isValid()) {
      localStorage.removeItem(legacyKey);
      return true;
    }

    return false;
  };

  return LegacyStorageKeyConverter;
});

/**
 * InputView, mainly for automatically resetting a text or file input to an empty state
 *
 * @return InputView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/inputview',['lib/extend', 'core/view'], function(extend, View) {
  /**
   * Constructor
   *
   * @param $view
   *          a DOM input element
   */
  function InputView($view) {
    InputView.superconstructor.call(this, undefined, $view);
  }
  extend(InputView, View);

  /**
   * 'reset' Callback function: set the content of the input field to an empty
   * string
   */
  InputView.prototype.onreset = function() {
    this.$view.val('');
  };

  return InputView;
});

/**
 * FileLoadController
 *
 * @return FileLoadController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/fileloadcontroller',['jquery', 'lib/extend', 'core/controller', 'ui/inputview', './toast',
    './strings'], function($, extend, Controller, InputView, Toast, Strings) {
  /**
   * Constructor. Attention: It doesn't take a View, but a jquery element!
   *
   * @param $button
   *          a button element which, when clicked or drag-dropped, triggers the
   *          file selection/open
   */
  function FileLoadController($button) {
    var controller, view;

    view = new InputView($('<input>').attr('type', 'file'));
    FileLoadController.superconstructor.call(this, view);

    controller = this;
    this.reader = undefined;
    this.file = undefined;

    this.view.$view.change(function(evt) {
      controller.initFileRead(evt.target.files[0]);
    });

    $button.on('dragover', this.buttonDragOver.bind(this));
    $button.on('drop', this.buttonDrop.bind(this));
    $button.click(function() {
      controller.view.$view.click();
    });
  }
  extend(FileLoadController, Controller);

  /*
   * Functions to implement
   */

  /**
   * unread a file, e.g. on file read error. Please overload.
   */
  FileLoadController.prototype.unreadFile = function() {
    console.warn('FileLoadController.unreadfile() called but not overloaded');
  };

  /**
   * Read a file into your model or whatever. Please overload.
   *
   * @param fileContents
   *          the contents of the loaded file
   */
  FileLoadController.prototype.readFile = function(fileContents) {
    console.log(fileContents);
  };

  /*
   * Protected functions. Do not implement.
   */

  /**
   * Drag&Drop event handling: set drag&drop behavior
   *
   * @param evt
   *          the dragover event
   * @return false
   */
  FileLoadController.prototype.buttonDragOver = function(evt) {
    evt.originalEvent.dataTransfer.dropEffect = 'copy';
  };

  /**
   * Handle Drag-Drop events: if there is exactly one file carried, open it.
   * Show error-toasts otherwise.
   *
   * @param evt
   * @return false
   */
  FileLoadController.prototype.buttonDrop = function(evt) {
    var files = evt.originalEvent.dataTransfer.files;

    if (files.length < 1) {
      new Toast(Strings.nofiles, Toast.LONG);
      return;
    } else if (files.length > 1) {
      new Toast(Strings.onlyonefile, Toast.LONG);
      return;
    }

    if (files[0]) {
      this.initFileRead(files[0]);
    } else {
      new Toast(Strings.nofiles, Toast.LONG);
    }
  };

  /**
   * initiate file read after its selection. Applies to drag&drop and click.
   *
   * @param file
   */
  FileLoadController.prototype.initFileRead = function(file) {
    this.file = file;
    this.reader = new FileReader();

    this.reader.onerror = this.loadError.bind(this);
    this.reader.onabort = this.loadAbort.bind(this);
    this.reader.onload = this.loadSuccess.bind(this);

    this.reader.readAsText(this.file);
  };

  /**
   * FileReader callback function for load error. Calls `this.unreadFile()` and
   * shows the cause of the error as a toast
   *
   * @param evt
   */
  FileLoadController.prototype.loadError = function(evt) {
    this.unreadFile();

    switch (evt.target.error.code) {
    case evt.target.error.NOT_FOUND_ERR:
      new Toast(Strings.filenotfound);
      break;
    case evt.target.error.NOT_READABLE_ERR:
      new Toast(Strings.filenotreadable);
      break;
    case evt.target.error.ABORT_ERR:
      break;
    default:
      new Toast(Strings.fileerror, Toast.LONG);
    }

    this.model.emit('reset');
  };

  /**
   * FileReader callback function: load success. Calls this.readFile()
   *
   * @param evt
   */
  FileLoadController.prototype.loadSuccess = function(evt) {
    var blob, Alltabs;

    if (evt.target === this.reader) {
      this.readFile(evt.target.result);
    } else {
      new Toast(Strings.loadfailed, Toast.LONG);
    }

    this.model.emit('reset');
  };

  /**
   * FileReader callback function: loading was aborted (e.g. during file
   * selection)
   */
  FileLoadController.prototype.loadAbort = function() {
    new Toast(Strings.fileabort);
  };

  return FileLoadController;
});

/**
 * UnicodeHelper
 *
 * @return UnicodeHelper
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/unicodehelper',[], function() {
  /**
   * Constructor. Irrelevant, simply helps the code outline viewer of Eclipse
   * recognize the static functions.
   */
  function UnicodeHelper() {
  }

  UnicodeHelper.numutfbytes = function(character) {
    var code;

    code = character.charCodeAt();

    switch (true) {
    case code < 0xC0:
      return 1;
    case code >= 0xC0 && code < 0xE0:
      return 2;
    case code >= 0xE0 && code < 0xF0:
      return 3;
    case code >= 0xF0 && code < 0xF8:
      return 4;
    case code >= 0xF8 && code < 0xFC:
      return 5;
    case code >= 0xFC && code < 0xFE:
      return 6;
    }

    return 0;
  };

  UnicodeHelper.isutf8byte = function(character) {
    var code;

    code = character.charCodeAt();

    return code >= 0x80 && code < 0xC0;
  };

  UnicodeHelper.isutf8codepoint = function(string) {
    var bytes, byteindex;

    bytes = UnicodeHelper.numutfbytes(string[0]);
    if (bytes <= 1) {
      return false;
    }

    for (byteindex = 1; byteindex < bytes; byteindex += 1) {
      if (!UnicodeHelper.isutf8byte(string[byteindex])) {
        return false;
      }
    }

    return true;
  };

  UnicodeHelper.latin2utf8symbol = function(characters) {
    var bytes, symbol, byteindex;

    bytes = UnicodeHelper.numutfbytes(characters[0]);

    symbol = characters[0].charCodeAt();
    switch (bytes) {
    case 1:
      return characters[0];
    case 2:
      symbol = symbol ^ 0xC0;
      break;
    case 3:
      symbol = symbol ^ 0xE0;
      break;
    case 4:
      symbol = symbol ^ 0xF0;
      break;
    case 5:
      symbol = symbol ^ 0xF8;
      break;
    case 6:
      symbol = symbol ^ 0xFC;
      break;
    default:
      return characters[0];
    }

    for (byteindex = 1; byteindex < bytes; byteindex += 1) {
      symbol = symbol << 6;
      symbol += characters[byteindex].charCodeAt() ^ 0x80;
    }

    return String.fromCharCode(symbol);
  };

  UnicodeHelper.latin2utf8 = function(string) {
    var symbolindex, ret, symbol;
    ret = [];

    for (symbolindex = 0; symbolindex < string.length; symbolindex += 1) {

      symbol = string.substr(symbolindex, 6);
      if (UnicodeHelper.isutf8codepoint(symbol)) {
        // skip utf8 bytes
        symbolindex += UnicodeHelper.numutfbytes(symbol) - 1;
        // add utf-8 codepoint instead of its ansi representation
        ret.push(UnicodeHelper.latin2utf8symbol(symbol));
      } else {
        // just display the ansi symbol
        ret.push(string[symbolindex]);
      }
    }

    return ret.join('');
  };

  return UnicodeHelper;
});

/**
 * TeamsFileLoadController: loads a whole file and adds its lines as teams
 *
 * Inner workings: An HTML5 FileReader reads all contents as ANSI (ISO-8859-1).
 * It then converts possible UTF-8 byte into utf-8 code points, leaving all
 * other characters in place. This enables the use of both latin-1 and utf-8 as
 * input file encoding.
 *
 * All other encodings are discouraged. DOS-style line endings are filtered by
 * "new TeamModel()". MAC-style line endings can still be a problem.
 *
 * TODO rewrite the whole thing and extract a lot of methods
 *
 * @return TeamsFileLoadController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamsfileloadcontroller',['lib/extend', 'ui/fileloadcontroller', './toast', './strings',
    'ui/state', './playermodel', './teammodel', 'presets', //
    'ui/unicodehelper'], function(extend, FileLoadController, Toast, Strings,
    State, PlayerModel, TeamModel, Presets, UnicodeHelper) {

  /**
   * Constructor
   *
   * @param $button
   *          Optional. A button element which, when clicked, starts the file
   *          selection
   */
  function TeamsFileLoadController($button) {
    TeamsFileLoadController.superconstructor.call(this, $button);
  }
  extend(TeamsFileLoadController, FileLoadController);

  /**
   * Implemented function: file read success. Start parsing.
   *
   * @param fileContents
   *          file contents
   */
  TeamsFileLoadController.prototype.readFile = function(fileContents) {
    return TeamsFileLoadController.load(fileContents);
  };

  /**
   * Implemented function: unread current file. Nothing to do here, since there
   * should be no registered teams
   */
  TeamsFileLoadController.prototype.unreadFile = function() {
    // Nothing to unread
  };

  /**
   * reads names from a string and adds the players accordingly. Ignores
   * #-escaped lines
   *
   * @return true on success, undefined or false on failure
   */
  TeamsFileLoadController.parseCSVString = function(str, teamsizeModel) {
    var lines, name, names, i;

    lines = str.split('\n');

    lines = lines.filter(function(line) {
      return line.trim().length !== 0 && !line.trim().match(/^#/);
    }).map(function(line) {
      var match, name, names = [];

      while (line.length > 0) {
        match = (line.match(/^\s*"([^"]+|"")*"\s*(,|$)/) || '');
        match = match || line.match(/^\s*[^,]*\s*(,|$)/);

        name = (match && match[0]) || line;
        line = line.substr(name.length);
        names.push(name);
      }

      return names;
    });

    lines = lines.map(function(names) {
      return names.map(function(name) {
        // remove commas and whitespaces
        name = name.replace(/,$/, '').trim();
        if (name.match(/^".*"$/)) {
          name = name.replace(/^"(.*)"$/, '$1');
          name = name.replace(/""/g, '"');
        }
        return name;
      });
    });

    lines = lines.filter(function(names) {
      return names.join('').length !== 0;
    });

    return lines;
  };

  /**
   * Read teamsize from teams array
   *
   * @param teams
   *          a 2d teams array
   * @return the team size, or 0 on failure.
   */
  TeamsFileLoadController.readTeamsize = function(teams) {
    var teamsizes, teamsize;

    if (teams.length === 0) {
      return 0;
    }

    teamsizes = teams.map(function(team) {
      return team.length;
    });

    teamsize = teamsizes[0];

    if (teamsizes.some(function(size) {
      return size !== teamsize;
    })) {
      return 0;
    }

    return teamsize;
  };

  /**
   * load the teams from a csv string and write them to State
   *
   * @param csvString
   * @return true on success, false otherwise
   */
  TeamsFileLoadController.load = function(csvString) {
    var teams, teamsize;

    csvString = UnicodeHelper.latin2utf8(csvString);

    if (State.teams.length !== 0) {
      new Toast(Strings.teamsnotempty);
      return false;
    }

    teams = TeamsFileLoadController.parseCSVString(csvString, State.teamsize);
    teamsize = TeamsFileLoadController.readTeamsize(teams);

    // validate team size
    if (teamsize >= Presets.registration.minteamsize
        && teamsize <= Presets.registration.maxteamsize) {
      State.teamsize.set(teamsize);
    } else {
      new Toast(Strings.invalidteamsize);
      return false;
    }

    // enter new teams
    teams.forEach(function(names) {
      var players = names.map(function(name) {
        return new PlayerModel(name);
      });

      State.teams.push(new TeamModel(players));
    });

    new Toast(Strings.loaded);

    return true;
  };

  return TeamsFileLoadController;
});

/**
 * StateLoader: A singleton for loading save states
 *
 * @return StateLoaderModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/stateloader',['ui/state', 'timemachine/timemachine', 'ui/legacyloadermodel',
    'ui/legacystoragekeyconverter', 'ui/teamsfileloadcontroller'], //
function(State, TimeMachine, LegacyLoaderModel, LegacyStorageKeyConverter,
    TeamsFileLoadController) {
  var StateLoader;

  /**
   * Constructor. Also auto-converts all legacy storage keys. This will only be
   * performed once every pageload StateLoader this is a singleton.
   */
  function StateLoaderModel() {
    var converter = new LegacyStorageKeyConverter();
    converter.convertAll();
  }

  /**
   * find the latest commit and load it.
   *
   * @return true on success, false otherwise
   */
  StateLoaderModel.prototype.loadLatest = function() {
    var lastCommit;

    if (TimeMachine.roots.length === 0) {
      return false;
    }

    lastCommit = TimeMachine.roots.get(TimeMachine.roots.length - 1);
    lastCommit = lastCommit.getYoungestDescendant() || lastCommit;

    return this.loadCommit(lastCommit);
  };

  /**
   * load the state from an existing commit
   *
   * @param commit
   *          a valid commit to load.
   * @return true on success, false otherwise
   */
  StateLoaderModel.prototype.loadCommit = function(commit) {
    var string;

    if (!commit || !commit.isValid()) {
      return false;
    }

    string = TimeMachine.load(commit);

    if (!string) {
      return false;
    }

    return this.loadString(string);
  };

  /**
   * load the state from a string (serialized data)
   *
   * @param string
   *          the serialized data
   * @return true on success, false otherwise
   */
  StateLoaderModel.prototype.loadString = function(string) {
    var data;

    if (!string) {
      return false;
    }

    try {
      data = JSON.parse(string);
    } catch (e) {
      // try CSV-loading
      return this.loadTeamsCSV(string);
    }

    return this.loadData(data);
  };

  /**
   * load the state from a save-data object. Tries to up-convert old savestates
   *
   * @param data
   *          the save-data object, as written by State.save() at some point in
   *          the past
   * @return true on success, false otherwise.
   */
  StateLoaderModel.prototype.loadData = function(data) {
    var success;

    if (!data) {
      return false;
    }

    if (!data.version) {
      // pre-1.5.0
      return this.loadLegacyData(data);
    }

    success = State.restore(data);

    if (success) {
      console.log('savestate loaded');
    }

    return success;
  };

  /**
   * load an old save state, from pre-1.5.0 times when the MVC-classes weren't
   * completed yet
   *
   * @param data
   *          a data object of pre-1.5.0 format
   * @return true on success, false otherwise
   */
  StateLoaderModel.prototype.loadLegacyData = function(data) {
    console.warn('Saved data is older than 1.5.0. '
        + 'Tuvero tries to auto-convert it, but success is not guaranteed.'
        + 'Please check the results before trusting them blindly');

    loader = new LegacyLoaderModel();
    try {
      if (loader.load(data)) {
        console.log('legacy savestate loaded');
        return true;
      }
    } catch (e) {
      console.error(e.stack);
    }

    return false;
  };

  StateLoaderModel.prototype.loadTeamsCSV = function(csvString) {
    try {
      State.clear();
      return TeamsFileLoadController.load(csvString);
    } catch (e) {
    }
    return false;
  };

  /**
   * reset the current state and forget about all previously loaded states
   */
  StateLoaderModel.prototype.unload = function() {
    TimeMachine.unload();
    State.clear();
  };

  /*
   * StateLoader is a singleton
   */
  StateLoader = new StateLoaderModel();

  return StateLoader;
});

/**
 * StateSaver: Properly saves the State to the TimeMachine
 *
 * @return StateSaver
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/statesaver',['ui/state', 'timemachine/timemachine', 'ui/stateloader'], function(
    State, TimeMachine, StateLoader) {
  var StateSaver;

  /**
   * Constructor of the singleton StateSaver
   */
  function StateSaverModel() {
    this.createTree = undefined;
  }

  StateSaverModel.prototype.newTree = function(name) {
    this.createTree = name || '';
  };

  StateSaverModel.prototype.createNewEmptyTree = function(name) {
    this.newTree(name);

    StateLoader.unload();

    return this.saveState();
  };

  /**
   * @return true if a state can be saved, false otherwise
   */
  StateSaverModel.prototype.canSave = function() {
    return this.createTree !== undefined || TimeMachine.isInitialized();
  };

  /**
   * Save the current state to a new commit
   *
   * @return true on success, false otherwise
   */
  StateSaverModel.prototype.saveState = function() {
    var data = State.save();

    return this.saveData(data);
  };

  /**
   * Save a data object to a new commit
   *
   * @param data
   *          a data object to save
   * @return true on success, false otherwise
   */
  StateSaverModel.prototype.saveData = function(data) {
    var string;

    if (!data) {
      return false;
    }

    string = JSON.stringify(data);

    return this.saveString(string);
  };

  /**
   * Save a string to a new commit
   *
   * @param string
   *          the string to store
   * @return true on success, false otherwise
   */
  StateSaverModel.prototype.saveString = function(string) {
    var commit, success;

    if (!string) {
      return false;
    }

    if (this.createTree === undefined) {
      commit = TimeMachine.save(string);
    } else {
      commit = TimeMachine.init(string, this.createTree);
    }

    if (!commit) {
      return false;
    }

    success = commit.isValid();

    if (success) {
      this.createTree = undefined;
      TimeMachine.cleanup(commit, 3);
      console.log('state saved');
    }

    return success;
  };

  StateSaverModel.prototype.removeEverything = function() {
    StateLoader.unload();
    while (TimeMachine.roots.length > 0) {
      TimeMachine.roots.get(0).eraseTree();
    }
    TimeMachine.getOrphans().forEach(function(orphan) {
      orphan.remove();
    });
  };

  /*
   * StateSaver is a singleton
   */
  StateSaver = new StateSaverModel();

  return StateSaver;
});

/**
 * store the state whenever a player name changes
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/autosave',['ui/state', 'ui/listcollectormodel', 'ui/teammodel',
    'core/tournamentmodel', 'ui/statesaver', 'core/listener'], function(State,
    ListCollectorModel, TeamModel, TournamentModel, StateSaver, Listener) {
  var updatePending, nameListener, AutoSave,

  AutoSave = undefined;

  updatePending = undefined;

  function save() {
    if (updatePending === undefined) {
      updatePending = window.setTimeout(function() {
        updatePending = undefined;
        if (StateSaver.canSave()) {
          if (!StateSaver.saveState()) {
            // TODO display as Toast!
            console.error('autosave failed');
          }
        } else {
          console.warn('cannot autosave: No state loaded.');
        }
      }, 10);
    }
  }

  // save on player name change
  Listener.bind(new ListCollectorModel(State.teams, TeamModel), 'update', save//
  );

  // save on team insertion/removal
  Listener.bind(State.teams, 'resize', save);

  // save on tournament property change
  Listener.bind(new ListCollectorModel(State.tournaments, TournamentModel),
      'update', save);

  // save on tournament insertion/removal
  Listener.bind(State.tournaments, 'resize', save);

  // save on global ranking change (i.e. after every match, etc.
  Listener.bind(State.tournaments, 'update', save);

  // save on tournament name change
  nameListener = new Listener();
  nameListener.onupdate = save;

  // register tournament listeners
  Listener.bind(State.tournaments, 'insert', function(emitter, event, data) {
    data.object.getName().registerListener(nameListener);
  });
  Listener.bind(State.tournaments, 'remove', function(emitter, event, data) {
    data.object.getName().unregisterListener(nameListener);
  });

  return AutoSave;
});

/**
 * Hotkeys for the font size. Hooks as directly as possible into the fontsize
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/dropstyle',['jquery'], function($) {
  var DropStyle;

  DropStyle = undefined;
  $body = undefined;

  function initDrop($body) {
    $body.on('dragover', function(e) {
      $body.addClass('dragover');
      e.preventDefault();
      return false;
    });

    $body.on('dragleave drop', function(e) {
      $body.removeClass('dragover');
      e.preventDefault();
      return false;
    });
  }

  $(function($) {
    initDrop($('body'));
  });

  return DropStyle;
});

/**
 * detect features and warn users when they're leaving the page if data will be
 * lost
 *
 * @return FeatureDetect
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/featuredetect',['jquery', 'lib/modernizr', '../strings', '../toast'], function($,
    Modernizr, Strings, Toast) {
  var FeatureDetect;

  FeatureDetect = {};

  $(function($) {
    function confirmLeave() {
      window.onbeforeunload = function() {
        return Strings.confirmleave;
      };
    }

    if (!Modernizr) {
      console.error('cannot load Modernizr!');
    } else {
      if (!Modernizr.adownload) {
        $('.noadownload').show();
      }

      if (!Modernizr.filereader) {
        $('.nofilereader').show();
        $('.filereader').detach();
        new Toast(Strings.nofilereader, Toast.LONG);
      }

      if (!Modernizr.json) {
        $('.nojson').show();
        $('.json').detach();
        new Toast(Strings.nojson, Toast.LONG);
        confirmLeave();
      }

      if (!Modernizr.localstorage) {
        $('.nostorage').show();
        $('.storage').detach();
        new Toast(Strings.nostorage, Toast.LONG);
        confirmLeave();
      }
    }
  });

  return FeatureDetect;
});

/**
 * Hotkeys for the font size. Hooks as directly as possible into the fontsize
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/fonthotkeys',['jquery'], function($) {
  var FontHotkeys, $buttons;

  FontHotkeys = undefined;
  $buttons = undefined;

  function hashcheck() {
    var fontSize;

    if (!$buttons) {
      return;
    }

    if (window.location.hash === '#font+') {
      setFontSize(getFontSize() + 1);
      window.location.hash = '';
    } else if (window.location.hash === '#font-') {
      setFontSize(getFontSize() - 1);
      window.location.hash = '';
    }
  }

  function getFontSize() {
    var fontSize = -1;

    $buttons.each(function(index) {
      if ($(this).parent().hasClass($(this).attr('class'))) {
        fontSize = index;
      }
    });

    return fontSize;
  }

  function setFontSize(fontSize) {
    index = Math.min(Math.max(fontSize, 0), $buttons.length - 1);

    $buttons.eq(index).click();
  }

  $(window).on('hashchange', function() {
    hashcheck();
  });

  $(function($) {
    $buttons = $('#tabs>[data-tab="settings"] .fontsizeview:first button');
  });

  return FontHotkeys;
});

/**
 * Box Controller for catching collapse-by-click events
 *
 * @return BoxController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/boxcontroller',['lib/extend', 'core/controller'], function(extend, Controller) {
  /**
   * Constructor, in which a click to the header is bound to sending a a toggle
   * event over the model.
   *
   * @param view
   *          the instance of BoxView which will be controlled
   */
  function BoxController(view) {
    BoxController.superconstructor.call(this, view);

    this.view.$view.on('click', '> h3:first-child', this.toggle.bind(this));
  }
  extend(BoxController, Controller);

  BoxController.prototype.toggle = function(evt) {
    if (evt.target.nodeName.toLowerCase() == 'input') {
      evt.preventDefault();
      return false;
    }

    this.model.emit('toggle');
  };

  return BoxController;
});

/**
 * BoxView for collapsing boxes on click events
 *
 * @return BoxView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/boxview',['lib/extend', 'core/view', './boxcontroller'], function(extend, View,
    BoxController) {
  /**
   * Set the current tabbing state. This forbids tabbing into a collapsed box.
   *
   * @param $box
   *          the .boxview jQuery object
   */
  function setTabbing($box) {
    var i, $inputs, $input, enable;

    enable = !$box.hasClass('collapsed');

    $inputs = $box.find('a, button, input, select, textarea');

    for (i = 0; i < $inputs.length; i += 1) {
      $input = $inputs.eq(i);

      if (enable) {
        if ($input.data().tabindex === undefined) {
          $input.removeAttr('tabindex');
        } else {
          $input.attr('tabindex', $input.data().tabindex);
        }
        delete $input.data().tabindex;
      } else {
        $input.data().tabindex = $input.attr('tabindex');
        $input.attr('tabindex', -1);
      }
    }
  }

  /**
   * Constructor, which also creates the BoxController
   *
   * @param $box
   *          the .boxview jQuery object
   */
  function BoxView($box) {
    BoxView.superconstructor.call(this, undefined, $box);
    this.model.EVENTS = BoxView.EVENTS;

    if (this.$view.hasClass('collapsed')) {
      // start collapsed, if specified
      setTabbing(this.$view.css('height', 0));
    }

    this.controller = new BoxController(this);
  }
  extend(BoxView, View);

  BoxView.EVENTS = {
    toggle: true
  };

  /**
   * reset to the expanded state
   */
  BoxView.prototype.reset = function() {
    setTabbing(this.$view.removeClass('collapsed').css('height', '').css(
        'transition', ''));
  };

  /**
   * update the box with a transition, e.g. after toggling its state
   */
  BoxView.prototype.update = function() {
    var $box, oldheight, targetheight;

    $box = this.$view;

    if ($box.hasClass('collapsed')) {
      targetheight = 0;
    } else {
      oldheight = $box.height();
      $box.css('transition', '');
      $box.css('height', '');
      $box[0].offsetHeight;

      targetheight = $box.height();
      $box.css('height', oldheight);
      $box[0].offsetHeight;
    }
    $box.css('height', $box.height());
    $box.css('transition', 'height 0.5s');
    $box[0].offsetHeight;
    $box.css('height', targetheight);

    setTabbing($box);

    // reset the transition value
    setTimeout(function() {
      $box.css('transition', '');
      if (!$box.hasClass('collapsed')) {
        $box.css('height', '');
      }
    }, 500);
  };

  /**
   * toggle callback function
   */
  BoxView.prototype.ontoggle = function() {
    this.$view.toggleClass('collapsed');
    this.update();
  };

  return BoxView;
});

/**
 * register and initiate static views, which aren't necessarily subviewed
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/backgroundscripts/initboxviews',['ui/boxview', 'jquery'], function(BoxView, $) {
  var InitViews = undefined;

  $(function($) {
    $('.boxview:not(.template)').each(function() {
      var $box;

      $box = $(this);

      if ($box.parents('.template').length == 0) {
        return new BoxView($box);
      }
    });
  });

  return InitViews;
});

/**
 * store the state whenever a player name changes
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/matchtoasts',['ui/state', 'ui/toast', 'ui/strings', 'core/listener'], function(
    State, Toast, Strings, Listener) {
  var MatchToasts;

  MatchToasts = {};

  /*
   * toast for finished matches
   */
  MatchToasts.matchfinished = new Listener();
  MatchToasts.matchfinished.onremove = function(emitter, event, data) {
    if (data.object.isRunningMatch()) {
      return new Toast(Strings.gamefinished);
    }
  };

  /*
   * toast for tournament state changes
   */
  MatchToasts.tournamentState = new Listener();
  MatchToasts.tournamentState.onupdate = function(emitter, event, data) {
    return new Toast(Strings['tournament_' + data], Toast.LONG);
  };

  /*
   * bind the listeners to all tournaments, and send a 'tournament created'
   * Toast
   */
  Listener.bind(State.tournaments, 'insert', function(emitter, event, data) {
    data.object.getMatches().registerListener(MatchToasts.matchfinished);
    data.object.getState().registerListener(MatchToasts.tournamentState);
    return new Toast(Strings.tournament_initial, Toast.LONG);
  });
  Listener.bind(State.tournaments, 'remove', function(emitter, event, data) {
    data.object.getMatches().unregisterListener(MatchToasts.matchfinished);
    data.object.getState().unregisterListener(MatchToasts.tournamentState);
  });

  return MatchToasts;
});

/**
 * some debugging functions, such as stack trace and whether it's a dev version
 *
 * @return Debug
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/debug',['./toast', './strings', 'jquery'], function(Toast, Strings, $) {
  var Debug;

  Debug = {
    stackTrace: function() {
      var e, stack;

      e = new Error('dummy');
      stack = e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '')
          .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@');
      console.log(stack);
    },
    isDevVersion: undefined
  };

  // Not waiting for document load. We're just reading a header text, not
  // manipulating the DOM. We should be safe.
  // $(function($) {
  Debug.isDevVersion = !/\s[0-9]+(\.[0-9]+)+(-rc[0-9]*)?$/.test($('head title')
      .text());
  if (Debug.isDevVersion) {
    new Toast(Strings.dev, Toast.INFINITE);
  }
  // });

  return Debug;
});

/**
 * Manage the application cache and notify about available and finished updates
 *
 * The exported Update() function allows manually triggering an update check.
 * Updates are automatically checked for on every pageload.
 *
 * @export Update
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
// FIXME start this script as early as possible!
define('ui/update',['./strings', './toast', './debug'], function(Strings, Toast, Debug) {
  var Update, appCache, downloadToast, uncachedToast;

  downloadToast = undefined;

  Update = function() {
    cacheStatus();
    if (Update.isCached) {
      try {
        appCache.update();
      } catch (er) {
        console.error(er);
      }
    }
  };
  // Note: Update() is NOT A CLASS
  // This is just a cheap hack to keep type mismatch warnings suppressed
  Update.prototype = {};
  Update.isCached = false;

  appCache = window.applicationCache;

  function closeDownloadToast() {
    if (downloadToast) {
      downloadToast.close();
      downloadToast = undefined;
    }
  }

  function isLocal() {
    return document.location.protocol === 'file:';
  }

  function setCached(cached) {
    if (cached) {
      Update.isCached = true;
      if (uncachedToast) {
        uncachedToast.close();
      }
    } else {
      Update.isCached = false;
      if (!Debug.isDevVersion) {
        if (!isLocal()) {
          console.error('no cache manifest found');
          if (uncachedToast === undefined) {
            uncachedToast = new Toast(Strings.nomanifest, Toast.INFINITE);
          }
        }
      }
    }
    closeDownloadToast();
  }

  function cacheStatus() {
    switch (appCache.status) {
    case appCache.OBSOLETE:
    case appCache.UNCACHED:
      // no cache manifest available
      setCached(false);
      break;

    case appCache.UPDATEREADY:
      // We don't need swapCache. In fact, it would likely break the page in
      // horrible ways if there's an API change
      // appCache.swapCache();
      setCached(true);
      new Toast(Strings.updateavailable, Toast.INFINITE);
      console.warn('boulesprog application cache updated');
      window.applicationCache.swapCache();
      break;
    case appCache.IDLE:
      setCached(true);
      break;
    case appCache.CHECKING:
      break;
    case appCache.DOWNLOADING:
      if (!downloadToast) {
        downloadToast = new Toast(Strings.updatedownloading, Toast.INFINITE);
      }
      break;
    default:
      console.error('unhandled appCache status: ' + appCache.status);
      setCached(false);
      break;
    }
  }

  // function cacheError() {
  // new Toast(Strings.updatefailed, Toast.LONG);
  // console
  // .error('unexpected applicationCache error. window.applicationCache.status =
  // '
  // + window.applicationCache.status);
  // }

  appCache.addEventListener('error', cacheStatus);
  appCache.addEventListener('downloading', cacheStatus);
  appCache.addEventListener('progress', cacheStatus);
  appCache.addEventListener('cached', cacheStatus);
  appCache.addEventListener('noupdate', cacheStatus);
  appCache.addEventListener('updateready', cacheStatus);

  cacheStatus();

  if (Debug.isDevVersion) {
    window.setInterval(Update, 5000);
    appCache.addEventListener('updateready', function() {
      window.setTimeout(function() {
        window.location.reload();
      }, 1000);
    });
  }

  return Update;
});

/**
 * Supports Online(), which returns true if the browser is online.
 *
 * Also notifies if the user wants to leave the page while offline, but cannot
 * re-open it because it's not in the cache
 *
 * @return Online
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/online',['jquery', '../strings', '../update'], function($, Strings, Update) {
  var Online;

  /**
   * Check for an internet connection. Does not check for an active connection
   * to tuvero.de
   *
   * @return true if there's an active internet connection, false otherwise.
   */
  Online = function() {
    return navigator.onLine;
  };

  // if offline, send a nag message on exit!

  $(function($) {
    $(window).on('beforeunload', function(e) {
      var message = Strings.offlineconfirmexit;

      if (!Online() && !Update.isCached &&
          document.location.protocol !== 'file:') {
        if (e) {
          e.returnValue = message;
        }
        return message;
      }

      // uncomment to show dev reload notifications again
      //
      // if (Shared.Debug.isDevVersion) {
      // message='(dev output) beforeunload ' + (Online() ? 'online' :
      // 'offline')
      // + ' ' + (Update.isCached ? 'cached' : 'uncached');
      // if (e) {
      // e.returnValue = message;
      // }
      // return message;
      // }
      //

      // let it reload
      return undefined;
    });
  });

  return Online;
});

/**
 * Print button logic, which triggers printing the current tab to paper.
 *
 * @return undefined
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/print',['jquery'], function($) {
  var Print = undefined;

  $(function($) {
    $('#tabs').on('click', 'button.print', function() {
      window.print();
    });
  });

  return Print;
});

/**
 * Clears all stored data when the user visits the '#reset' target.
 *
 * This is intended as a fallback solution when loading fails or old saves are
 * no longer compatible. Do not use this for clearing the storage, because the
 * page will be reloaded unnecessarily.
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/reset',['../toast', 'timemachine/timemachine', '../strings', 'jquery'], //
function(Toast, TimeMachine, Strings, $) {
  var Reset = undefined;

  function hashcheck() {
    if (location.hash === '#reset') {
      console.log('clearing localstorage');
      if (window.localStorage) {
        window.localStorage.clear();
      }

      TimeMachine.updateRoots();

      new Toast(Strings.reset, Toast.LONG);
      window.location.hash = '#debug';

      return true;
    }
    return false;
  }

  $(window).on('hashchange', function() {
    if (hashcheck()) {
      location.reload();
    }
  });

  // also bind the reset button by delegating its click to a Tab_Storage
  // element
  $(function($) {
    $('#tabs').on('click', 'button.reset', function(e) {
      $('#tabs > [data-tab="settings"] .local button.clear').click();
    });
  });

  hashcheck();

  return Reset;
});

/**
 * FileSaverModel: Save either the current TimeMachine commit or a selected
 * commit
 *
 * @return FileSaverModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/filesavermodel',['lib/extend', 'core/model', 'lib/FileSaver', 'timemachine/timemachine',
    'presets', 'lib/Blob'], function(extend, Model, saveAs, TimeMachine,
    Presets, Blob) {
  /**
   * Constructor: Constructs a FileSaverModel instance around the given commit
   *
   * @param commit
   *          A CommitModel instance. Defaults to the current commit if
   *          undefined
   */
  function FileSaverModel(commit) {
    FileSaverModel.superconstructor.call(this);

    this.commit = commit;
  }
  extend(FileSaverModel, Model);

  /**
   * save the contained commit, or the current commit if it has been set to
   * undefined
   *
   * @return true on success, false otherwise
   */
  FileSaverModel.prototype.save = function() {
    var commit, basename, filename, data, blob, saveState;

    commit = this.commit || TimeMachine.commit.get();

    if (!commit) {
      console.error('FileSaver: There is no commit to save');
      return false;
    }
    if (!commit.isValid()) {
      console.error('FileSaver: The commit is not valid');
      return false;
    }

    basename = commit.getTreeName() || Presets.target;
    filename = basename.replace(/(\.json)+$/, '').substr(0, 64) + '.json';

    data = commit.load();

    if (!data) {
      console.error('FileSaver: commit contains no data');
      return false;
    }

    try {
      blob = new Blob([data], {
        type: 'application/json'
      });
    } catch (e) {
      console.error('FileSaver: Blob creation failed');
      console.error(e.stack);
      return false;
    }

    try {
      saveState = saveAs(blob, filename);
    } catch (e) {
      console.error('FileSaver: saveAs failed');
      return false;
    }

    if (!saveState) {
      return false;
    }
    return true;
  };

  return FileSaverModel;
});

/**
 * Save button logic which initiates a file download of the current state for
 * later loading
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/save',['jquery', 'ui/filesavermodel', '../toast', '../strings'], function($,
    FileSaverModel, Toast, Strings) {
  var Save = undefined;

  $(function($) {
    $('#tabs').on('click', 'button.save', function() {
      var fileSaver;

      fileSaver = new FileSaverModel();
      if (!fileSaver.save()) {
        new Toast(Strings.savefailed);
      }
    });
  });

  return Save;
});

/**
 * store the state whenever a player name changes
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/statetoasts',['ui/state', 'core/listener', '../toast', '../strings'], function(
    State, Listener, Toast, Strings) {
  var StateToasts;

  StateToasts = {};

  /*
   * show error toasts
   */
  StateToasts.errorListener = Listener.bind(State, 'error', function(emitter,
      event, message) {
    new Toast(message, Toast.LONG);
  });

  StateToasts.clearListener = Listener.bind(State, 'clear', function(emitter,
      event, message) {
    // TODO replace with Toast.isInitialized or similar.
    if (Toast.$container !== undefined) {
      new Toast(Strings.newtournament, Toast.LONG);
    }
  });

  return StateToasts;
});

/**
 * Display tournament-related errors as Toasts
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/backgroundscripts/tournamenterrortoasts',['ui/state', '../listcollectormodel', 'core/tournamentmodel',
    '../toast', '../strings'], function(State, ListCollectorModel,
    TournamentModel, Toast, Strings) {
  var TournamentErrorToasts;

  // save on player name change
  TournamentErrorToasts = new ListCollectorModel(State.tournaments,
      TournamentModel);
  TournamentErrorToasts.onerror = function(emitter, event, message) {
    return new Toast(Strings.tournamenterrorprefix + ': ' + message,//
    Toast.LONG);
  };

  return TournamentErrorToasts;
});

/**
 * BinaryTreeModel: A node of a binary tree, which has a unique ID and supports
 * querying the ids of parent, left/right children and the sibling.
 *
 * @return BinaryTreeModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/binarytreemodel',['lib/extend', 'core/indexedmodel', 'core/type'], function(extend,
    IndexedModel, Type) {
  /**
   * Constructor
   *
   * @param id
   *          Optional. the id of the node.
   */
  function BinaryTreeModel(id) {
    BinaryTreeModel.superconstructor.call(this);

    if (Type.isNumber(id)) {
      this.id = id;
    } else {
      this.id = 1;
    }
  }
  extend(BinaryTreeModel, IndexedModel);

  /**
   * @return the ID of this nodes' parent. returns 0 for the root
   */
  BinaryTreeModel.prototype.getParentID = function() {
    return this.id >> 1;
  };

  /**
   * @return the ID of this nodes' sibling
   */
  BinaryTreeModel.prototype.getSiblingID = function() {
    if (this.id > 1) {
      return this.id ^ 0x1;
    }
    return this.id; // root (1) and default (0)
  };

  /**
   * @return the ID of this nodes' left child
   */
  BinaryTreeModel.prototype.getLeftChildID = function() {
    if (this.id > 0) {
      return this.id << 1;
    } else if (this.id === 0) {
      return 1;
    }
    return 0;
  };

  /**
   * @return the ID of this nodes' right child
   */
  BinaryTreeModel.prototype.getRightChildID = function() {
    return this.getLeftChildID() + (this.id <= 0 ? 0 : 1);
  };

  /**
   * @return the depth of this node within the binary tree
   */
  BinaryTreeModel.prototype.getDepth = function() {
    if (this.id >= 1) {
      return Math.floor(Math.log(this.id) / Math.LN2);
    }
    return 0;
  };

  return BinaryTreeModel;
});

/**
 * BrowserInfoController
 *
 * @return BrowserInfoController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/browserinfocontroller',['lib/extend', 'core/controller'], function(extend, Controller) {
  /**
   * Constructor
   */
  function BrowserInfoController(view) {
    var model;

    BrowserInfoController.superconstructor.call(this, view);

    this.$updateButton = this.view.$view.find('button.update');
    model = this.model;

    this.$updateButton.click(function() {
      model.emit('update');
    });
  }
  extend(BrowserInfoController, Controller);

  return BrowserInfoController;
});

/**
 * prepares a Browser object, which contains the name and version of the
 * browser, for most major browsers
 *
 * @export Browser
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/browser',['./backgroundscripts/online', './update'], function(Online, Update) {
  var Browser;

  Browser = {
    name: undefined,
    version: undefined,
    online: undefined,
    cached: undefined,
    local: undefined,
    secure: undefined,
    legit: undefined,
    inithash: window.location.hash.replace(/^#/, '')
  };

  Browser.update = function() {
    /**
     * original code copied from:
     * http://stackoverflow.com/questions/2400935/browser-detection-in-javascript
     *
     * @return browser information: "Browsername 13.0.0.1" or similar
     */
    sayswho = (function() {
      var ua, tem, M, regex;

      ua = navigator.userAgent;
      regex = /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i;
      M = ua.match(regex) || [];
      if (/trident/i.test(M[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE ' + (tem[1] || '');
      }
      if (M[1] === 'Chrome') {
        tem = ua.match(/\b(OPR|Edge)\/(\d+)/);
        if (tem != null)
          return tem.slice(1).join(' ').replace('OPR', 'Opera');
      }
      M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion,//
      '-?'];
      if ((tem = ua.match(/version\/(\d+)/i)) != null)
        M.splice(1, 1, tem[1]);
      return M.join(' ');
    })();

    Browser.name = sayswho.match(/^\S+/)[0];
    if (Browser.name === 'undefined') {
      Browser.name = undefined;
    }

    Browser.version = sayswho.match(/\S+$/)[0];
    if (Browser.version === 'undefined') {
      Browser.version = undefined;
    } else {
      Browser.version = Number(Browser.version);
    }

    Browser.online = Online();

    Browser.cached = Update.isCached;

    Browser.local = document.location.protocol === 'file:';

    Browser.secure = document.location.protocol === 'https:';

    Browser.legit = document.location.host === 'tuvero.de';

    return Browser;
  };

  Browser.update();

  return Browser;
});

/**
 * BrowserInfoView: display browser information
 *
 * @return BrowserInfoView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/browserinfoview',['lib/extend', 'core/view', './browser', './toast',
    './browserinfocontroller', 'ui/update'], function(extend, View, Browser,
    Toast, BrowserInfoController, Update) {
  /**
   * Constructor
   */
  function BrowserInfoView($view) {
    BrowserInfoView.superconstructor.call(this, undefined, $view);

    this.$name = this.$view.find('.name');
    this.$version = this.$view.find('.version');
    this.$online = this.$view.find('.online');
    this.$local = this.$view.find('.local');
    this.$cached = this.$view.find('.cached');

    this.controller = new BrowserInfoController(this);

    this.update();
  }
  extend(BrowserInfoView, View);

  BrowserInfoView.prototype.update = function() {
    Browser.update();

    this.$name.text(Browser.name);
    this.$version.text(Browser.version);
    this.$online.text(Browser.online);
    this.$local.text(Browser.local);
    this.$cached.text(Browser.cached);
  };

  BrowserInfoView.prototype.onupdate = function() {
    this.update();
    Update();
    new Toast('update');
  };

  return BrowserInfoView;
});

/**
 * No Description
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/checkboxcontroller',['jquery', 'lib/extend', 'core/controller'], function($, extend, Controller) {
  /**
   * Constructor
   *
   * @param view
   *          a CheckboxView instance
   */
  function CheckboxController(view) {
    var model, $checkbox, $parent;
    CheckboxController.superconstructor.call(this, view);

    model = this.model;
    $checkbox = this.view.$view;
    $parent = $checkbox.parent().filter('span');

    $parent.click(function(e) {
      if ($(e.target).prop('tagName') === 'SPAN') {
        $checkbox.click();
      }
    });

    /**
     * apply checkbox state to model state
     */
    $checkbox.change(function() {
      var viewvalue, modelvalue;

      viewvalue = $checkbox.prop('checked');
      modelvalue = model.get();

      if (viewvalue !== modelvalue) {
        model.set(viewvalue);
      }
    });
  }
  extend(CheckboxController, Controller);

  return CheckboxController;
});

/**
 * No Description
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/checkboxview',['lib/extend', 'core/view', 'core/valuemodel', './checkboxcontroller'], //
function(extend, View, ValueModel, CheckboxController) {

  /**
   * Constructor
   *
   * @param model
   *          a boolean ValueModel instance
   * @param $view
   *          the checkbox
   */
  function CheckBoxView(model, $view) {
    CheckBoxView.superconstructor.call(this, model || new ValueModel(), $view);

    if (this.model.get() !== true && this.model.get() !== false) {
      this.model.set(this.$view.prop('checked'));
    }

    this.controller = new CheckboxController(this);

    this.update();
  }
  extend(CheckBoxView, View);

  /**
   * apply model state to checkbox state
   */
  CheckBoxView.prototype.update = function() {
    var viewvalue, modelvalue;

    viewvalue = this.$view.prop('checked');
    modelvalue = this.model.get();

    if (viewvalue !== modelvalue) {
      this.$view.prop('checked', modelvalue);
    }
  };

  /**
   * Callback function
   */
  CheckBoxView.prototype.onupdate = function() {
    this.update();
  };

  return CheckBoxView;
});

/**
 * ClosedTournamentCollapseListener
 *
 * @return ClosedTournamentCollapseListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/closedtournamentcollapselistener',['lib/extend', 'core/listener'], function(extend, Listener) {
  /**
   * Constructor
   */
  function ClosedTournamentCollapseListener(tournamentlistview) {
    var tournaments = tournamentlistview.model;
    ClosedTournamentCollapseListener.superconstructor.call(this,
        tournaments.closedTournaments);

    this.tournaments = tournaments;
    this.tournamentlistview = tournamentlistview;
  }
  extend(ClosedTournamentCollapseListener, Listener);

  /**
   * The tournament has been closed. Collapse it.
   *
   * @param tournamentID
   *          the tournament id
   */
  ClosedTournamentCollapseListener.prototype.collapse = function(tournamentID) {
    var tournamentView, boxView;

    tournamentView = this.tournamentlistview.getSubview(tournamentID);
    boxView = tournamentView.boxview;
    if (!boxView.$view.hasClass('collapsed')) {
      boxView.model.emit('toggle');
    }
  };

  /**
   * @param emitter
   *          this.model
   * @param event
   *          'insert'
   * @param data
   *          a data object
   */
  ClosedTournamentCollapseListener.prototype.oninsert = function(emitter,
      event, data) {
    var listener = this;
    // Use a timeout to avoid runtime concurrency problems during pageload.
    window.setTimeout(function() {
      listener.collapse(data.object);
    }, 1);
  };

  return ClosedTournamentCollapseListener;
});

/**
 * RenameController
 *
 * @return RenameController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/renamecontroller',['jquery', 'lib/extend', 'core/controller', 'timemachine/timemachine',
    'ui/stateloader', 'ui/strings', 'ui/toast', 'ui/filesavermodel'], //
function($, extend, Controller, TimeMachine, StateLoader, Strings, Toast,
    FileSaverModel) {
  /**
   * Constructor
   */
  function RenameController(view, mouseSupport) {
    var events;

    RenameController.superconstructor.call(this, view);

    this.$anchor = undefined;
    this.$rename = undefined;
    this.mouseSupport = !!mouseSupport;

    events = 'click' + (this.mouseSupport ? ' mouseenter' : '');
    this.view.$view.on(events,
        '.rename', this.startRename.bind(this));
    this.view.$view.filter('.rename').on(events, this.startRename.bind(this));
  }
  extend(RenameController, Controller);

  RenameController.prototype.setName = function(name) {
    console.error('setName() needs to be overloaded');
    return false;
  };

  RenameController.prototype.getName = function() {
    console.error('getName() needs to be overloaded');
    return 'overload RenameController.prototype.getName()!';
  };

  RenameController.prototype.initRenameInput = function() {
    if (!this.$rename) {
      this.$rename = $('<input>').addClass('rename');
      this.$rename.on('blur' + (this.mouseSupport ? ' mouseleave' : ''),
          this.endRename.bind(this));
      this.$rename.keydown(this.renameKeyDown.bind(this));
    }
  };

  RenameController.prototype.startRename = function(evt) {
    var name;

    if (this.$anchor) {
      return;
    }

    this.$anchor = $(evt.target);
    if (!this.$anchor) {
      return;
    }

    name = this.getName();
    if (name === undefined) {
      this.$anchor = undefined;
      return;
    }

    this.initRenameInput();

    this.$anchor.before(this.$rename);
    this.$anchor.addClass('hidden');
    this.$rename.val(name);
    this.$rename.focus();

    evt.preventDefault();
    return false;
  };

  RenameController.prototype.endRename = function(evt) {
    var name;

    if (!this.$anchor) {
      return;
    }

    name = this.$rename.val().trim();

    if (this.setName(name)) {
      this.$anchor.removeClass('hidden');
      this.$anchor = undefined;
      this.$rename.detach();
    }

    evt.preventDefault();
    return false;
  };

  RenameController.prototype.renameKeyDown = function(evt) {
    if (!evt || !this.$rename) {
      return;
    }

    switch (evt.which) {
    case 27: // escape
      this.$rename.val(this.getName());
      // deliberate fallthrough
    case 13: // enter
      return this.endRename(evt);
    }
  };

  RenameController.prototype.destroy = function() {
    if (this.$rename) {
      this.$rename.remove();
    }

    RenameController.superclass.destroy.call(this);
  };

  return RenameController;
});

/**
 * TeamController: Let the user change player names, when she clicks a player
 * name
 *
 * @return TeamController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamcontroller',['lib/extend', 'ui/renamecontroller', './toast', './strings'], function(
    extend, RenameController, Toast, Strings) {
  /**
   * Constructor
   *
   * @param view
   *          a ListView instance with TeamView instances
   */
  function TeamController(view, $input) {
    TeamController.superconstructor.call(this, view);
  }
  extend(TeamController, RenameController);

  /**
   * Retrieve the Player instance, which is associated with the $name element
   *
   * This requires working knowledge of the TeamView structure. So be it.
   *
   * @param $name
   *          the DOM element which displays the player name
   * @return the associated PlayerModel instance
   */
  TeamController.prototype.getPlayer = function($name) {
    var index, $names;

    $names = this.view.$view.find('.name');
    if ($names.length === 0) {
      $names = this.view.$view.filter('.name');
    }
    index = $names.index($name);

    return this.model.getPlayer(index);
  };

  TeamController.prototype.getName = function() {
    var player;

    if (!this.$anchor) {
      return '';
    }

//    if (!(this.model.getID() >= 0)) {
//      return undefined;
//    }

    player = this.getPlayer(this.$anchor);

    return player.getName();
  };

  TeamController.prototype.setName = function(name) {
    if (!this.$anchor || !name) {
      return false;
    }

    player = this.getPlayer(this.$anchor);

    player.setName(name);

    return true;
  };

  return TeamController;
});

/**
 * A teamView, which sets the .teamno and .name elements of the associated DOM
 * element
 *
 * @return TeamView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/teamview',['lib/extend', 'core/view', 'core/type', 'ui/teamcontroller'], //
function(extend, View, Type, TeamController) {
  /**
   * Constructor
   *
   * @param model
   *          a TeamModel instance
   * @param $view
   *          the associated DOM element
   * @param teamlist
   *          Optional. A ListModel of TeamModels. If model is a number, model
   *          is set to teamlist.get(model). Helper for index-referencing lists
   */
  function TeamView(model, $view, teamlist) {
    if (Type.isNumber(model) && teamlist !== undefined) {
      model = teamlist.get(model);
    }
    TeamView.superconstructor.call(this, model, $view);

    this.teamController = new TeamController(this);

    this.update();
  }
  extend(TeamView, View);

  /**
   * write the playernames and teamnumber to the DOM
   */
  TeamView.prototype.update = function() {
    var $names, i, $name, $teamno, player, teamid;

    $teamno = this.$view.find('.teamno');
    if ($teamno.length === 0) {
      $teamno = this.$view.filter('.teamno');
    }
    teamid = this.model.getID();
    if (Type.isNumber(teamid)) {
      teamid += 1;
    }
    $teamno.text(teamid);

    $names = this.$view.find('.name');
    if ($names.length === 0) {
      $names = this.$view.filter('.name');
    }

    // FIXME read maxteamsize from options or something
    for (i = 0; i < 3; i += 1) {
      $name = $names.eq(i);
      player = this.model.getPlayer(i);

      if (player) {
        $name.text(player.getName());
      } else {
        $name.remove();
      }
    }
  };

  /**
   * Callback listener
   */
  TeamView.prototype.onupdate = function() {
    this.update();
  };

  TeamView.bindTeamList = function(teamlist) {
    function IndexTeamView(teamID, $view) {
      IndexTeamView.superconstructor.call(this, teamlist.get(teamID), $view);
    }
    extend(IndexTeamView, TeamView);

    return IndexTeamView;
  };

  TeamView.destroy = function() {
    this.teamController.destroy();

    TeamView.superclass.destroy.call(this);
  };

  return TeamView;
});

/**
 * Controller for finishing a Match
 *
 * TODO use ValueModel events to communicate the values, not jquery events
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/matchcontroller',['jquery', 'lib/extend', 'core/controller', 'options'], function($, extend,
    Controller, Options) {
  /**
   * Constructor
   *
   * @param view
   *          the associated MatchView
   */
  function MatchController(view, $form) {
    MatchController.superconstructor.call(this, view);

    this.$form = $form;
    this.$acceptbutton = this.$form.find('button.accept');
    this.$cancelbutton = this.$form.find('button.cancel');
    this.$scores = this.$form.find('.score');

    this.$scores.val(Options.defaultscore || 0);

    this.$acceptbutton.click(this.accept.bind(this));
    this.$cancelbutton.click(this.cancel.bind(this));
    this.initKeyListeners();

    this.initNumberValidation();

    this.updateButtonStatus();
  }
  extend(MatchController, Controller);

  MatchController.prototype.initKeyListeners = function() {
    var controller, $lastinput;

    controller = this;

    this.$form.keydown(function(e) {
      switch (e.which) {
      case 27: // escape
        controller.cancel();
        break;
      case 13: // enter
        controller.accept();
        break;
      case 9: // tab
        if (e.shiftKey) {
          return;
        }

        if (controller.$acceptbutton.filter(':not(.hidden)').length !== 0) {
          return;
        }

        $lastinput = controller.$scores.eq(controller.$scores.length - 1);
        if ($lastinput.data() !== $(e.target).data()) {
          return;
        }

        if (controller.accept()) {
          break;
        }
      default:
        return;
      }

      e.preventDefault();
      return false;
    });
  };

  MatchController.prototype.initNumberValidation = function() {
    var controller = this;

    // select the whole input field on focus. make id DAU-safe.
    this.$scores.click(function() {
      $(this).select();
    });

    // We're using keyup to check the values as the user types, not only
    // when
    // the focus is lost or the value is changed incrementally
    this.$scores.on('change keyup', function() {
      var $this, value, valid;

      valid = true;

      $this = $(this);
      value = $this.val();

      if (value.length === 0) {
        valid = false;
      } else {
        value = Number(value);

        if (isNaN(value)) {
          valid = false;
        } else if (value < Options.minpoints) {
          valid = false;
        } else if (value > Options.maxpoints) {
          valid = false;
        }
      }

      if (valid) {
        $this.removeClass('invalid');
      } else {
        $this.addClass('invalid');
      }

      controller.updateButtonStatus();
    }).attr('min', Options.minpoints).attr('max', Options.maxpoints);
  };

  MatchController.prototype.updateButtonStatus = function() {
    this.$acceptbutton.prop('disabled', !this.validateScore());
  };

  MatchController.prototype.validateScore = function() {
    var valid, tie, firstpoints, maxpoints;

    valid = this.$scores.filter('.invalid').length === 0;

    if (valid && (Options.tiesforbidden || Options.maxpointtiesforbidden)) {
      tie = true;
      firstpoints = undefined;

      this.$scores.each(function() {
        var points = Number($(this).val());
        if (firstpoints === undefined) {
          firstpoints = points;
        }
        if (points !== firstpoints) {
          tie = false;
        }
      });

      if (tie && Options.tiesforbidden) {
        valid = false;
      }

      maxpoints = (Number(this.$scores.eq(0).val()) == Options.maxpoints);
      if (tie && maxpoints && Options.maxpointtiesforbidden) {
        valid = false;
      }
    }

    return valid;
  };

  /**
   * finish the match with the entered result, if it's valid.
   *
   * @return true on success, false otherwise
   */
  MatchController.prototype.accept = function() {
    var points;

    if (!this.validateScore()) {
      return false;
    }

    points = [];

    this.$scores.each(function(i) {
      points[i] = Number($(this).val());
    });

    this.model.finish(points);
    return true;
  };

  /**
   * cancel the input. Please overload where necessary
   */
  MatchController.prototype.cancel = function() {
    // inherit if necessary. Usual result submissions cannot be canceled
    // We could reset the points, however
  };

  return MatchController;
});

/**
 * MatchView
 *
 * @return MatchView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/matchview',['lib/extend', 'jquery', 'core/view', 'ui/teamview',
    'ui/matchcontroller', './playermodel', './teammodel', './strings',
    'core/type'], function(extend, $, View, TeamView, MatchController,
    PlayerModel, TeamModel, Strings, Type) {
  var emptyPlayer, byePlayer;

  // player name for bye votes
  byePlayer = new PlayerModel(Strings.byename);
  emptyPlayer = new PlayerModel('');
  emptyPlayer.name = ''; // avoid 'NONAME'
  emptyPlayer.setName = function() {
  };

  /**
   * create a team with exactly the wanted number of bye players.
   *
   * @return a TeamModel instance which is not part of the teams list, has only
   *         bye players and a (textual) team id which represents a bye vote
   */
  function createByeTeam(length) {
    var players, team;

    players = [];

    while (players.length < length) {
      players.push(byePlayer);
    }

    team = new TeamModel(players);
    team.setID(Strings.byeid);
    return team;
  }

  function createEmptyTeam(length) {
    var players, team;

    players = [];

    while (players.length < length) {
      players.push(emptyPlayer);
    }

    team = new TeamModel(players);
    team.setID('');
    return team;
  }

  function $createTeamsLists($elements) {
    var team, teams, i, $element;

    team = undefined;
    teams = [];

    for (i = 0; i <= $elements.length; i += 1) {
      $element = $elements.eq(i);
      if (i === $elements.length || $element.hasClass('teamno')) {
        if (team) {
          teams.push($(team));
        }
        team = undefined;
      }

      if ($element) {
        if (!team) {
          team = [];
        }
        team.push($element[0]);
      }
    }

    return teams;
  }

  /**
   * Constructor
   *
   * @param model
   *          a MatchModel instance
   * @param $view
   *          a jQuery object representing a MatchView table
   * @param teamlist
   *          Optional. A ListModel of TeamModels, from which the teams will be
   *          read for visualization. See MatchView.bindTeamList(), too.
   */
  function MatchView(model, $view, teamlist) {
    MatchView.superconstructor.call(this, model, $view);

    this.teamviews = [];
    if (teamlist) {
      this.teamlist = teamlist;
    } else if (!this.teamlist) {
      this.teamlist = undefined;
    }

    this.$finishform = this.$view.find('.finish');

    if (this.model.isRunningMatch()) {
      this.controller = new MatchController(this, this.$finishform);
    } else {
      this.$finishform.remove();
      this.$finishform = undefined;
    }

    this.update();
  }
  extend(MatchView, View);

  /**
   * destroy all team views before creating new ones on the existing items. This
   * is a bit too much, but it shouldn't be called too often, right?
   */
  MatchView.prototype.destroyTeamViews = function() {
    // destroy all teamviews in order to create new ones
    this.teamviews.forEach(function(teamview) {
      teamview.destroy();
    });
    this.teamviews.splice(0);
  };

  /**
   * update all the values
   */
  MatchView.prototype.update = function() {
    var $teams, i, $team, teamid, isBye, team, teamsize;

    $teams = this.$view.find('.team');
    if ($teams.length === 0) {
      $teams = $createTeamsLists(this.$view.find('>.teamno , >.name'));
    }
    if ($teams.length === 0) {
      $teams = $createTeamsLists(this.$view.filter('.teamno,.name'));
    }

    teamsize = undefined;

    this.destroyTeamViews();

    isBye = this.model.isBye && this.model.isBye();

    // should support a varying number of teams
    for (i = 0; i < $teams.length; i += 1) {
      $team = $($teams[i]);
      teamid = this.model.getTeamID(i % this.model.length);

      if (this.teamlist) {
        if (teamid !== undefined) {
          team = this.teamlist.get(teamid);
          teamsize = team.length;
          if (isBye && (i % this.model.length !== 0)) {
            team = createByeTeam(team.length);
          }
        } else {
          if (teamsize === undefined) {
            // dirty hack: just look for size of the the first team.
            teamsize = this.teamlist.get(0) && this.teamlist.get(0).length;
          }
          team = createEmptyTeam(teamsize);
        }
        this.teamviews.push(new TeamView(team, $team));
      } else {
        if (isBye) {
          team = Strings.byename;
        } else if (Type.isNumber(teamid)) {
          team = teamid + 1;
        } else if (teamid === undefined) {
          team = '';
        } else {
          team = teamid;
        }
        $team.text(team);
      }
    }
  };

  /**
   * Callback Listener. For safety. Is never called in the current
   * implementation.
   *
   * @param emitter
   *          this.model
   * @param event
   *          'update'
   * @param data
   *          should be undefined
   */
  MatchView.prototype.onupdate = function(emitter, event, data) {
    this.update();
  };

  /**
   * bind a whole MatchView subclass to a list of teams for better display.
   *
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @return a new MatchView constructor, which has this.teamList set
   */
  MatchView.bindTeamList = function(teamlist) {
    function MyMatchView() {
      MyMatchView.superconstructor.apply(this, arguments);
    }
    extend(MyMatchView, MatchView);

    MyMatchView.prototype.teamlist = teamlist;

    return MyMatchView;
  };

  return MatchView;
});

/**
 * MatchResultController
 *
 * @return MatchResultController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/matchresultcontroller',['lib/extend', './matchcontroller', './strings', './toast', 'options'], //
function(extend, MatchController, Strings, Toast, Options) {
  /**
   * Constructor
   */
  function MatchResultController(view, $form, tournament) {
    MatchResultController.superconstructor.call(this, view, $form);

    if (this.model.length != 2) {
      console.error('corrections corrently only works with two teams.');
      return;
    }

    this.tournament = tournament;

    this.$match = this.$form.parents('.match').eq(0);
    this.$result = this.view.$result;

    this.$result.click(this.enableCorrection.bind(this));

    this.updateScore();
  }
  extend(MatchResultController, MatchController);

  MatchResultController.prototype.updateScore = function() {
    this.$scores.eq(0).val(this.model.score[0]);
    this.$scores.eq(1).val(this.model.score[1]);
    this.$scores.attr('max', Options.maxpoints);
    this.$scores.attr('min', Options.minpoints);
  };

  MatchResultController.prototype.enableCorrection = function() {
    this.updateScore();
    this.$match.addClass('correcting');
    this.$scores.eq(0).click();
  };

  MatchResultController.prototype.disableCorrection = function() {
    this.$match.removeClass('correcting');
  };

  MatchResultController.prototype.cancel = function() {
    new Toast(Strings.pointchangeaborted);
    this.disableCorrection();
  };

  MatchResultController.prototype.accept = function() {
    var score;

    score = [];
    score.push(Number(this.$scores.eq(0).val()));
    score.push(Number(this.$scores.eq(1).val()));

    if (isNaN(score[0]) || isNaN(score[1])) {
      return;
    } else if (score[0] < Options.minpoints || score[1] < Options.minpoints) {
      return;
    } else if (score[0] > Options.maxpoints || score[1] > Options.maxpoints) {
      return;
    } else if (score[0] === this.model.score[0]
        && score[1] === this.model.score[1]) {
      return;
    }

    this.tournament.correct(this.model, score);

    new Toast(Strings.pointchangeapplied);
    this.disableCorrection();
  };

  return MatchResultController;
});

/**
 * MatchResultView
 *
 * @return MatchResultView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/matchresultview',['lib/extend', './matchview', './matchresultcontroller'], function(
    extend, MatchView, MatchResultController) {
  /**
   * Constructor
   *
   * @param model
   *          a MatchResult instance
   * @param $view
   *          the container element
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @param tournament
   *          a TournamentModel instance
   */
  function MatchResultView(model, $view, teamlist, tournament) {
    MatchResultView.superconstructor.call(this, model, $view, teamlist);

    this.$result = this.$view.find('.result');
    this.$scores = this.$result.find('.score');
    this.$correctionform = this.$view.find('.correct');

    if (this.model.isResult()) {
      if (this.model.isBye()) {
        this.$correctionform.remove();
        this.$correctionform = undefined;
      } else {
        if (tournament) {
          this.controller = new MatchResultController(this,
              this.$correctionform, tournament);
        }
      }
    } else {
      this.$result.remove();
      this.$result = undefined;
      this.$scores = undefined;
      this.$correctionform.remove();
      this.$correctionform = undefined;
    }

    this.updateScore();
  }
  extend(MatchResultView, MatchView);

  /**
   * display the score of the MatchResult
   */
  MatchResultView.prototype.updateScore = function() {
    if (this.model.isResult()) {
      this.model.score.forEach(function(score, index) {
        this.$scores.eq(index).text(score);
      }, this);
    }
  };

  return MatchResultView;
});

/**
 * CorrectionView
 *
 * @return CorrectionView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/correctionview',['lib/extend', 'core/view', './matchresultview'], function(extend, View,
    MatchResultView) {
  /**
   * Constructor
   *
   * @param model
   *          a CorrectionModel instance
   * @param $view
   *          a row of a correction table
   */
  function CorrectionView(model, $view) {
    CorrectionView.superconstructor.call(this, model, $view);

    this.$before = this.$view.find('.before');
    this.$after = this.$view.find('.after');

    this.beforeview = new MatchResultView(model.before, this.$before);
    this.afterview = new MatchResultView(model.after, this.$after);
  }
  extend(CorrectionView, View);

  return CorrectionView;
});

/**
 * CSVExportController
 *
 * @return CSVExportController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/csvexportcontroller',['jquery', 'lib/extend', 'core/controller', 'ui/state', 'presets',
    'lib/FileSaver', 'lib/Blob', './toast', './strings',
    'timemachine/timemachine'], function($, extend, Controller, State, Presets,
    saveAs, Blob, Toast, Strings, TimeMachine) {
  var validsets = ['teams', 'ranking', 'history'];

  /**
   * Constructor
   *
   * @param view
   *          a View which contains the CSV container
   */
  function CSVExportController(view) {
    var controller;
    CSVExportController.superconstructor.call(this, view);

    controller = this;

    this.$buttons = this.view.$view.find('button');

    this.$buttons.click(function() {
      var $button, classes;

      $button = $(this);
      classes = $button.attr('class').split(' ');

      controller.saveCSV(classes);
    });
  }
  extend(CSVExportController, Controller);

  CSVExportController.prototype.saveCSV = function(datasets) {
    var data, blob, filename, basename;

    if (!TimeMachine.isInitialized()) {
      new Toast(Strings.notournament, Toast.LONG);
      return;
    }

    basename = TimeMachine.commit.get().getTreeName() || Presets.target;
    filename = basename.substr(0, 64) + '.csv';

    data = this.generateCSV(datasets);
    try {
      blob = new Blob([data], {
        type: 'text/csv'
      });
    } catch (e) {
      console.log(e.stack);
      new Toast(Strings.exportfailed, Toast.LONG);
    }

    if (!saveAs(blob, filename)) {
      console.error('saveAs failed!');
      new Toast(Strings.exportfailed, Toast.LONG);
    }
  };

  /**
   * create a shared CSV file
   *
   * @param datasets
   *          an array of strings, each of which is a dataset name (i.e. one of
   *          'ranking', 'history' or 'teams)
   * @return a combined CSV string of all datasets
   */
  CSVExportController.prototype.generateCSV = function(datasets) {
    var csvDataSets = datasets.filter(function(dataset) {
      return validsets.indexOf(dataset) !== -1;
    }).map(function(dataset) {
      if (this[dataset + 'ToCSV']) {
        return this[dataset + 'ToCSV']();
      }

      State.emit('error', 'missing CSV export function: ' + dataset);
      return 'CSV export failed for ' + dataset;
    }, this);

    return csvDataSets.join('\r\n\r\n');
  };

  /**
   * @return a CSV string which represents the registered teams
   */
  CSVExportController.prototype.teamsToCSV = function() {
    var csvLines;

    csvLines = State.teams.map(function(team) {
      var i, line;

      line = [team.getID() + 1];

      for (i = 0; i < team.length; i += 1) {
        line.push(this.escape(team.getPlayer(i).getName()));
      }

      return line.join(',');
    }, this);

    csvLines.unshift(Strings.csvheader_teams);

    return csvLines.join('\r\n');
  };

  /**
   * @return a CSV string which represents the ranking
   */
  CSVExportController.prototype.rankingToCSV = function() {
    var tournaments = State.tournaments.map(function(tournament) {
      var lines, ranking;

      ranking = tournament.getRanking().get();

      lines = ranking.displayOrder.map(function(displayID) {
        var teamID, fields;

        teamID = ranking.ids[displayID];
        fields = [ranking.ranks[displayID] + 1, teamID + 1];

        ranking.components.map(function(componentname) {
          fields.push(ranking[componentname][displayID]);
        });

        return fields.join(',');
      });

      lines.unshift(Strings.csvheader_ranking + ','
          + ranking.components.join(','));
      lines.unshift(this.escape(tournament.getName().get()));

      return lines.join('\r\n');
    }, this);

    return tournaments.join('\r\n\r\n');
  };

  /**
   * @return a CSV string which represents all past matches and byes, without
   *         placeholders
   */
  CSVExportController.prototype.historyToCSV = function() {
    var csvTournaments;

    csvTournaments = State.tournaments.map(function(tournament) {
      var lines = [this.escape(tournament.getName().get()),
          Strings.csvheader_history];

      tournament.getHistory().map(function(result) {
        var fields, i;

        fields = [];
        fields.push(result.getGroup() + 1);
        fields.push(result.getID() + 1);

        if (result.isResult()) {
          for (i = 0; i < result.length; i += 1) {
            if (i > 0 && result.isBye()) {
              fields.push(Strings.byeid);
            } else {
              fields.push(result.getTeamID(i) + 1);
            }
          }

          for (i = 0; i < result.length; i += 1) {
            fields.push(result.score[i]);
          }

          lines.push(fields.join(','));
        }
      }, this);

      return lines.join('\r\n');
    });

    return csvTournaments.join('\r\n\r\n');
  };

  CSVExportController.prototype.escape = function(string) {
    string = '' + string;

    if (/[",]|\s/.test(string)) {
      string = string.replace(/"/g, '""');
      string = '"' + string + '"';
    }

    return string;
  };

  return CSVExportController;
});

/**
 * Storage: Save ValueModels and save/restore-compatible models whenever they
 * emit 'update'.
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/storage',['lib/extend', 'core/type', 'core/model', 'core/valuemodel',
    'core/listener'], function(extend, Type, Model, ValueModel, Listener) {
  /**
   * A Storage class. Has no further use at the moment, since there's only one
   * localStorage.
   */
  function Storage() {
  }

  /**
   * Test whether stuff can be stored
   *
   * @return true if storage is possible, false otherwise
   */
  Storage.available = function() {
    if (!window.localStorage) {
      console.error('Storage is not available');
      return false;
    }

    return true;
  };

  /**
   * stored model instances, i.e. values
   */
  Storage.values = {};

  /**
   * Register or retrieve an instance of the Implementation class:
   *
   * @param key
   *          the Key under which to store it
   * @param Implementation
   *          A constructor which is a subclass of Model, i.e. ValueModel. It is
   *          required to either support save/restore or be a ValueModel
   *          subclass.
   * @return an singleton instance of the Implementation class, or undefined if
   *         anything fails (e.g. Implementation is the wrong type)
   */
  Storage.register = function(key, Implementation) {
    var stored, model;

    key = key || undefined;
    Implementation = Implementation || Model;

    if (!key || !Type.isString(key)) {
      console.error('Storage.getModel(): Key is not a String: ');
      console.error(key);
      return undefined;
    }

    if (!extend.isSubclass(Implementation, Model) && Implementation !== Model) {
      console.error('Storage.register(): Not a model: ');
      console.error(Implementation)
      return undefined;
    }

    if (!Storage.available()) {
      return undefined;
    }

    model = Storage.values[key];
    if (model) {
      if (model instanceof Implementation) {
        return model;
      }

      console.error('Storage.register(): '
          + 'stored instance does not match Implementation:');
      console.error(model);
      console.error(Implementation);
      return undefined;
    }

    model = new Implementation();
    if (Type.isFunction(model.save)) {
      Listener.bind(model, 'update', function() {
        window.localStorage.setItem(key, JSON.stringify(model.save()))
      });
    } else if (model instanceof ValueModel) {
      Listener.bind(model, 'update', function() {
        window.localStorage.setItem(key, JSON.stringify(model.get()));
      });
    } else {
      console.error('Storage.register(): instance cannot save/restore');
      console.error(model);
      return undefined;
    }

    stored = window.localStorage.getItem(key);
    if (Type.isString(stored)) {
      stored = JSON.parse(stored);
      if (Type.isFunction(model.restore)) {
        model.restore(stored);
      } else if (model instanceof ValueModel) {
        model.set(stored);
      }
    }

    Storage.values[key] = model;
    return model;
  };

  /**
   * remove this and only this key from localStorage to avoid collision with
   * other software under the same domain.
   *
   * @param key
   *          The key to remove from localStorage. if undefined, clear every key
   *          in the keys object
   */
  Storage.clear = function(key) {
    if (!Storage.available()) {
      return;
    }

    if (key === undefined) {
      Object.keys(Storage.values).forEach(Storage.clear.bind(Storage));
    } else {
      if (Storage.values[key]) {
        Storage.values[key].destroy();
      }
      window.localStorage.removeItem(key);
    }
  };

  return Storage;
});

/**
 * LoadedImagesView
 *
 * @return LoadedImagesView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/loadedimagesview',['lib/extend', 'core/view', 'jquery'], function(extend, View, $) {
  /**
   * Constructor
   */
  function LoadedImagesView($view) {
    LoadedImagesView.superconstructor.call(this, undefined, $view);

    this.appendImages($(document.body));
  }
  extend(LoadedImagesView, View);

  /**
   * reads all sprite images from the page and returns them as a list
   *
   * @param $container
   *          a jquery element for which all images should be retrieved
   * @return an array of image names, e.g. 'new', 'boule'. For use with the
   *         data-img attribute
   */
  LoadedImagesView.imageList = function($container) {
    var $images, images;

    $images = $container.find('[data-img]');
    images = {};

    $images.each(function() {
      images[$(this).attr('data-img')] = true;
    });

    // don't use the sprite itself
    delete images.sprite;

    return Object.keys(images).sort();
  };

  /**
   * finds and appends all images from the container
   *
   * @param $container
   */
  LoadedImagesView.prototype.appendImages = function($container) {
    var images;

    images = LoadedImagesView.imageList($container);

    images.forEach(function(image) {
      var $image = $('<div>').attr('data-img', image);
      this.$view.append($image);
    }, this);
  };

  return LoadedImagesView;
});

/**
 * RegisterTeamsController
 *
 * @return RegisterTeamsController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/registerteamscontroller',['lib/extend', 'core/controller', 'core/view', 'ui/state',
    './teammodel', './playermodel', 'core/random', 'ui/statesaver'], //
function(extend, Controller, View, State, TeamModel, PlayerModel, Random,
    StateSaver) {
  var rng;

  rng = new Random();

  /**
   * Constructor
   */
  function RegisterTeamsController($button, $numteams) {
    RegisterTeamsController.superconstructor.call(this, new View(undefined,
        $button));

    this.$button = $button;
    this.$numteams = $numteams;

    $button.click(this.registerTeams.bind(this));
    this.$numteams.keydown((function(e) {
      if (e.which == 13) {
        this.registerTeams();
      }
    }).bind(this));
  }
  extend(RegisterTeamsController, Controller);

  RegisterTeamsController.prototype.registerTeams = function() {
    var numTeams;

    numTeams = Number(this.$numteams.val());
    if (isNaN(numTeams)) {
      return;
    }

    if (!StateSaver.canSave()) {
      StateSaver.createNewEmptyTree('Tuvero Test-Turnier');
    }

    for (; numTeams > 0; numTeams -= 1) {
      State.teams.push(RegisterTeamsController.createTeam());
    }
  };

  RegisterTeamsController.createTeam = function() {
    var players, team;

    players = [];
    while (players.length < State.teamsize.get()) {
      players.push(new PlayerModel(RegisterTeamsController.randomName()));
    }

    team = new TeamModel(players);

    return team;
  };

  RegisterTeamsController.randomName = function() {
    var first, last, length, i, letters, Letters;

    letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'ä',
        'ö', 'ü', 'ß'];
    Letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'Ä',
        'Ö', 'Ü'];

    length = rng.nextInt(6) + 3;
    first = '';
    first += rng.pick(Letters);
    for (i = 0; i < length; i++) {
      first += rng.pick(letters);
    }

    length = rng.nextInt(6) + 3;
    last = '';
    last += rng.pick(Letters);
    for (i = 0; i < length; i++) {
      last += rng.pick(letters);
    }

    return first + ' ' + last;
  };

  return RegisterTeamsController;
});

/**
 * RegisterIDsController
 *
 * @return RegisterIDsController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/registeridscontroller',['lib/extend', 'core/controller', 'core/view', 'ui/state',
    './teammodel', './playermodel', 'core/random', 'ui/statesaver'], //
function(extend, Controller, View, State, TeamModel, PlayerModel, Random,
    StateSaver) {
  var rng;

  rng = new Random();

  /**
   * Constructor
   */
  function RegisterIDsController($button, $numteams) {
    RegisterIDsController.superconstructor.call(this, new View(undefined,
        $button));

    this.$button = $button;
    this.$numteams = $numteams;

    $button.click(this.registerTeams.bind(this));
  }
  extend(RegisterIDsController, Controller);

  RegisterIDsController.prototype.registerTeams = function() {
    var numTeams, id;

    numTeams = Number(this.$numteams.val());
    if (isNaN(numTeams)) {
      return;
    }

    if (!StateSaver.canSave()) {
      StateSaver.createNewEmptyTree('Tuvero Test-Turnier');
    }

    for (id = 0; id < numTeams; id += 1) {
      State.teams.push(RegisterIDsController.createTeam(id + 1));
    }
  };

  RegisterIDsController.createTeam = function(id) {
    var players, team;

    players = [];
    while (players.length < State.teamsize.get()) {
      players.push(new PlayerModel('' + id));
    }

    team = new TeamModel(players);

    return team;
  };

  return RegisterIDsController;
});

/**
 * RequireModsShortcut
 *
 * @return RequireModsShortcut
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/requiremodsshortcut',['lib/extend', 'core/model'], function(extend, Model) {
  /**
   * Constructor
   */
  function RequireModsShortcut() {
    RequireModsShortcut.superconstructor.call(this);
    window.setTimeout(this.createModsObject.bind(this), 1);
  }
  extend(RequireModsShortcut, Model);

  RequireModsShortcut.prototype.createModsObject = function() {
    var rjsdef, mods;

    if (window.mods !== undefined) {
      return;
    }

    rjsdef = require.s.contexts._.defined;
    if (!rjsdef) {
      console.error('require.s.contexts._.defined is undefined');
      return;
    }

    mods = window.mods = {};

    // add every key to mods, which is similar to the directory tree
    Object.keys(rjsdef).forEach(function(key) {
      var keyparts, subobject;

      keyparts = key.split('/');
      subobject = mods;

      // search the position of the key, add new objects as necessary
      keyparts.forEach(function(part, partid) {
        if (partid >= keyparts.length - 1) {
          subobject[part] = rjsdef[key];

        } else {
          if (subobject[part] === undefined) {
            subobject[part] = {};
          }

          subobject = subobject[part];
        }
      });
    });
  };

  return RequireModsShortcut;
});

/**
 * FinishRoundController
 *
 * @return FinishRoundController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/finishroundcontroller',['lib/extend', 'core/controller', 'core/view', 'ui/state',
    'options'], function(extend, Controller, View, State, Options) {
  /**
   * Constructor
   */
  function FinishRoundController($button) {
    FinishRoundController.superconstructor.call(this, new View(undefined,
        $button));

    this.view.$view.click(this.finishRound.bind(this));
  }
  extend(FinishRoundController, Controller);

  /**
   *
   */
  FinishRoundController.prototype.finishRound = function() {
    State.tournaments.map(function(tournament) {
      var matches, finished;

      matches = tournament.getMatches();

      do {
        finished = true;

        matches.map(function(match) {
          if (match.isRunningMatch()) {
            match.finish(this.getScore(match.length));
            finished = false;
          }
        }, this);

      } while (!finished);
    }, this);
  };

  FinishRoundController.prototype.getScore = function() {
    return [Options.maxpoints, 0];
  };

  return FinishRoundController;
});

/**
 * Instantiates the TabMenuView and abstracts the old Tabs calls to the new
 * TabsMenuView interface.
 *
 * FIXME use TabMenuView directly and remove this file
 *
 * @return TabsHandle
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/tabshandle',['core/tabmenuview', 'jquery'], function(TabMenuView, $) {
  var tabmenu, TabsHandle;

  tabmenu = {
    getTabModel: function() {
      return undefined;
    }
  };

  $(function() {
    if ($('#tabs').length === 1 && $('#testmain').length === 0) {
      tabmenu = new TabMenuView($('#tabs'));
    }

    // hide the lanes tab
    if (tabmenu.getTabModel('lanes')) {
      tabmenu.getTabModel('lanes').visibility.set(false);
    }
  });

  TabsHandle = {
    hide: function(tabname) {
      var tab = tabmenu.getTabModel(tabname);

      if (!tab) {
        return;
      }

      tab.visibility.set(false);
      tab.accessibility.set(false);
    },
    show: function(tabname) {
      var tab = tabmenu.getTabModel(tabname);

      if (!tab) {
        return;
      }

      tab.visibility.set(true);
      tab.accessibility.set(true);
    },
    focus: function(tabname) {
      tabmenu.focus(tabname);
    },
    bindTabOpts: function(tabname, valueModel) {
      var tab = tabmenu.getTabModel(tabname);

      if (!tab) {
        return undefined;
      }

      tab.imgParam.bind(valueModel);
    }
  };

  return TabsHandle;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/debugtab',['lib/extend', 'jquery', 'core/view', './storage', './strings',
    './toast', './loadedimagesview', './browserinfoview',
    './registerteamscontroller', './registeridscontroller',
    './requiremodsshortcut', './finishroundcontroller', './debug',
    './tabshandle', 'ui/statesaver'], function(extend, $, View, Storage,
    Strings, Toast, LoadedImagesView, BrowserInfoView, RegisterTeamsController,
    RegisterIDsController, RequireModsShortcut, FinishRoundController, Debug,
    TabsHandle, StateSaver) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function DebugTab($tab) {
    DebugTab.superconstructor.call(this, undefined, $tab);

    this.init();
  }
  extend(DebugTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  DebugTab.prototype.init = function() {
    var $container, $button;

    /*
     * Show Tab in dev versions
     */
    if (!Debug.isDevVersion) {
      TabsHandle.hide('debug');
    }

    /*
     * show browser info
     */
    $container = this.$view.find('.browser');
    this.browserNameView = new BrowserInfoView($container);

    /*
     * button: clear all
     */
    $container = this.$view.find('.register .delete');
    $container.click(function() {
      StateSaver.removeEverything();
      Storage.clear();
      if (window.localStorage) {
        window.localStorage.clear();
      }
      new Toast(Strings.reset);
    });

    /*
     * images at pageload
     */
    $container = this.$view.find('.allimages');
    this.allImages = new LoadedImagesView($container);

    $container;

    /*
     * buttons: register teams
     */
    $button = this.$view.find('button.registerteams');
    $container = this.$view.find('input.numteams');
    this.registerTeamsController = new RegisterTeamsController($button,
        $container);

    /*
     * buttons: register teams
     */
    $button = this.$view.find('button.registerids');
    $container = this.$view.find('input.numteams');
    this.registerIDsController = new RegisterIDsController($button, //
    $container);

    this.mods = new RequireModsShortcut();

    /*
     * button: finish matches
     */
    $button = this.$view.find('button.finishround');
    this.finishRound = new FinishRoundController($button);
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="debug"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new DebugTab($tab);
    }
  });

  return DebugTab;
});

/**
 * DeleteAllTeamsController
 *
 * @return DeleteAllTeamsController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/deleteallteamscontroller',['lib/extend', 'core/controller', 'ui/state', './strings'], function(
    extend, Controller, State, Strings) {
  /**
   * Constructor
   */
  function DeleteAllTeamsController(view) {
    DeleteAllTeamsController.superconstructor.call(this, view);

    this.view.$view.click(this.confirmDeletion.bind(this));
  }
  extend(DeleteAllTeamsController, Controller);

  /**
   * ask the user if he really wants to delete all teams. abortf if not.
   */
  DeleteAllTeamsController.prototype.confirmDeletion = function() {
    if (State.tournaments.length !== 0) {
      console.error('cannot delete all teams: there are tournaments');
    }

    if (window.confirm(Strings.deleteallteamsconfirmation)) {
      this.performDeletion();
    }
  };

  /**
   * really REALLY delete all registered teams
   */
  DeleteAllTeamsController.prototype.performDeletion = function() {
    State.teams.clear();
  };

  return DeleteAllTeamsController;
});

/**
 * Font Size Controller for adjusting the font size according to user input on
 * the FontSizeView widget
 *
 * @return FontSizeController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/fontsizecontroller',['jquery', 'lib/extend', 'core/controller'], function($, extend, Controller) {

  /**
   * Constructor
   *
   * @param view
   *          the FontSizeView
   */
  function FontSizeController(view) {
    var model;
    FontSizeController.superconstructor.call(this, view);

    model = this.model;

    /**
     * adjust the font size at the click of a button
     */
    this.view.$view.on('click', '> button', function() {
      model.setFontSize($(this).attr('class').replace(/.*fontsize([a-z]+).*/, '$1'));
    });
  }
  extend(FontSizeController, Controller);

  return FontSizeController;
});

/**
 * Model for user-driven and programmatic font size changes
 *
 * @return FontSizeModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/fontsizemodel',['lib/extend', 'core/model'], function(extend, Model) {

  /**
   * FontSizeModel constructor
   */
  function FontSizeModel() {
    FontSizeModel.superconstructor.call(this);

    this.fontsize = FontSizeModel.DEFAULT;
  }
  extend(FontSizeModel, Model);

  /**
   * list of possible font sizes
   */
  FontSizeModel.SIZES = ['tiny', 'small', 'normal', 'large', 'huge'];

  /**
   * default font size
   */
  FontSizeModel.DEFAULT = FontSizeModel.SIZES[2];

  /**
   * @return the current font size
   */
  FontSizeModel.prototype.getFontSize = function() {
    return this.fontsize;
  };

  /**
   * Set the font size. Throws an error if the font size is invalid.
   *
   * @param fontsize
   */
  FontSizeModel.prototype.setFontSize = function(fontsize) {
    if (FontSizeModel.SIZES.indexOf(fontsize) === -1) {
      throw 'invalid font size';
    }
    this.fontsize = fontsize;
    this.emit('update');
  };

  return FontSizeModel;
});

/**
 * Font Size View: A widget for controlling the font size.
 *
 * The FontSizeModel is unique for every DOM element and can be retrieved and
 * controlled using a static function.
 *
 * TODO allow for arbitrary font sizes
 *
 * @return FontSizeView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/fontsizeview',['jquery', 'lib/extend', 'core/view', './fontsizecontroller',
    './fontsizemodel'], function($, extend, View, FontSizeController,
    FontSizeModel) {
  var classprefix;

  classprefix = 'fontsize';

  /**
   * Constructor, which also calls update() for the first time
   *
   * @param $view
   *          the container of the widget
   * @param $container
   *          the container of the size-adjusted text. If undefined, it defaults
   *          to <body>
   */
  function FontSizeView($view, $container) {
    $container = $container || $('body');

    FontSizeView.superconstructor.call(this, FontSizeView
        .getModelOfContainer($container), $view);

    this.$container = $container;

    this.update();

    this.controller = new FontSizeController(this);
  }
  extend(FontSizeView, View);

  /**
   * removes all font size information
   */
  FontSizeView.prototype.reset = function() {
    var $container = this.$container;
    FontSizeModel.SIZES.map(function(size) {
      this.$container.removeClass(classprefix + size);
      this.$view.removeClass(classprefix + size);
    }, this);
  };

  /**
   * sets the current font size, as defined by the model
   */
  FontSizeView.prototype.update = function() {
    this.reset();
    this.$container.addClass(classprefix + this.model.getFontSize());
    this.$view.addClass(classprefix + this.model.getFontSize());
  };

  /**
   * model.emit() callback function
   */
  FontSizeView.prototype.onupdate = function() {
    this.update();
  };

  /**
   * Retrieves the model for the given container. Allocates a new FontSizeModel,
   * if not set yet.
   *
   * @param $container
   *          the container
   * @return the model for the given container
   */
  FontSizeView.getModelOfContainer = function($container) {
    if (!$container.data('FontSizeModel')) {
      $container.data('FontSizeModel', new FontSizeModel());
    }

    return $container.data('FontSizeModel');
  };

  return FontSizeView;
});

/**
 * A TemplateView holds a template element from the DOM, which it prepares for
 * duplication through a subclass, e.g. ListView. Templating is not meant to be
 * handled by the user.
 *
 * @return TemplateView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/templateview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * @param model
   *          the model
   * @param $view
   *          the view DOM element
   * @param $template
   *          the template
   */
  function TemplateView(model, $view, $template) {
    TemplateView.superconstructor.call(this, model, $view);
    this.$template = $template.detach().removeClass('template');
  }
  extend(TemplateView, View);

  return TemplateView;
});

/**
 * Generic View for filling a DOM element with text
 *
 * @return TextView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/textview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * constructor
   *
   * @param text
   *          the initial text
   * @param $view
   *          the containing DOM element
   */
  function TextView(text, $view) {
    TextView.superconstructor.call(this, undefined, $view);

    this.setText(text);
  }
  extend(TextView, View);

  /**
   * change the text of this element
   *
   * @param text
   *          the new text
   */
  TextView.prototype.setText = function(text) {
    if (text === undefined) {
      this.model.text = 'undefined';
    } else {
      this.model.text = text;
    }
    this.model.emit('update');
  };

  /**
   * reset the text to an empty string
   */
  TextView.prototype.reset = function() {
    this.setText('');
  };

  /**
   * write the current text to the DOM element
   */
  TextView.prototype.update = function() {
    this.$view.text(this.model.text);
  };

  /**
   * Callback listener
   */
  TextView.prototype.onupdate = function() {
    this.update();
  };

  return TextView;
});

/**
 * ListView for printing data in a list using arbitrary views
 *
 * @return ListView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/listview',['lib/extend', './templateview', './textview'], function(extend,
    TemplateView, TextView) {
  /**
   * Constructor
   *
   * @param model
   *          the ListModel instance
   * @param $view
   *          the jquery table object
   * @param $template
   *          a template jQuery object, into which to insert the text of each
   *          element. Defaults to a <div>
   * @param SubView
   *          an object constructor for a View of the elements of the list.
   *          Default to TextView
   * @param ...
   *          arbitrary number of additional arguments, which are passed to the
   *          SubView constructor
   */
  function ListView(model, $view, $template, SubView) {
    var i;
    ListView.superconstructor.call(this, model, $view, $template);

    this.SubView = SubView || TextView;
    this.optArgs = [];
    this.subviews = [];

    for (i = 4; i < arguments.length; i += 1) {
      this.optArgs.push(arguments[i]);
    }

    this.update();
  }
  extend(ListView, TemplateView);

  /**
   * reset to an empty state
   */
  ListView.prototype.reset = function() {
    while (this.subviews.length > 0) {
      this.removeItem(0);
    }
  };

  /**
   * redraw everything
   */
  ListView.prototype.update = function() {
    var index;

    this.reset();

    for (index = 0; index < this.model.length; index += 1) {
      this.insertItem(index);
    }
  };

  /**
   * inserts an item into the ListView, using the constructor-specified SubView
   *
   * @param index
   *          the index of the item inside the underlying list
   */
  ListView.prototype.insertItem = function(index) {
    var $subview, subview, model, $previousView, args;

    $subview = this.$template.clone();
    model = this.model.get(index);
    args = this.optArgs.slice(0);
    args.splice(0, 0, null, model, $subview);
    /*
     * Magic: this replaces 'new SubView(model, $subview, optArgs), but enables
     * the use of an arbitrary number of optional arguments
     */
    subview = new (Function.prototype.bind.apply(this.SubView, args));
    if (subview.$view !== $subview) {
      console.error('$subview != subview.$view');
      throw new Error('$subview != subview.$view');
    }

    if (index === this.subviews.length) {
      if (this.insertBeforeView) {
        this.$view.before(subview.$view);
      } else {
        this.$view.append(subview.$view);
      }
    } else {
      $previousView = this.subviews[index].$view;
      $previousView.eq(0).before(subview.$view);
    }
    this.subviews.splice(index, 0, subview);
  };

  /**
   * return the index of the DOM element, or -1
   *
   * @param $view
   *          the DOM element for which to look
   * @return the index of the DOM element inside the underlying list
   */
  ListView.prototype.indexOf = function($view) {
    var $parents, parentindex, index;

    // verify the descendance and ascend to the subview level of the DOM
    $parents = $view.parents();
    parentindex = $parents.index(this.$view);
    switch (parentindex) {
    case -1:
      console.warn('listview.indexOf: '
          + '$view is not a descendant of this.$view');
      return -1;
    case 0:
      // $view is a direct descendant of this.$view, i.e. child
      break;
    default:
      if (this.$template.prop('tagName') !== 'TBODY'
          && $parents.eq(parentindex - 1).prop('tagName') === 'TBODY') {
        // adjust parentindex if we have to step over an automatically inserted
        // tbody element. This is against the standard, but more intuitive
        parentindex -= 1;
        if (parentindex === 0) {
          // NOW, the parentindex is 0
          break;
        }
      }
      $view = $parents.eq(parentindex - 1);
      break;
    }

    /**
     * get the actual index
     */
    index = undefined;
    this.subviews.some(function(subview, subviewid) {
      // Note to self: cannot compare separate jQuery objects directly, but
      // their data() object is unique for each DOM element
      if (subview.$view.data() === $view.data()) {
        index = subviewid;
        return true;
      }
      return false;
    });

    if (index === undefined) {
      return -1;
    }
    return index;
  };

  /**
   * retrieve a subview
   *
   * @param index
   *          the index of the subview
   * @return undefined on failure, a subview reference on success
   */
  ListView.prototype.getSubview = function(index) {
    return this.subviews[index];
  };

  /**
   * remove the item from the DOM and remove all local references as well as its
   * subview
   *
   * @param index
   *          the index of the item upon removal
   */
  ListView.prototype.removeItem = function(index) {
    var subview;

    subview = this.subviews[index];

    if (subview) {
      subview.destroy();
      this.subviews.splice(index, 1);
    }
  };

  /**
   * Emitter Callback function, called right after a new element has been
   * inserted
   *
   * @param model
   *          the ListModel instance
   * @param event
   *          name of the event, i.e. 'insert'
   * @param data
   *          data object, containing at least the index within the list
   */
  ListView.prototype.oninsert = function(model, event, data) {
    this.insertItem(data.id);
  };

  /**
   * Emitter Callback function, called right after the removal of an element
   * from the list
   *
   * @param model
   *          the ListModel instance
   * @param event
   *          name of the event, i.e. 'remove'
   * @param data
   *          data object, containing at least the index within the list
   */
  ListView.prototype.onremove = function(model, event, data) {
    this.removeItem(data.id);
  };

  /**
   * Callback function, event emitted by list.clear()
   */
  ListView.prototype.onreset = function() {
    // Note to self: there should have been 'remove' events. This is just for
    // safety, in case I break the code in a strange way.
    this.reset();
  };

  return ListView;
});

/**
 * PopoutController
 *
 * @return PopoutController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/popoutcontroller',['jquery', 'lib/extend', 'core/controller', 'ui/toast', 'ui/strings',
    'core/classview', 'ui/state', 'core/listener', 'timemachine/timemachine',
    'ui/fontsizeview'], function($, extend, Controller, Toast, Strings, ClassView,
    State, Listener, TimeMachine, FontSizeView) {
  var mainPopout, $fontsizeview, fontsizeview;

  // TODO close a popout when its parent is removed from the DOM

  // TODO allow popouts to be moved to their own window

  // TODO close popout window when all popouts are closed? Or show a hint.

  // TODO destroy all popout views on mainPopout close

  mainPopout = undefined;

  function isMainPopoutOpen() {
    return mainPopout && mainPopout.document;
  }

  function closeMainPopout() {
    if (isMainPopoutOpen()) {
      fontsizeview.destroy();
      // TODO destroy all popout views!
      mainPopout.close();
    }
    mainPopout = undefined;
  }

  timeMachineListener = Listener.bind(TimeMachine, 'unload', closeMainPopout);

  /**
   * close all popout on page leave
   */
  $(function($) {
    $(window).on('beforeunload', closeMainPopout);
  });

  /**
   * Constructor
   */
  function PopoutController(view, cloneFunction) {
    PopoutController.superconstructor.call(this, view);

    this.cloneFunction = cloneFunction;

    if (this.view.$popout) {
      this.view.$popout.click(this.popout.bind(this));
    }
    if (this.view.$close) {
      this.view.$close.click(this.close.bind(this));
    }
    if (this.view.$pageBreak) {
      this.view.$pageBreak.click(this.togglePageBreak.bind(this));
    }
  }
  extend(PopoutController, Controller);

  PopoutController.prototype.popout = function(e) {
    var $popoutView, stylepath, $style, $title, $body;

    $popoutView = this.view.$popoutTemplate.clone();

    if (!isMainPopoutOpen()) {
      console.log('opening new popout');

      mainPopout = window.open('', '', 'location=0');
      $(mainPopout).on('beforeunload', closeMainPopout);

      $style = $('style');
      if ($style.length == 0) {
        stylepath = window.location.href.replace(/index.html[?#].*/,
            'style/main.css');
        $style = $('<link rel="stylesheet" href="' + stylepath + '">');
      } else {
        $style = $style.clone();
      }
      $title = $('title').clone();
      $(mainPopout.document.head).append($style).append($title);

      $body = $(mainPopout.document.body);
      $body.attr('id', 'app').addClass('popoutContainer');
      $body.data({
        maxWidthView: new ClassView(State.tabOptions.nameMaxWidth, $body,
            'maxwidth', 'nomaxwidth'),
        hideNamesView: new ClassView(State.tabOptions.showNames, $body,
            undefined, 'hidenames'),
        showtableClassView: new ClassView(State.tabOptions.showMatchTables,
            $body, 'showmatchtable', 'showtable'),
        hidefinishedClassView: new ClassView(
            State.tabOptions.hideFinishedGroups, $body, 'hidefinished')
      });

      if (!$fontsizeview) {
        $fontsizeview = $('.fontsizeview').eq(1);
      }

      fontsizeview = new FontSizeView($fontsizeview, $body);

    } else {
      console.log('main popout already exists and is open');
    }

    $popoutView.addClass('primaryPopout');
    $(mainPopout.document.body).append($popoutView);
    this.cloneFunction.call(mainPopout, $popoutView);

    window.setTimeout(function() {
      if (!isMainPopoutOpen()) {
        new Toast(Strings.popout_adblocked);
      }
    }, 500);

    e.preventDefault(true);
    return false;
  };

  PopoutController.prototype.close = function(e) {
    console.log('close');

    this.view.destroy();

    e.preventDefault(true);
    return false;
  };

  PopoutController.prototype.togglePageBreak = function(e) {
    this.view.pageBreakModel.set(!this.view.pageBreakModel.get());

    e.preventDefault(true);
    return false;
  };

  return PopoutController;
});

/**
 * PopoutBoxView
 *
 * @return PopoutBoxView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/popoutboxview',['jquery', 'lib/extend', './boxview', './popoutcontroller', 'core/valuemodel',
    'core/classview'], function($, extend, BoxView, PopoutController, ValueModel,
    ClassView) {
  var $iconTemplate, $popoutIconTemplate, $closeIconTemplate, //
  $pageBreakIconTemplate;

  $iconTemplate = $('<div>').addClass('icon').addClass('noprint');

  // TODO read this from DOM.
  $popoutIconTemplate = $iconTemplate.clone().addClass('popout').text('↗');
  $closeIconTemplate = $iconTemplate.clone().addClass('close').text('x');
  $pageBreakIconTemplate = $iconTemplate.clone().addClass('pagebreak')
      .text('⏎');

  /**
   * Constructor
   */
  function PopoutBoxView($view, $popoutTemplate, cloneFunction) {
    PopoutBoxView.superconstructor.call(this, $view);

    this.$popoutTemplate = $popoutTemplate;

    if (this.$view.hasClass('primaryPopout')) {
      this.addCloseIcon();
      this.addPageBreakIcon();
    } else {
      this.addPopoutIcon();
    }

    this.popoutController = new PopoutController(this, cloneFunction);
  }
  extend(PopoutBoxView, BoxView);

  PopoutBoxView.prototype.addPopoutIcon = function() {
    this.$popout = $popoutIconTemplate.clone();
    this.$view.find('>h3:first-child').append(this.$popout);
  };

  PopoutBoxView.prototype.addCloseIcon = function() {
    this.$close = $closeIconTemplate.clone();
    this.$view.find('>h3:first-child').append(this.$close);
  };

  PopoutBoxView.prototype.addPageBreakIcon = function() {
    this.$pageBreak = $pageBreakIconTemplate.clone();
    this.pageBreakModel = new ValueModel(false);
    this.pageBreakView = new ClassView(this.pageBreakModel, this.$view,
        'pagebreak');
    this.$view.find('>h3:first-child').append(this.$pageBreak);
  };

  PopoutBoxView.prototype.destroy = function() {
    if (this.pageBreakModel) {
      this.pageBreakModel.destroy();
    }
    if (this.pageBreakView) {
      this.pageBreakView.destroy();
    }

    PopoutBoxView.superclass.destroy.bind(this);
  };

  return PopoutBoxView;
});

/**
 * TeamTableView: hides th.playercol tags in consecutive occurrences, when their
 * index inside the consecutive occurrence is greater or equal to the number of
 * teams. This allows for the occurrence of multiple teams inside a single row,
 * e.g. for match tables
 *
 * Also hides the whole table if there's no entry in the table.
 *
 * TODO extract the teamsize logic to a ClassView+IsEmptyModel (or something)
 *
 * TODO make this a general TableView, which inherits from ListView and hides as
 * soon as the list is empty
 *
 * @return TeamTableView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamtableview',['jquery', 'lib/extend', 'core/view'], function($, extend, View) {
  /**
   * Constructor
   *
   * @param teamview
   *          a ListView of the table
   * @param teamsize
   *          a ValueModel instance of the team size
   */
  function TeamTableView(teamview, teamsize) {
    TeamTableView.superconstructor.call(this, teamsize, teamview.$view);

    this.teamlist = teamview.model;
    this.teamlist.registerListener(this);

    this.$names = this.$view.find('tr>th');

    this.updateVisibility();
    this.updatePlayerColumns();
  }
  extend(TeamTableView, View);

  /**
   * show one column for each player in a team (teamsize)
   */
  TeamTableView.prototype.updatePlayerColumns = function() {
    var teamsize, teamindex;

    teamsize = this.model.get();
    teamindex = 0;

    this.$names.each(function(index, elem) {
      var $elem;

      $elem = $(elem);

      if ($elem.hasClass('playercol')) {
        if (teamindex < teamsize) {
          $elem.removeClass('hidden');
        } else {
          $elem.addClass('hidden');
        }
        teamindex += 1;
      } else {
        teamindex = 0;
      }
    });
  };

  /**
   * hide the whole table if there's no player; show it as soon as a player has
   * been registered
   */
  TeamTableView.prototype.updateVisibility = function() {
    if (this.teamlist.length === 0) {
      this.$view.addClass('hidden');
    } else {
      this.$view.removeClass('hidden');
    }
  };

  /**
   * the team size changed. check player column visibility
   */
  TeamTableView.prototype.onupdate = function() {
    this.updatePlayerColumns();
  };

  /**
   * the number of teams changed. update the visibility
   */
  TeamTableView.prototype.onresize = function() {
    this.updateVisibility();
  };

  return TeamTableView;
});

/**
 * MatchTableView
 *
 * @return MatchTableView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/matchtableview',['lib/extend', './templateview', './listview', 'core/listener',
    './matchresultview', './teamtableview'], function(extend, TemplateView,
    ListView, Listener, MatchResultView, TeamTableView) {
  /**
   * Constructor
   */
  function MatchTableView(model, $view, teamlist, tournament, teamsize) {
    var $listview;
    MatchTableView.superconstructor.call(this, model, $view, $view
        .find('.match'));

    $listview = this.$view.children('table');
    this.listView = new ListView(this.model, $listview, this.$template,
        MatchResultView, teamlist, tournament);

    this.teamTableView = new TeamTableView(this.listView, teamsize);

    this.$round = this.$view.find('.round');

    this.updateRunningState();
    this.updateGroupNumber();

    var view = this;
    this.groupListener = new Listener(this.model);
    this.groupListener.oninsert = function(emitter, event, data) {
      if (view.model.length === 1) {
        view.updateGroupNumber();
      }
    };
  }
  extend(MatchTableView, TemplateView);

  /**
   * print the group ID as soon as it's available
   */
  MatchTableView.prototype.updateGroupNumber = function() {
    if (this.model.length > 0) {
      this.$round.text(Number(this.model.get(0).getGroup()) + 1);
    }
  };

  MatchTableView.prototype.updateRunningState = function() {
    var i, isRunning;

    isRunning = false;
    for (i = 0; i < this.model.length; i += 1) {
      if (!this.model.get(i).isResult()) {
        isRunning = true;
        break;
      }
    }

    if (isRunning) {
      this.$view.addClass('running');
      this.$view.removeClass('finished');
    } else {
      this.$view.addClass('finished');
      this.$view.removeClass('running');
    }

  };

  /**
   * callback function, which gets called by insert and remove
   *
   * @param emitter
   * @param event
   * @param data
   */
  MatchTableView.prototype.onresize = function(emitter, event, data) {
    this.updateRunningState();
  };

  MatchTableView.prototype.destroy = function() {
    MatchTableView.superclass.destroy.call(this);
    this.listView.destroy();
    this.groupListener.destroy();
  };

  return MatchTableView;
});

/**
 * TournamentRenameController
 *
 * @return TournamentRenameController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentrenamecontroller',['lib/extend', 'ui/renamecontroller'], function(extend, //
RenameController) {
  /**
   * Constructor
   */
  function TournamentRenameController(view) {
    TournamentRenameController.superconstructor.call(this, view, false);
  }
  extend(TournamentRenameController, RenameController);

  TournamentRenameController.prototype.setName = function(name) {
    if (name) {
      this.model.getName().set(name);
      return true;
    }
    return false;
  };

  TournamentRenameController.prototype.getName = function() {
    return this.model.getName().get();
  };

  return TournamentRenameController;
});

/**
 * TournamentMatchesView
 *
 * @return TournamentMatchesView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentmatchesview',['lib/extend', 'core/view', './templateview', './listview',
    './popoutboxview', './teamview', 'core/listener', './matchtableview',
    'ui/tournamentrenamecontroller'], function(extend, View, TemplateView,
    ListView, PopoutBoxView, TeamView, Listener, MatchTableView,
    TournamentRenameController) {
  /**
   * Constructor
   *
   * @param model
   *          a TournamentModel from which all matches are read
   * @param $view
   *          the container
   * @param teamlist
   *          a ListModel of all TeamModels. Is referenced by ID by
   *          model.getMatches()
   * @param teamsize
   *          a ValueModel which represents the number of players in a team
   */
  function TournamentMatchesView(model, $view, teamlist, teamsize) {
    var $popoutTemplate = $view.clone();
    TournamentMatchesView.superconstructor.call(this, model, $view, //
    $view.find('.template.voteview'));

    this.renameController = new TournamentRenameController(new View(model,
        this.$view.find('.tournamentname.rename')));
    this.boxview = new PopoutBoxView(this.$view, $popoutTemplate, function(
        $view) {
      return new TournamentMatchesView(model, $view, teamlist, teamsize);
    });

    this.$names = this.$view.find('.tournamentname');
    this.teamlist = teamlist;
    this.teamsize = teamsize;

    this.initMatches();

    this.initVotes();

    Listener.bind(this.model.getName(), 'update', this.updateNames.bind(this));

    this.updateNames();
  }
  extend(TournamentMatchesView, TemplateView);

  /**
   * initializes matchtable
   */
  TournamentMatchesView.prototype.initMatches = function() {
    this.$matchtable = this.$view.find('.matchtable');
    this.matchtable = new MatchTableView(this.model.getMatches(),
        this.$matchtable, this.teamlist, this.model, this.teamsize);

    Listener.bind(this.model.getMatches(), 'resize', this.updateVisibility
        .bind(this));

    this.updateVisibility();
  };

  TournamentMatchesView.prototype.updateVisibility = function() {
    if (this.model.getMatches().length === 0) {
      this.$view.addClass('hidden');
    } else {
      this.$view.removeClass('hidden');
    }
  };

  /**
   * initialize all vote lists and tables
   */
  TournamentMatchesView.prototype.initVotes = function() {
    var $votetemplate;

    this.$view.find('.votelist').hide();

    $votetemplate = this.$template;

    this.votelistmodels = this.model.VOTES.map(function(votetype) {
      var $votes, votelist;

      $votes = this.$view.find('.votelist.' + votetype);
      if ($votes.length === 0) {
        return undefined;
      }

      votelist = this.model.getVotes(votetype);

      // TODO use some shared View, e.g. ListEmptyView, to hide the whole
      // view when the list is empty
      Listener.bind(votelist, 'resize', function(emitter, event, data) {
        if (emitter.length === 0) {
          $votes.hide();
        } else {
          $votes.show();
        }
      });

      if (votelist.length !== 0) {
        $votes.show();
      }

      return new ListView(votelist, $votes, $votetemplate, TeamView,//
      this.teamlist);
    }, this);
  };

  TournamentMatchesView.prototype.updateNames = function() {
    this.$names.text(this.model.getName().get());
  };

  return TournamentMatchesView;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/gamestab',['lib/extend', 'jquery', 'core/view', './listview', 'ui/state',
    './checkboxview', 'core/classview', './tournamentmatchesview',
    'ui/tabshandle'], function(extend, $, View, ListView, State, CheckBoxView,
    ClassView, TournamentMatchesView, TabsHandle) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function GamesTab($tab) {
    GamesTab.superconstructor.call(this, undefined, $tab);

    this.init();

    this.update();

    State.tournaments.registerListener(this);
  }
  extend(GamesTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  GamesTab.prototype.init = function() {
    var $template, $container, value;

    // tournamentlist
    $container = this.$view.find('.tournamentlist');
    $template = $container.find('.tournament.template');
    this.tournamentList = new ListView(State.tournaments, $container,
        $template, TournamentMatchesView, State.teams, State.teamsize);

    // name maxwidth checkbox
    value = State.tabOptions.nameMaxWidth;
    $container = this.$view.find('>.options input.maxwidth');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, 'maxwidth',
        'nomaxwidth');

    // player names checkbox
    value = State.tabOptions.showNames;
    $container = this.$view.find('>.options input.shownames');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, undefined,
        'hidenames');
  };

  /**
   * show/hide the tab and update it as necessary
   */
  GamesTab.prototype.update = function() {
    var i, isRunning;

    isRunning = false;

    for (i = 0; !isRunning && i < State.tournaments.length; i += 1) {
      isRunning = State.tournaments.get(i).getState().get() === 'running';
    }

    if (isRunning) {
      TabsHandle.show('games');
    } else {
      TabsHandle.hide('games');
    }
  };

  /**
   * a tournament state has been changed
   *
   * @param emitter
   * @param event
   * @param data
   */
  GamesTab.prototype.onupdate = function(emitter, event, //
  data) {
    if (emitter !== State.tournaments) {
      this.update();
    }
  };

  /**
   * a tournament has been added
   *
   * @param emitter
   * @param event
   * @param data
   */
  GamesTab.prototype.oninsert = function(emitter, event, //
  data) {
    data.object.getState().registerListener(this);
    this.update();
  };

  /**
   * a tournament has been removed
   *
   * @param emitter
   * @param event
   * @param data
   */
  GamesTab.prototype.onremove = function(emitter, event, //
  data) {
    data.object.getState().unregisterListener(this);
    this.update();
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="games"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new GamesTab($tab);
    }
  });

  return GamesTab;
});

/**
 * InlineListView
 *
 * @return InlineListView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/inlinelistview',['lib/extend', './listview'], function(extend, ListView) {
  /**
   * Constructor
   *
   * @param model
   *          the ListModel instance
   * @param $view
   *          the jquery table object
   * @param $template
   *          a template jQuery object, into which to insert the text of each
   *          element. Defaults to a <div>
   * @param SubView
   *          an object constructor for a View of the elements of the list.
   *          Default to TextView
   * @param ...
   *          arbitrary number of additional arguments, which are passed to the
   *          SubView constructor
   */
  function InlineListView(model, $view, $template, SubView) {
    this.insertBeforeView = true;
    InlineListView.superconstructor.apply(this, arguments);
  }
  extend(InlineListView, ListView);

  return InlineListView;
});

/**
 * ProgressRowView
 *
 * @return ProgressRowView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/progressrowview',['lib/extend', './templateview', './teamview', './listview', //
'core/listmodel', './inlinelistview', 'core/listener', './matchresultview'], //
function(extend, TemplateView, TeamView, ListView, ListModel, InlineListView,
    Listener, MatchResultView) {
  /**
   * Constructor
   */
  function ProgressRowView(matches, $view, teamlist, tournament) {
    var teamno = matches.get(0).getTeamID(0);
    ProgressRowView.superconstructor.call(this, teamlist.get(teamno), $view,
        $view.find('.template'));

    this.ranking = tournament.getRanking();
    this.$separator = this.$view.find('.hidden.separator');
    this.rankingList = new ListModel();

    this.teamView = new TeamView(this.model, $view);

    // TODO defer
    this.updatePending = false;
    Listener.bind(this.ranking, 'update', function() {
      if (!this.updatePending) {
        window.setTimeout(this.updateRank.bind(this), 1);
        this.updatePending = true;
      }
    }, this);

    this.matches = new InlineListView(matches, this.$separator, this.$template
        .filter('.match'), MatchResultView, teamlist, tournament);

    this.ranks = new ListView(this.rankingList, this.$view, this.$template
        .filter('.rankingcomponent'));

    this.updateRank();
  }
  extend(ProgressRowView, TemplateView);

  ProgressRowView.prototype.updateRank = function() {
    var ranking, rankIndex, order;

    ranking = this.ranking.get();
    rankIndex = ranking.ids.indexOf(this.model.getID());

    order = ranking.components.slice(0);
    order.push('ranks');

    order.forEach(function(component, index) {
      var value = ranking[component][rankIndex];
      if (component === 'ranks') {
        value += 1;
      }

      if (this.rankingList.length === index) {
        this.rankingList.push(value);
      } else if (this.rankingList.get(index) != value) {
        this.rankingList.set(index, value);
      }
    }, this);

    this.updatePending = false;
  };

  return ProgressRowView;
});

/**
 * ReverseMatchReferenceModel
 *
 * @return ReverseMatchReferenceModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/reversematchreferencemodel',['lib/extend', 'core/matchreferencemodel'], function(extend,
    MatchReferenceModel) {
  /**
   * Constructor
   */
  function ReverseMatchReferenceModel(match, teamlist) {
    ReverseMatchReferenceModel.superconstructor.call(this, match, teamlist);
    this.teams.reverse();
  }
  extend(ReverseMatchReferenceModel, MatchReferenceModel);

  /**
   * used by TournamentModel.correct() to determine whether the teams are
   * reversed
   */
  ReverseMatchReferenceModel.prototype.hasReversedTeams = true;

  /**
   * reverse the score before finishing the match
   *
   * @param score
   *          an array of score numbers
   * @return true on success, undefined otherwise
   */
  ReverseMatchReferenceModel.prototype.finish = function(score) {
    score = score.slice();
    score.reverse();
    return ReverseMatchReferenceModel.superclass.finish.call(this, score);
  };

  return ReverseMatchReferenceModel;
});

/**
 * ReverseResultReferenceModel
 *
 * @return ReverseResultReferenceModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/reverseresultreferencemodel',['lib/extend', 'core/resultreferencemodel'], function(extend,
    ResultReferenceModel) {
  /**
   * Constructor
   */
  function ReverseResultReferenceModel(result, teamlist) {
    ReverseResultReferenceModel.superconstructor.call(this, result, teamlist);
    if (this.isBye()) {
      return;
    }

    this.teams.reverse();
    this.score.reverse();
  }
  extend(ReverseResultReferenceModel, ResultReferenceModel);

  /**
   * used by TournamentModel.correct() to determine whether the teams are
   * reversed
   */
  ReverseResultReferenceModel.prototype.hasReversedTeams = true;

  return ReverseResultReferenceModel;
});

/**
 * ProgressListModel
 *
 * @return ProgressListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/progresslistmodel',['lib/extend', 'core/binningreferencelistmodel',
    'core/sortedreferencelistmodel', 'core/combinedreferencelistmodel',
    'core/referencelistmodel', './reversematchreferencemodel',
    './reverseresultreferencemodel'], function(extend,
    BinningReferenceListModel, SortedReferenceListModel,
    CombinedReferenceListModel, ReferenceListModel, ReverseMatchReferenceModel,
    ReverseResultReferenceModel) {

  /**
   * Constructor
   */
  function ProgressListModel(tournament) {
    ProgressListModel.superconstructor.call(this, this
        .createSortedList(tournament), this.binningFunction);
  }
  extend(ProgressListModel, BinningReferenceListModel);

  /**
   * @param tournament
   *          a TournamentModel instance
   * @return a ListModel containing all matches and their reversed counterparts
   */
  ProgressListModel.prototype.createCombinedList = function(tournament) {
    var matches, reverseMatches, history, reverseHistory;

    matches = tournament.getMatches();
    reverseMatches = new ReferenceListModel(matches, undefined,
        ReverseMatchReferenceModel);
    history = tournament.getHistory();
    reverseHistory = new ReferenceListModel(history, undefined,
        ReverseResultReferenceModel);

    return new CombinedReferenceListModel(matches, reverseMatches, history,
        reverseHistory);
  };

  /**
   * @param tournament
   *          a TournamentModel instance
   * @return a sorted ListModel containing all matches and their reversed
   *         counterparts, where the matches are unique (e.g. no duplicate byes)
   */
  ProgressListModel.prototype.createSortedList = function(tournament) {
    return new SortedReferenceListModel(this.createCombinedList(tournament),
        this.sortFunction, true);
  };

  /**
   * @param a
   *          a MatchModel instance
   * @param b
   *          another MatchModel instance
   * @return the order relation between the two
   */
  ProgressListModel.prototype.sortFunction = function(a, b) {
    return a.getTeamID(0) - b.getTeamID(0) || a.getGroup() - b.getGroup();
  };

  /**
   * @param match
   *          a MatchModel instance
   * @return the first team id of the match, as used in a progress table
   */
  ProgressListModel.prototype.binningFunction = function(match) {
    return match.getTeamID(0);
  };

  return ProgressListModel;
});

/**
 * ProgressRoundView
 *
 * @return ProgressRoundView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/progressroundview',['lib/extend', 'core/view'], function(extend, View, StateClassView) {
  /**
   * Constructor
   *
   * @param round
   *          the index of the current round
   * @param $view
   *          the view
   */
  function ProgressRoundView(round, $view) {
    ProgressRoundView.superconstructor.call(this, undefined, $view);

    this.round = round;
    this.$round = this.$view.find('.round');

    this.updateRound();
  }
  extend(ProgressRoundView, View);

  ProgressRoundView.prototype.updateRound = function() {
    this.$round.text(this.round + 1);
  };

  ProgressRoundView.prototype.onstate = function() {
    this.updateRound();
  };

  return ProgressRoundView;
});

/**
 * ProgressTableView
 *
 * @return ProgressTableView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/progresstableview',['lib/extend', './templateview', './listview', './inlinelistview',
    './teamtableview', './progressrowview', './progresslistmodel', './strings',
    'core/listmodel', './progressroundview', 'core/listener'], function(extend,
    TemplateView, ListView, InlineListView, TeamTableView, ProgressRowView,
    ProgressListModel, Strings, ListModel, ProgressRoundView, Listener) {
  /**
   * Constructor
   *
   * @param tournament
   *          a TournamentModel instance
   * @param $view
   *          the table
   * @param groups
   *          a BinningReferenceListModel of MatchReferenceModels which are
   *          grouped by their match group
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @param teamsize
   *          a ValueModel which represents the size of all registered teams
   */
  function ProgressTableView(tournament, $view, groups, teamlist, teamsize) {
    this.$table = $view.find('.progresstable');
    ProgressTableView.superconstructor.call(this, new ProgressListModel(
        tournament), $view, this.$table.find('tr.template,th.template'));

    this.$separator = this.$table.find('th.hidden.separator');

    // progress table rows
    this.listView = new ListView(this.model, this.$table, this.$template
        .filter('.progressrow'), ProgressRowView, teamlist, tournament);

    // teamsize adjustments
    this.teamTableView = new TeamTableView(this.listView, teamsize);

    // table headers for every round
    this.roundHeaderView = new InlineListView(groups.getBinNames(),
        this.$separator, this.$template.filter('.roundcol'), //
        ProgressRoundView);

    // table headers for every ranking component + 'ranks'
    this.rankingComponents = new ListModel();
    this.$headerRow = this.$table.find('.headerrow');
    this.rankingComponentHeaderView = new ListView(this.rankingComponents,
        this.$headerRow, this.$template.filter('.rankcol'));

    // regular update of this.rankingComponents
    this.ranking = tournament.getRanking();
    Listener.bind(this.ranking, 'update', this.updateRankingComponents
        .bind(this));
    this.updateRankingComponents();
  }
  extend(ProgressTableView, TemplateView);

  /**
   * Read the ranking components from tournament.getRanking() and add missing
   * components to the list of components, to be displayed via a ListView
   */
  ProgressTableView.prototype.updateRankingComponents = function() {
    var order = this.ranking.get().components.slice();
    order.push('ranks');

    order.forEach(function(componentName, index) {
      var name = Strings['ranking_medium_' + componentName];

      if (this.rankingComponents.length === index) {
        this.rankingComponents.push(name);
      } else if (this.rankingComponents.get(index) !== name) {
        this.rankingComponents.set(index, name);
      }
    }, this);

    while (this.rankingComponents.length > order.length) {
      this.rankingComponents.pop();
    }
  };

  return ProgressTableView;
});

/**
 * KOListModel
 *
 * @return KOListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kolistmodel',['lib/extend', 'core/binningreferencelistmodel'], function(extend,
    BinningReferenceListModel) {

  /**
   * Constructor
   *
   * @param tournament
   *          a KOTournamentModel instance
   */
  function KOListModel(tournament) {
    KOListModel.superconstructor.call(this, tournament.getCombinedHistory(),
        this.binningFunction);
  }
  extend(KOListModel, BinningReferenceListModel);

  /**
   * @param match
   *          a MatchModel instance
   * @return which KO Tree Group this match belongs to. The match for third
   *         place is shown in the tree for first place, and so on.
   */
  KOListModel.prototype.binningFunction = function(match) {
    /*
     * Just strip the '1' bit from the match group, if it's set
     *
     * If you're reading this and don't understand the following bit operations,
     * have a look at the following url for clarification:
     * http://stackoverflow.com/questions/3920307/how-can-i-remove-a-flag-in-c
     */
    return match.getGroup(0) & ~0x1;
  };

  return KOListModel;
});

/**
 * KOTreePosition
 *
 * @return KOTreePosition
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kotreeposition',['core/kotournamentmodel'], function(KOTournamentModel) {
  var leftPadding, topPadding, width, height, shortWidth;

  width = 17;
  shortWidth = 7;
  height = 4;
  topPadding = -2;
  leftPadding = 1;

  /**
   * Constructor
   *
   * @param id
   *          a match id
   * @param group
   *          a KO match group
   * @param numTeams
   *          the total number of teams in the tournament
   * @param showNames
   *          whether the boxes should be wide enough to include names
   */
  function KOTreePosition(id, group, numTeams, showNames) {
    this.id = id;
    this.group = group;
    this.numTeams = numTeams;
    this.showNames = showNames;
    this.round = KOTournamentModel.roundOfMatchID(this.id);
    this.isThirdPlace = (this.group & 0x1) === 1;
    this.firstid = KOTournamentModel.firstMatchIDOfRound(this.round);
    this.firstRound = Math.min(//
    KOTournamentModel.initialRoundForTeams(this.numTeams), //
    KOTournamentModel.roundsInGroup(this.group & ~0x1) - 1);

    this.x = this.calcXPosition();
    this.y = this.calcYPosition();
  }

  /**
   * calculate the x position (css: left) from the given parameters
   *
   * @return the x position
   */
  KOTreePosition.prototype.calcXPosition = function() {
    return leftPadding + (this.firstRound - this.round) * this.getWidth();
  };

  KOTreePosition.prototype.getWidth = function() {
    return KOTreePosition.getWidth(this.showNames);
  };

  /**
   * calculate the y position (css: top) from the given parameters
   *
   * @return the y position
   */
  KOTreePosition.prototype.calcYPosition = function() {
    var y, yFactor;

    yFactor = Math.pow(2, this.firstRound - this.round - 1);

    // padding
    y = topPadding;

    // position of first match in this round
    y += height * yFactor;

    // offset from first match in this round
    y += height * 2 * yFactor * (this.id - this.firstid);

    // third place offset
    if (this.isThirdPlace) {
      y += height * 1.5;
    }

    return y;
  };

  /**
   * @return a KOTreePosition instance which represents the position of the
   *         following match in the hierarchy
   *
   */
  KOTreePosition.prototype.getFollowingPosition = function() {
    var nextID = KOTournamentModel.nextRoundMatchID(this.id);

    return new KOTreePosition(nextID, this.group, this.numTeams, //
    this.showNames);
  };

  KOTreePosition.getWidth = function(showNames) {
    if (showNames) {
      return width;
    }
    return shortWidth;
  };

  KOTreePosition.HEIGHT = height;
  KOTreePosition.TOPPADDING = topPadding;
  KOTreePosition.LEFTPADDING = leftPadding;

  return KOTreePosition;
});

/**
 * KOMatchResultView
 *
 * @return KOMatchResultView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/komatchresultview',['lib/extend', './matchresultview', './kotreeposition'], //
function(extend, MatchResultView, KOTreePosition) {
  /**
   * Constructor
   *
   * @param model
   *          a MatchResult instance
   * @param $view
   *          the container element
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @param tournament
   *          a TournamentModel instance
   */
  function KOMatchResultView(model, $view, teamlist, tournament, showNames) {
    KOMatchResultView.superconstructor.call(this, model, $view, teamlist,
        tournament);

    this.tournament = tournament;
    this.showNames = showNames;

    this.reposition();

    showNames.registerListener(this);
  }
  extend(KOMatchResultView, MatchResultView);

  KOMatchResultView.prototype.reposition = function() {
    var pos = new KOTreePosition(this.model.getID(), this.model.getGroup(),
        this.tournament.getTeams().length, this.showNames.get());

    this.x = pos.x;
    this.y = pos.y;

    this.$view.css('left', this.x + 'em');
    this.$view.css('top', this.y + 'em');
  };

  KOMatchResultView.prototype.onupdate = function() {
    this.reposition();
  };

  return KOMatchResultView;
});

/**
 * No Description
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/koline',['./strings'], function(Strings) {
  function generateCacheID(from, midx, to) {
    return [from[0], from[1], midx, to[0], to[1]].join(':');
  }

  /**
   * converts a style object to a style attribute string
   *
   * TODO move to its own tiny CSS library?
   *
   * @param style
   *          a style object
   * @return a combined string of the styles, as used by the HTML style attr.
   */
  function styleToString(style) {
    var key, strings;

    strings = [];

    for (key in style) {
      if (style.hasOwnProperty(key)) {
        strings.push([key, style[key]].join(': '));
      }
    }

    return strings.join('; ');
  }

  /**
   * create an empty SVG element
   *
   * @param width
   *          the width, in em
   * @param height
   *          the height, in em
   * @param left
   *          the x-position, in em
   * @param top
   *          the y-position, in em
   * @return a newly instantiated svg DOM element
   */
  function createSVG(width, height, left, top) {
    var svg, style;

    style = {
      position: 'absolute',
      width: width + 'em',
      height: height + 'em',
      left: left + 'em',
      top: top + 'em',
      overflow: 'visible'
    };

    svg = document.createElementNS(KOLine.SVGNS, 'svg');
    svg.setAttributeNS(null, 'style', styleToString(style));

    return svg;
  }

  /**
   * creates a SVG line
   *
   * @param from
   *          the start position, in em
   * @param to
   *          the end position, in em
   * @return the SVG line DOM object
   */
  function createSVGLine(from, to) {
    var line;

    line = document.createElementNS(KOLine.SVGNS, 'line');
    line.setAttributeNS(null, 'x1', from[0] + 'em');
    line.setAttributeNS(null, 'y1', from[1] + 'em');
    line.setAttributeNS(null, 'x2', to[0] + 'em');
    line.setAttributeNS(null, 'y2', to[1] + 'em');

    return line;
  }

  /**
   * creates a perpendicular connector path out of SVG lines.
   *
   * Actual SVG paths seem to require pixel coordinates, while this solution
   * enables the use of font-relative sizes (em)
   *
   * @param from
   *          the start point, in em
   * @param to
   *          the end point, in em
   * @return a SVG object, which correctly represents the path
   */
  function createSVGPath(from, to) {
    var midx, mid1, mid2, group, pathid;

    midx = (from[0] + to[0]) / 2;

    pathid = generateCacheID(from, midx, to);

    if (KOLine.pathCache[pathid]) {
      group = KOLine.pathCache[pathid].cloneNode(true);
    } else {
      mid1 = [midx, from[1]];
      mid2 = [midx, to[1]];

      group = document.createElementNS(KOLine.SVGNS, 'g');
      group.setAttributeNS(null, 'stroke', 'black');
      group.setAttributeNS(null, 'stroke-width', '2');
      group.setAttributeNS(null, 'stroke-linecap', 'round');

      group.appendChild(createSVGLine(from, mid1));
      group.appendChild(createSVGLine(mid1, mid2));
      group.appendChild(createSVGLine(mid2, to));

      KOLine.pathCache[pathid] = group.cloneNode(true);
    }

    return group;
  }

  /**
   * KOLine, a representative class of the perpendicular connector path, as used
   * in binary KO tournament trees
   *
   * @param from
   *          the start position, in em
   * @param to
   *          the end position, in em
   * @return the path object (this). The SVG DOM element can be accessed as
   *          this.svg and is supposed to be jQuery-compatible
   */
  function KOLine(from, to) {
    var width, height, left, right, top, bottom;

    left = Math.min(from[0], to[0]);
    right = Math.max(from[0], to[0]);
    top = Math.min(from[1], to[1]);
    bottom = Math.max(from[1], to[1]);

    width = right - left + 1;
    height = bottom - top + 1;

    from = [from[0] - left, from[1] - top];
    to = [to[0] - left, to[1] - top];

    this.svg = createSVG(width, height, left, top);
    this.svg.appendChild(createSVGPath(from, to));

    return this;
  }
  /**
   * the svg namespace string
   */
  KOLine.SVGNS = Strings.svgns;
  /**
   * an object cache, which will be used for similar paths instead of creating
   * them over and over again. May not be necessary, but won't hurt, either
   */
  KOLine.pathCache = {};

  return KOLine;
});

/**
 * KOLineView
 *
 * @return KOLineView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kolineview',['lib/extend', 'core/view', 'jquery', './koline', './kotreeposition'], //
function(extend, View, $, KOLine, KOTreePosition) {
  /**
   * Constructor
   *
   * @param model
   *          a MatchResult instance
   * @param $view
   *          the container element
   * @param numTeams
   *          the total number of teams in the KO tournament
   * @param showNames
   *          a ValueModel which evaluates to true if names should be shown
   */
  function KOLineView(model, $view, numTeams, showNames) {
    KOLineView.superconstructor.call(this, model, $view);

    this.numTeams = numTeams;
    this.showNames = showNames;

    this.render();

    showNames.registerListener(this);
  }
  extend(KOLineView, View);

  KOLineView.prototype.clear = function() {
    if (this.$line) {
      this.$line.remove();
      this.$line = undefined;
    }
  };

  KOLineView.prototype.render = function() {
    this.clear();

    if (this.model.getID() > 1) {
      this.$line = this.createLine();
      this.$view.append(this.$line);
    }
  };

  /**
   * @param model
   *          a MatchModel instance
   * @param numTeams
   *          the total number of teams in the KO tournament
   * @return a jquery object of a KO line, ready to be inserted
   */
  KOLineView.prototype.createLine = function() {
    var line, from, to, pos;

    pos = new KOTreePosition(this.model.getID(), this.model.getGroup(),
        this.numTeams, this.showNames.get());

    this.x = pos.x;
    this.y = pos.y;

    pos = pos.getFollowingPosition();

    from = [this.x + KOTreePosition.getWidth(this.showNames.get()) - 1,
        this.y + 2];
    to = [pos.x + 0.4, pos.y + 2];

    line = new KOLine(from, to);
    return $(line.svg).addClass('.koline');
  };

  KOLineView.prototype.onupdate = function(emitter, event, data) {
    this.render();
  };

  return KOLineView;
});

/**
 * KOTreeView
 *
 * @return KOTreeView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kotreeview',['lib/extend', './templateview', './listview', './inlinelistview',
    './komatchresultview', 'core/kotournamentmodel', './kotreeposition',
    './kolineview', './boxview'], function(extend, TemplateView, ListView,
    InlineListView, KOMatchResultView, KOTournamentModel, KOTreePosition,
    KOLineView, BoxView) {
  /**
   * Constructor
   *
   * @param tournament
   *          a TournamentModel instance
   * @param $view
   *          the table
   * @param groups
   *          a BinningReferenceListModel of MatchReferenceModels which are
   *          grouped by their match group
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @param teamsize
   *          a ValueModel which represents the size of all registered teams
   * @param showNames
   *          a ValueModel which evaluates to true if names should be shown
   */
  function KOTreeView(model, $view, teamlist, tournament, teamsize, showNames) {
    KOTreeView.superconstructor.call(this, model, $view, $view
        .find('.komatchresult.template'));

    this.group = this.model.get(0).getGroup() & ~0x1;
    this.boxView = new BoxView(this.$view);

    this.showNames = showNames;
    this.tournament = tournament;
    this.$forest = this.$view.find('.forest');
    this.$kolineanchor = this.$forest.find('.kolineanchor');
    this.$bestrank = this.$view.find('.bestrank');

    this.lines = new InlineListView(this.model, this.$kolineanchor,
        this.$kolineanchor.clone(), KOLineView, tournament.getTeams().length,
        showNames);

    this.matches = new ListView(this.model, this.$forest, this.$template,
        KOMatchResultView, teamlist, tournament, showNames);

    this.updateGroupInformation();
    this.setSize();

    showNames.registerListener(this);
  }
  extend(KOTreeView, TemplateView);

  /**
   * print the best possible rank for this group
   */
  KOTreeView.prototype.updateGroupInformation = function() {
    var bestrank = this.group * 2 + 1;

    this.$bestrank.text(bestrank);
  };

  /**
   * set the size of $forest to match the tree. It's necessary since the tree
   * nodes are absolutely positioned, so the div doesn't flow around them
   * automatically.
   */
  KOTreeView.prototype.setSize = function() {
    var numTeams, numRounds, thirdPlacePos, lowestPos, x, y, isTopAligned;

    numTeams = this.tournament.getTeams().length;

    thirdPlacePos = new KOTreePosition(1, this.group + 1, numTeams,
        this.showNames.get());

    lowestID = KOTournamentModel
        .firstMatchIDOfRound(thirdPlacePos.firstRound + 1) - 1;
    lowestPos = new KOTreePosition(lowestID, this.group, numTeams,
        this.showNames.get());

    if (this.group === 0) {
      numRounds = KOTournamentModel.initialRoundForTeams(numTeams) + 1;
    } else {
      numRounds = KOTournamentModel.roundsInGroup(this.group);
    }

    isTopAligned = KOTournamentModel.numMatchesInRound(numRounds) == numTeams;

    x = thirdPlacePos.x;
    y = Math.max(lowestPos.y, thirdPlacePos.y);

    x += KOTreePosition.getWidth(this.showNames.get());
    y += KOTreePosition.HEIGHT;

    this.$forest.css('width', x + 'em');
    this.$forest.css('height', y + 'em');
    this.$forest.css('margin-top', isTopAligned ? '0em' : '-2.5em');
  };

  /**
   * 'update'-listener for showNames
   *
   * @param emitter ==
   *          this.showNames
   * @param event ==
   *          'update'
   * @param data
   *          a data object
   */
  KOTreeView.prototype.onupdate = function(emitter, event, data) {
    this.setSize();
  };

  return KOTreeView;
});

/**
 * KOHistoryView
 *
 * @return KOHistoryView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kohistoryview',['lib/extend', './templateview', './listview', './kolistmodel',
    './kotreeview'], function(extend, TemplateView, ListView, KOListModel,
    KOTreeView) {
  /**
   * Constructor
   *
   * @param tournament
   *          a TournamentModel instance
   * @param $view
   *          the table
   * @param groups
   *          a BinningReferenceListModel of MatchReferenceModels which are
   *          grouped by their match group
   * @param teamlist
   *          a ListModel of TeamModel instances
   * @param teamsize
   *          a ValueModel which represents the size of all registered teams
   * @param showNames
   *          a ValueModel which evaluates to true if names should be shown
   */
  function KOHistoryView(tournament, $view, groups, teamlist, teamsize,
      showNames) {
    KOHistoryView.superconstructor.call(this, new KOListModel(tournament),
        $view, $view.find('.progressrow.template'));

    this.$kotree = this.$view.find('.kotree').detach();

    // nested ListViews: BinningReferenceListModel is 2D
    this.kotrees = new ListView(this.model, this.$view, this.$kotree,
        KOTreeView, teamlist, tournament, teamsize, showNames);
  }
  extend(KOHistoryView, TemplateView);

  return KOHistoryView;
});

/**
 * GenericTournamentHistoryView
 *
 * @return GenericTournamentHistoryView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/generictournamenthistoryview',['lib/extend', 'core/view', './progresstableview', './kohistoryview'], //
function(extend, View, ProgressTableView, KOHistoryView) {
  var types;

  types = {
    swiss: {
      constructor: ProgressTableView,
      selector: '.progresstable',
      showlists: true
    },
    round: {
      constructor: ProgressTableView,
      selector: '.progresstable',
      showlists: true
    },
    ko: {
      constructor: KOHistoryView,
      selector: '.kotree',
      showlists: false
    }
  };

  /**
   * Constructor
   *
   * @param tournament
   *          a TournamentModel instance
   * @param $view
   *          a DOM element
   * @param groups
   *          a ListModel with the group names
   * @param teamlist
   *          a ListModel of TeamModels which are referenced by teamIDs
   * @param teamsize
   *          a ValueModel of the current default team size
   * @param showNames
   *          a ValueModel, which evaluates to true if names should be shown
   */
  function GenericTournamentHistoryView(tournament, $view, groups, teamlist,
      teamsize, showNames) {
    var Constructor, $subview, type;
    GenericTournamentHistoryView.superconstructor.call(this, undefined, $view);

    this.tournament = tournament;
    type = types[tournament.SYSTEM];
    if (tournament && type) {
      $subview = this.$view.find(type.selector);
      $subview.removeClass('hidden');
      // don't display the matchtable on default anymore, since there's a more
      // sophisticated view in place
      $view.addClass('hastable');
      Constructor = type.constructor;
      this.view = new Constructor(tournament, $view, groups, teamlist, //
      teamsize, showNames);
      this.showlists = !!type.showlists;
    } else {
      this.view = new View(undefined, $view);
      this.showlists = true;
    }
  }
  extend(GenericTournamentHistoryView, View);

  GenericTournamentHistoryView.prototype.destroy = function() {
    this.view.destroy();
    GenericTournamentHistoryView.superclass.destroy.call(this);
  };

  return GenericTournamentHistoryView;
});

/**
 * StateClassView
 *
 * TODO write a test page
 *
 * @return StateClassView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/stateclassview',['lib/extend', 'core/view'], function(extend, View) {
  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance, preferably a StateModel
   * @param $view
   */
  function StateClassView(model, $view) {
    StateClassView.superconstructor.call(this, model, $view);

    this.currentClass = undefined;

    this.update();
  }
  extend(StateClassView, View);

  /**
   * change the class to the value of this.model.get()
   */
  StateClassView.prototype.update = function() {
    var newClass;

    newClass = this.model.get();
    if (newClass !== this.currentClass) {
      this.$view.removeClass(this.currentClass);
      this.$view.addClass(newClass);
      this.currentClass = newClass;
    }
  };

  /**
   * Callback function to monitor value changes
   */
  StateClassView.prototype.onupdate = function() {
    this.update();
  };

  return StateClassView;
});

/**
 * TournamentController
 *
 * @return TournamentController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentcontroller',['lib/extend', 'ui/renamecontroller', './toast', './strings'], //
function(extend, RenameController, Toast, Strings) {
  var pendingNameChange;

  pendingNameChange = undefined;

  /**
   * Constructor
   *
   * @param view
   *          a TournamentView instance
   */
  function TournamentController(view, tournaments) {
    var tournament, rankingOrder;
    TournamentController.superconstructor.call(this, view, false);

    tournament = this.model.tournament;
    rankingOrder = this.model.rankingOrder;

    this.toast = undefined;

    this.$runbutton = this.view.$view.find('button.runtournament');
    this.$closebutton = this.view.$view.find('button.closetournament');

    this.$runbutton.click(function() {
      if (tournament.getState().get() === 'initial') {
        if (rankingOrder.length < 1) {
          tournament.emit('error', 'not enough ranking components');
          return;
        }
        if (!tournament.setRankingOrder(rankingOrder.asArray())) {
          return;
        }
      }
      tournament.run();
    });

    this.$closebutton.click(function() {
      var state;

      if (tournament.finish()) {
        tournaments.closeTournament(tournament.getID());
        new Toast(Strings.tournamentfinished);
      } else {
        new Toast(Strings.gamesstillrunning, Toast.LONG);
      }
    });

    if (pendingNameChange === this.model.tournament) {
      this.view.$view.find('.rename').eq(0).click();
      window.setTimeout(this.$rename.focus.bind(this.$rename), 1);
      window.setTimeout(this.$rename.select.bind(this.$rename), 1);
    }
  }
  extend(TournamentController, RenameController);

  TournamentController.prototype.getName = function() {
    return this.model.tournament.getName().get();
  };

  TournamentController.prototype.setName = function(name) {
    if (!name) {
      return false;
    }

    this.model.tournament.getName().set(name);

    pendingNameChange = undefined;

    return true;
  };

  TournamentController.initiateNameChange = function(tournament) {
    pendingNameChange = tournament;
  };

  TournamentController.prototype.destroy = function() {
  };

  return TournamentController;
});

/**
 * RankingComponentView
 *
 * @return RankingComponentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/rankingcomponentview',['lib/extend', 'ui/textview', 'ui/strings'], function(extend, TextView,
    Strings) {

  /**
   * Look for a prepared text representation within the Strings global object.
   *
   * @param text
   *          the key
   * @return if available, the string representation. if not, the key itself.
   */
  function getString(text) {
    return Strings['ranking_' + text] || text;
  }

  /**
   * Constructor
   *
   * @param name
   *          the name of the RankingComponent, e.g. "wins"
   * @param $view
   *          a JQuery object into which the component information is to be
   *          written
   */
  function RankingComponentView(name, $view) {
    RankingComponentView.superconstructor.call(this, name, $view);
  }
  extend(RankingComponentView, TextView);

  /**
   * set the "value" attribute to the text and read the displayed text from
   * Strings
   */
  RankingComponentView.prototype.update = function() {
    this.$view.val(this.model.text);
    this.$view.text(getString(this.model.text));
  };

  return RankingComponentView;
});

/**
 * RankingOrderController: Handle buttons and keypresses in the
 * RankingOrderView. This Controller has slightly more logic than a pure
 * controller, in that it moves items between lists, but this avoids having to
 * inherit a new model from ListModel, so different ListModels can be used as a
 * model for the view.
 *
 * @return RankingOrderController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/rankingordercontroller',['jquery', 'lib/extend', 'core/controller'], function($, extend, Controller) {
  /**
   * Constructor
   *
   * @param view
   *          a valid RankingOrderView instance
   */
  function RankingOrderController(view) {
    var selected, available;

    RankingOrderController.superconstructor.call(this, view);

    selected = this.view.selected;
    allComponents = this.view.allComponents;

    this.view.$selectedList.on('click', '.component', function() {
      selected.remove($(this).index());
    });

    this.view.$availableList.on('click', '.component', function() {
      selected.push(allComponents.get($(this).index()));
    });
  }
  extend(RankingOrderController, Controller);

  return RankingOrderController;
});

/**
 * RankingOrderView
 *
 * @return RankingOrderView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/rankingorderview',['jquery', 'lib/extend', './templateview', './rankingcomponentview', './listview',
    './rankingordercontroller'], function($, extend, TemplateView,
    RankingComponentView, ListView, RankingOrderController) {
  /**
   * Constructor
   *
   * @param selectedComponents
   * @param $view
   * @param allComponents
   */
  function RankingOrderView(selectedComponents, $view, allComponents) {
    RankingOrderView.superconstructor.call(this, selectedComponents, $view,
        $view.find('.template'));

    this.selected = selectedComponents;
    this.allComponents = allComponents;

    this.$availableList = this.$view.find('.available');
    this.$selectedList = this.$view.find('.selected');

    this.selectedListView = new ListView(selectedComponents,
        this.$selectedList, this.$template, RankingComponentView);
    this.availableListView = new ListView(allComponents, this.$availableList,
        this.$template, RankingComponentView);

    this.controller = new RankingOrderController(this);

    this.update();
  }
  extend(RankingOrderView, TemplateView);

  /**
   * automatically show/hide already selected values from the list of available
   * items
   */
  RankingOrderView.prototype.update = function() {
    var model = this.model;
    this.$availableList.find('.component').each(function(index) {
      var $option = $(this);
      if (model.indexOf($option.val()) === -1) {
        $option.removeClass('hidden');
      } else {
        $option.addClass('hidden');
      }
    });
  };

  /**
   * an item has been inserted into the left list. Update the right list.
   */
  RankingOrderView.prototype.oninsert = function() {
    this.update();
  };

  /**
   * an item has been removed from the left list. Update the right list.
   */
  RankingOrderView.prototype.onremove = function() {
    this.update();
  };

  return RankingOrderView;
});

/**
 * TournamentView
 *
 * @return TournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentview',['jquery', 'lib/extend', 'core/view', 'ui/stateclassview', 'core/listener',
    './tournamentcontroller', 'core/listmodel', './boxview', 'presets',
    './rankingorderview', './strings'], function($, extend, View, StateClassView,
    Listener, TournamentController, ListModel, BoxView, Presets,
    RankingOrderView, Strings) {
  /**
   * Constructor
   *
   * @param model
   *          a TournamentModel instance
   * @param $view
   */
  function TournamentView(tournament, $view, tournaments) {
    var $advancedOptions;
    TournamentView.superconstructor.call(this, undefined, $view);

    this.$view.attr('rowspan', tournament.getTeams().length);

    this.model.tournament = tournament;
    this.model.rankingOrder = new ListModel(
        this.model.tournament.ranking.componentnames);

    this.stateClassView = new StateClassView(tournament.getState(), $view);

    this.$name = this.$view.find('.tournamentname');
    this.$round = this.$view.find('.round');
    this.$nextround = this.$view.find('.nextround');

    this.$initial = this.$view.find('.initial');
    this.$running = this.$view.find('.running');
    this.$idle = this.$view.find('.idle');
    this.$finished = this.$view.find('.finished');

    this.$advancedOptions = this.$view.find('.tournamentoptions.boxview');
    if (this.$advancedOptions.length > 0) {
      this.advancedOptions = $advancedOptions = [];
      this.$advancedOptions.each(function() {
        $advancedOptions.push(new BoxView($(this)));
      });
    }

    this.initRankingOrderView();

    Listener.bind(this.model.tournament.getName(), 'update', this.updateNames
        .bind(this));

    this.updateNames();
    this.updateRound();

    this.controller = new TournamentController(this, tournaments);
  }
  extend(TournamentView, View);

  /**
   * initiate a RankingOrderView, if necessary
   */
  TournamentView.prototype.initRankingOrderView = function() {
    var availableComponents;

    this.$rankingOrderView = this.$view.find('.rankingorderview');
    if (this.$rankingOrderView.length > 0) {
      availableComponents = Presets.ranking.components.slice(0);
      this.model.tournament.getRanking().get().components.forEach(function(
          component) {
        if (availableComponents.indexOf(component) === -1) {
          availableComponents.push(component);
        }
      });

      availableComponents.sort(function(a, b) {
        a = Strings['ranking_' + a] || a;
        b = Strings['ranking_' + b] || b;
        return a.localeCompare(b);
      });

      this.rankingOrderView = new RankingOrderView(this.model.rankingOrder,
          this.$rankingOrderView.eq(0), new ListModel(availableComponents));
    }
  };

  /**
   * update the displayed tournament name
   */
  TournamentView.prototype.updateNames = function() {
    this.$name.text(this.model.tournament.getName().get());
  };

  /**
   * update the displayed tournament round
   */
  TournamentView.prototype.updateRound = function() {
    if (this.model.tournament.getRound) {
      this.$round.text(this.model.tournament.getRound() + 1);
      this.$nextround.text(this.model.tournament.getRound() + 2);
    }
  };

  TournamentView.prototype.onstate = function() {
    this.updateRound();
  };

  TournamentView.prototype.destroy = function() {
    this.controller.destroy();
    if (this.subcontroller && this.subcontroller.destroy) {
      this.subcontroller.destroy();
    }

    if (this.rankingOrderView) {
      this.rankingOrderView.destroy();
    }

    this.stateClassView.destroy();

    TournamentView.superclass.destroy.call(this);
  };

  return TournamentView;
});

/**
 * RoundTournamentView
 *
 * @return RoundTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/roundtournamentview',['lib/extend', './tournamentview'], function(extend, TournamentView) {
  /**
   * Constructor
   *
   * @param model
   *          a RoundTournamentModel instance
   * @param $view
   *          a DOM element to fill
   */
  function RoundTournamentView(model, $view, tournaments) {
    RoundTournamentView.superconstructor.call(this, model, $view, tournaments);

    this.subcontroller = undefined;

    this.updateRound();
  }
  extend(RoundTournamentView, TournamentView);

  return RoundTournamentView;
});

/**
 * SwissTournamentController
 *
 * @return SwissTournamentController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swisstournamentcontroller',['jquery', 'lib/extend', 'core/controller', 'core/listener',
    'core/propertyvaluemodel'], function($, extend, Controller, Listener,
    PropertyValueModel) {
  /**
   * Constructor
   *
   * @param view
   *          a SwissTournamentView instance
   */
  function SwissTournamentController(view) {
    var $mode, $noshuffle, tournament, noshuffle;

    SwissTournamentController.superconstructor.call(this, view);

    tournament = this.model.tournament;
    noshuffle = this.model.noshuffle;

    this.$options = this.view.$view.find('.tournamentoptions');
    $mode = this.$options.find('select.mode');
    $noshuffle = this.$options.find('input.noshuffle');

    $mode.change(function() {
      tournament.setProperty('swissmode', $(this).val());
      $mode.val($(this).val());
      tournament.setProperty('swisstranspose', tournament
          .getProperty('swissmode') === 'halves');
    });

    Listener.bind(noshuffle, 'update', function() {
      tournament.setProperty('swissshuffle', !noshuffle.get());
    });

    this.initSpecialWinsProperties();
  }
  extend(SwissTournamentController, Controller);

  /**
   * update the visibility and properties
   */
  SwissTournamentController.prototype.initSpecialWinsProperties = function() {
    var modevalue, votesenabled;

    modevalue = new PropertyValueModel(this.model.tournament, 'swissmode');
    votesenabled = new PropertyValueModel(this.model.tournament, //
    'enableupdown');
    byeafterbye = new PropertyValueModel(this.model.tournament, 'byeafterbye');

    Listener.bind(modevalue, 'update', function() {
      votesenabled.set(modevalue.get() === 'wins');
      if (!votesenabled.get()) {
        byeafterbye.set(false);
      }
    });
  };

  return SwissTournamentController;
});

/**
 * SwissVotePropController
 *
 * @return SwissVotePropController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swissvotepropcontroller',['lib/extend', 'core/controller'], function(extend, Controller) {
  /**
   * Constructor
   *
   * @param view
   *          a SwissVotePropView instance
   */
  function SwissVotePropController(view) {
    SwissVotePropController.superconstructor.call(this, view);

    this.view.$view.click(this.toggleValue.bind(this));
  }
  extend(SwissVotePropController, Controller);

  /**
   * toggles the boolean value of the underlying model.
   */
  SwissVotePropController.prototype.toggleValue = function() {
    this.model.set(!this.model.get());
  };

  return SwissVotePropController;
});

/**
 * SwissVotePropView
 *
 * @return SwissVotePropView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swissvotepropview',['lib/extend', 'core/classview', './swissvotepropcontroller'], function(
    extend, ClassView, SwissVotePropController) {
  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance, which has a boolean value
   * @param $view
   *          a '.swissvotes .prop' DOM element
   */
  function SwissVotePropView(model, $view) {
    SwissVotePropView.superconstructor.call(this, model, $view, undefined,
        'forbidden');

    this.controller = new SwissVotePropController(this);
  }
  extend(SwissVotePropView, ClassView);

  return SwissVotePropView;
});

/**
 * SwissVotesView
 *
 * @return SwissVotesView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swissvotesview',['jquery', 'lib/extend', 'core/view', './boxview', './swissvotepropview',
    'core/propertyvaluemodel', 'core/classview'], function($, extend, View,
    BoxView, SwissVotePropView, PropertyValueModel, ClassView) {
  /**
   * Constructor
   *
   * @param model
   *          a TournamentModel instance
   * @param $view
   *          the associated DOM element
   */
  function SwissVotesView(model, $view) {
    SwissVotesView.superconstructor.call(this, model, $view);

    this.boxview = new BoxView(this.$view.find('.boxview'));

    this.votesenabled = new PropertyValueModel(this.model, 'enableupdown');
    this.hiddenclassview = new ClassView(this.votesenabled, this.$view,
        undefined, 'hidden');

    this.initProps();
  }
  extend(SwissVotesView, View);

  /**
   * for every .prop subview, initiate a SwissVotePropView
   */
  SwissVotesView.prototype.initProps = function() {
    var tournament, regex;

    tournament = this.model;
    regex = /^(\S*\s)*(\S+after\S+)(\s\S*)*$/; // extract "XafterY" string
    this.$view.find('.prop').each(
        function() {
          var prop, $view;
          $view = $(this);
          prop = $view.attr('class').replace(regex, '$2');
          return new SwissVotePropView(
              new PropertyValueModel(tournament, prop), $view);
        });
  };

  return SwissVotesView;
});

/**
 * A ValueView, which updates the value of ValueModel to the DOM
 *
 * @return ValueView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/valueview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance, which implements get() and emits update
   * @param $view
   *          the associated DOM element
   */
  function ValueView(model, $view) {
    ValueView.superconstructor.call(this, model, $view);

    this.update();
  }
  extend(ValueView, View);

  /**
   * write the contents of get() to the DOM
   */
  ValueView.prototype.update = function() {
    var value = this.model.get();
    if (value === undefined) {
      this.$view.text('undefined');
    } else {
      this.$view.text(value);
    }
  };

  /**
   * Callback listener
   */
  ValueView.prototype.onupdate = function() {
    this.update();
  };

  return ValueView;
});

/**
 * SwissMaxRoundView
 *
 * @return SwissMaxRoundView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swissmaxroundview',['lib/extend', 'core/view', 'core/valuemodel', 'ui/valueview',
    'core/propertyvaluemodel', 'core/listener', 'core/swisstournamentmodel'], //
function(extend, View, ValueModel, ValueView, PropertyValueModel, Listener,
    SwissTournamentModel) {
  /**
   * Constructor
   */
  function SwissMaxRoundView(model, $view) {
    SwissMaxRoundView.superconstructor.call(this, model, $view);

    this.maxrounds = new ValueModel(0);
    this.maxroundsview = new ValueView(this.maxrounds, this.$view
        .find('.maxrounds'));

    this.teams = this.model.getTeams();

    this.$view.find('.numteams').text(this.teams.length);

    this.mode = new PropertyValueModel(this.model, 'swissmode');

    this.modeListener = Listener.bind(this.mode, 'update', this.update
        .bind(this));

    this.update();
  }
  extend(SwissMaxRoundView, View);

  SwissMaxRoundView.prototype.update = function() {
    switch (this.mode.get()) {
    case SwissTournamentModel.MODES.wins:
      this.maxrounds.set(Math.ceil(Math.log(this.teams.length) / Math.log(2)));
      break;
    default:
      this.maxrounds.set(this.teams.length - 1);
      break;
    }
  };

  SwissMaxRoundView.prototype.destroy = function() {

    this.modeListener.destroy();
    this.mode.destroy();
    this.maxroundsview.destroy();
    this.maxrounds.destroy();

    SwissMaxRoundView.superclass.destroy.call(this);
  };

  return SwissMaxRoundView;
});

/**
 * SwissTournamentView
 *
 * @return SwissTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/swisstournamentview',['lib/extend', './tournamentview', './swisstournamentcontroller',
    'core/valuemodel', './checkboxview', './swissvotesview',
    'ui/swissmaxroundview'], function(extend, TournamentView,
    SwissTournamentController, ValueModel, CheckBoxView, SwissVotesView,
    SwissMaxRoundView) {
  /**
   * Constructor
   *
   * @param model
   *          a SwissTournamentModel instance
   * @param $view
   *          a jquery DOM element
   */
  function SwissTournamentView(model, $view, tournaments) {
    SwissTournamentView.superconstructor.call(this, model, $view, tournaments);

    // set noshuffle
    this.model.noshuffle = new ValueModel(!this.model.tournament
        .getProperty('swissshuffle'));
    // use noshuffle checkboxes
    this.noshufflecheckboxview = {
      initial: new CheckBoxView(this.model.noshuffle, this.$view
          .find('.initial .tournamentoptions .option input.noshuffle')),
      idle: new CheckBoxView(this.model.noshuffle, this.$view
          .find('.idle .tournamentoptions .option input.noshuffle'))
    };

    this.maxroundview = new SwissMaxRoundView(this.model.tournament, $view
        .find('.swissmaxroundview'));

    // read the swiss mode
    this.$view.find('.tournamentoptions .option select.mode').val(
        this.model.tournament.getProperty('swissmode'));

    this.swissvotes = new SwissVotesView(this.model.tournament, this.$view
        .find('.option.swissvotes'));

    this.subcontroller = new SwissTournamentController(this);
  }
  extend(SwissTournamentView, TournamentView);

  return SwissTournamentView;
});

/**
 * KOTournamentController
 *
 * @return KOTournamentController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kotournamentcontroller',['jquery', 'lib/extend', 'core/controller', 'core/listener'], function($, extend,
    Controller, Listener) {
  /**
   * Constructor
   *
   * @param view
   *          a SwissTournamentView instance
   */
  function KOTournamentController(view) {
    var $mode, $noshuffle, tournament, initialByes;

    KOTournamentController.superconstructor.call(this, view);

    tournament = this.model.tournament;
    initialByes = this.model.initialByes;

    this.$options = this.view.$view.find('.tournamentoptions');
    $mode = this.$options.find('select.mode');
    $noshuffle = this.$options.find('input.initialbyes');

    $mode.change(function() {
      tournament.setProperty('komode', $(this).val());
      $mode.val($(this).val());
    });

    Listener.bind(initialByes, 'update', function() {
      tournament.setProperty('initialbyes', initialByes.get());
    });
  }
  extend(KOTournamentController, Controller);

  return KOTournamentController;
});

/**
 * KOTournamentView
 *
 * @return KOTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/kotournamentview',['lib/extend', './tournamentview', 'core/valuemodel', './checkboxview',
    './kotournamentcontroller'], function(extend, TournamentView, ValueModel,
    CheckBoxView, KOTournamentController) {
  /**
   * Constructor
   *
   * @param model
   *          a RoundTournamentModel instance
   * @param $view
   *          a DOM element to fill
   */
  function KOTournamentView(model, $view, tournaments) {
    KOTournamentView.superconstructor.call(this, model, $view, tournaments);

    // set the initial value of the ValueModel
    this.model.initialByes = new ValueModel(this.model.tournament
        .getProperty('initialbyes'));
    // use checkboxes
    this.initialbyescheckboxview = new CheckBoxView(this.model.initialByes, //
    this.$view.find('.initial .tournamentoptions .option input.initialbyes'));

    // read the ko mode
    this.$view.find('.tournamentoptions .option select.mode').val(
        this.model.tournament.getProperty('komode'));

    this.subcontroller = new KOTournamentController(this);
  }
  extend(KOTournamentView, TournamentView);

  return KOTournamentView;
});

/**
 * GenericTournamentView
 *
 * @return GenericTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/generictournamentview',['lib/extend', 'core/view', './tournamentview', './roundtournamentview',
    './swisstournamentview', './kotournamentview'], function(extend, View, //
TournamentView, RoundTournamentView, SwissTournamentView, KOTournamentView) {
  var constructors, defaultConstructor;

  constructors = {
    swiss: SwissTournamentView,
    round: RoundTournamentView,
    ko: KOTournamentView
  };

  defaultConstructor = TournamentView;

  /**
   * Constructor
   */
  function GenericTournamentView(tournament, $view, tournaments) {
    var Constructor;
    GenericTournamentView.superconstructor.call(this, undefined, $view);

    this.tournament = tournament;
    if (tournament) {
      Constructor = constructors[tournament.SYSTEM] || defaultConstructor;
      this.view = new Constructor(tournament, $view, tournaments);
    } else {
      this.view = new View(undefined, $view);
    }

    /*
     * Note: for some unknown reason, the prototype chain ignores
     * 'prototype.destroy'
     */
    this.destroy = GenericTournamentView.destroy;
  }
  extend(GenericTournamentView, View);

  GenericTournamentView.destroy = function() {
    this.view.destroy();
    GenericTournamentView.superclass.destroy.call(this);
  };

  return GenericTournamentView;
});

/**
 * TournamentHistoryView
 *
 * @return TournamentHistoryView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamenthistoryview',['lib/extend', 'core/view', './listview', './popoutboxview',
    'core/listener', 'core/binningreferencelistmodel', './matchtableview',
    './generictournamenthistoryview', 'ui/tournamentrenamecontroller'], //
function(extend, View, ListView, PopoutBoxView, Listener,
    BinningReferenceListModel, MatchTableView, GenericTournamentHistoryView,
    TournamentRenameController) {

  /**
   * Constructor
   *
   * @param model
   *          a TournamentModel from which all matches are read
   * @param $view
   *          the container
   * @param teamlist
   *          a ListModel of all TeamModels. Is referenced by ID by
   *          model.getCombinedHistory()
   * @param teamsize
   *          a ValueModel which represents the number of players in a team
   * @param showNames
   *          a ValueModel which evaluates to true if the names should be shown
   */
  function TournamentHistoryView(model, $view, teamlist, teamsize, showNames) {
    var $popoutTemplate = $view.clone();
    TournamentHistoryView.superconstructor.call(this, model, $view);

    this.renameController = new TournamentRenameController(new View(model,
        this.$view.find('.tournamentname.rename')));
    this.boxview = new PopoutBoxView(this.$view, $popoutTemplate, function(
        $view) {
      return new TournamentHistoryView(model, $view, teamlist, teamsize,
          showNames);
    });

    this.$names = this.$view.find('.tournamentname');
    this.teamlist = teamlist;
    this.teamsize = teamsize;
    this.showNames = showNames;

    this.groups = new BinningReferenceListModel(
        this.model.getCombinedHistory(), TournamentHistoryView.groupFilter);

    this.initGenericView();
    this.initMatches();

    Listener.bind(this.model.getName(), 'update', this.updateNames.bind(this));

    Listener.bind(this.model.getCombinedHistory(), 'resize',
        this.updateVisibility.bind(this));

    this.updateVisibility();

    this.updateNames();
  }
  extend(TournamentHistoryView, View);

  TournamentHistoryView.groupFilter = function(matchresult) {
    return matchresult.getGroup();
  };

  /**
   * initializes matchtable
   */
  TournamentHistoryView.prototype.initMatches = function() {
    this.$matchtable = this.$view.find('.matchtable');

    if (this.genericView.showlists) {
      // nested ListViews: BinningReferenceListModel is 2D
      this.matchtable = new ListView(this.groups, this.$view, this.$matchtable,
          MatchTableView, this.teamlist, this.model, this.teamsize);

      this.$view.addClass('haslists');
    } else {
      this.$matchtable.remove();
      this.matchtable = undefined;
    }
  };

  TournamentHistoryView.prototype.initGenericView = function() {
    this.genericView = new GenericTournamentHistoryView(this.model, this.$view,
        this.groups, this.teamlist, this.teamsize, this.showNames);
  };

  TournamentHistoryView.prototype.updateVisibility = function() {
    if (this.model.getCombinedHistory().length === 0) {
      this.$view.addClass('hidden');
    } else {
      this.$view.removeClass('hidden');
    }
  };

  TournamentHistoryView.prototype.updateNames = function() {
    this.$names.text(this.model.getName().get());
  };

  return TournamentHistoryView;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/historytab',['lib/extend', 'jquery', 'core/view', './listview', 'ui/state',
    './checkboxview', 'core/classview', './tournamenthistoryview',
    './closedtournamentcollapselistener', 'ui/tabshandle'], function(extend, $,
    View, ListView, State, CheckBoxView, ClassView, TournamentHistoryView,
    ClosedTournamentCollapseListener, TabsHandle) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function HistoryTab($tab) {
    HistoryTab.superconstructor.call(this, undefined, $tab);

    this.init();

    this.update();

    State.tournaments.registerListener(this);
  }
  extend(HistoryTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  HistoryTab.prototype.init = function() {
    var $template, $container, value;

    // tournamentlist
    $container = this.$view.find('.tournamentlist');
    $template = $container.find('.tournament.template');
    this.tournamentList = new ListView(State.tournaments, $container,
        $template, TournamentHistoryView, State.teams, State.teamsize,
        State.tabOptions.showNames);

    // HACK: close tournaments
    this.collapseListener = new ClosedTournamentCollapseListener(
        this.tournamentList);

    // name maxwidth checkbox
    value = State.tabOptions.nameMaxWidth;
    $container = this.$view.find('>.options input.maxwidth');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, 'maxwidth',
        'nomaxwidth');

    // player names checkbox
    value = State.tabOptions.showNames;
    $container = this.$view.find('>.options input.shownames');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, undefined,
        'hidenames');

    // list/table selection checkbox
    value = State.tabOptions.showMatchTables;
    $container = this.$view.find('>.options input.showtable');
    this.showtableCheckBoxView = new CheckBoxView(value, $container);
    this.showtableClassView = new ClassView(value, this.$view,
        'showmatchtable', 'showtable');

    // hidefinished checkbox
    value = State.tabOptions.hideFinishedGroups;
    $container = this.$view.find('>.options input.hidefinished');
    this.hidefinishedCheckBoxView = new CheckBoxView(value, $container);
    this.hidefinishedClassView = new ClassView(value, this.$view,
        'hidefinished');
  };

  /**
   * show/hide the tab and update it as necessary
   */
  HistoryTab.prototype.update = function() {
    var i, hasHistory;

    hasHistory = false;

    for (i = 0; !hasHistory && i < State.tournaments.length; i += 1) {
      hasHistory = State.tournaments.get(i).getCombinedHistory().length > 0;

      if (hasHistory) {
        break;
      }
    }

    if (hasHistory) {
      TabsHandle.show('history');
    } else {
      TabsHandle.hide('history');
    }
  };

  /**
   * a tournament state has been changed
   *
   * @param emitter
   * @param event
   * @param data
   */
  HistoryTab.prototype.onresize = function(emitter, event, //
  data) {
    this.update();
  };

  /**
   * a tournament has been added
   *
   * @param emitter
   * @param event
   * @param data
   */
  HistoryTab.prototype.oninsert = function(emitter, event, //
  data) {
    if (emitter === State.tournaments) {
      data.object.getCombinedHistory().registerListener(this);
    }
    this.update();
  };

  /**
   * a tournament has been removed
   *
   * @param emitter
   * @param event
   * @param data
   */
  HistoryTab.prototype.onremove = function(emitter, event, //
  data) {
    if (emitter === State.tournaments) {
      data.object.getHistory().unregisterListener(this);
    }
    this.update();
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="history"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new HistoryTab($tab);
    }
  });

  return HistoryTab;
});

/**
 * TimeMachineCommitController
 *
 * @return TimeMachineCommitController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/timemachinecommitcontroller',['lib/extend', 'ui/renamecontroller', 'timemachine/timemachine',
    'ui/stateloader', 'ui/strings', 'ui/toast', 'ui/filesavermodel'], //
function(extend, RenameController, TimeMachine, StateLoader, Strings, Toast,
    FileSaverModel) {
  /**
   * Constructor
   */
  function TimeMachineCommitController(view) {
    TimeMachineCommitController.superconstructor.call(this, view, false);

    this.view.$view.find('button.removecommit').click(this.remove.bind(this));
    this.view.$view.find('button.loaddescendant').click(this.load.bind(this));
    this.view.$view.find('button.cleanuptree').click(this.cleanup.bind(this));
    this.view.$view.find('button.download').click(this.download.bind(this));
  }
  extend(TimeMachineCommitController, RenameController);

  TimeMachineCommitController.prototype.remove = function() {
    var active, confirmtext, name;

    active = TimeMachine.isRelatedToActive(this.model);
    name = this.model.getTreeName() || 'noname';

    confirmtext = active ? Strings.confirmactivetreeremoval
        : Strings.confirmtreeremoval;

    if (window.confirm(confirmtext.replace('%s', name))) {

      this.model.remove();

      if (active) {
        StateLoader.unload();
      }
    }
  };

  TimeMachineCommitController.prototype.cleanup = function() {
    TimeMachine.cleanup(this.model, 0);
  };

  TimeMachineCommitController.prototype.load = function() {
    StateLoader.loadCommit(this.model.getYoungestDescendant() || this.model);
  };

  TimeMachineCommitController.prototype.download = function() {
    var fileSaver;

    fileSaver = new FileSaverModel(this.model.getYoungestDescendant()
        || this.model);
    if (!fileSaver.save()) {
      new Toast(Strings.savefailed);
    }
  };

  TimeMachineCommitController.prototype.getName = function(name) {
    return this.model.getTreeName();
  };

  TimeMachineCommitController.prototype.setName = function(name) {
    if (name) {
      this.model.setTreeName(name);
      return true;
    }
    return false;
  };
  return TimeMachineCommitController;
});

/**
 * TimeMachineCommitView
 *
 * @return TimeMachineCommitView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/timemachinecommitview',['lib/extend', 'core/view', 'timemachine/timemachine',
    'core/valuemodel', 'ui/valueview', 'core/classview',
    'ui/timemachinecommitcontroller', 'ui/boxview'], function(extend, View,
    TimeMachine, ValueModel, ValueView, ClassView, TimeMachineCommitController,
    BoxView) {
  /**
   * Constructor
   */
  function TimeMachineCommitView(model, $view) {
    TimeMachineCommitView.superconstructor.call(this, model, $view);

    this.boxView = new BoxView(this.$view);

    this.nameView = new ValueView(new ValueModel(), this.$view.find('.name'));
    this.startDateView = new ValueView(new ValueModel(), this.$view
        .find('.startdate'));
    this.saveDateView = new ValueView(new ValueModel(), this.$view
        .find('.savedate'));
    this.sizeView = new ValueView(new ValueModel(), this.$view.find('.size'));
    this.activeView = new ClassView(new ValueModel(false), this.$view,
        'activetree');

    this.updateName();
    this.updateStartDate();
    this.updateSaveDate();
    this.updateSize();
    this.updateActive();

    this.controller = new TimeMachineCommitController(this);

    TimeMachine.registerListener(this);
  }
  extend(TimeMachineCommitView, View);

  TimeMachineCommitView.prototype.updateName = function() {
    this.nameView.model.set(this.model.getTreeName());
  };

  TimeMachineCommitView.prototype.updateStartDate = function() {
    var startDate = new Date(this.model.key.startDate);
    this.startDateView.model.set(startDate.toLocaleString());
  };

  TimeMachineCommitView.prototype.updateSaveDate = function() {
    var youngestAncestor, saveDate;

    youngestAncestor = this.model.getYoungestDescendant() || this.model;
    saveDate = new Date(youngestAncestor.key.saveDate);

    this.saveDateView.model.set(saveDate.toLocaleString());
  };

  TimeMachineCommitView.prototype.updateSize = function() {
    var size = TimeMachine.usedRelatedStorage(this.model);
    size = Math.round(size / 102.4) / 10;
    this.sizeView.model.set(size + 'kB');
  };

  TimeMachineCommitView.prototype.updateActive = function() {
    this.activeView.model.set(TimeMachine.isRelatedToActive(this.model));
  };

  TimeMachineCommitView.prototype.onsave = function(event, emitter, commit) {
    if (commit.key.isRelated(this.model.key)) {
      this.updateSaveDate();
      this.updateSize();
    }
  };

  TimeMachineCommitView.prototype.onremove = function(event, emitter, commit) {
    if (commit && !commit.isRoot()) {
      this.updateSaveDate();
      this.updateSize();
    }
  };

  TimeMachineCommitView.prototype.oninit = function(event, emitter, commit) {
    this.updateActive();
  };

  TimeMachineCommitView.prototype.onload = function(event, emitter, commit) {
    this.updateActive();
  };

  TimeMachineCommitView.prototype.oncleanup = function(event, emitter, commit) {
    this.updateSize();
  };

  TimeMachineCommitView.prototype.onrename = function(event, emitter, newname) {
    this.updateName();
  };

  TimeMachineCommitView.prototype.destroy = function() {
    this.nameView.destroy();
    this.startDateView.destroy();
    this.saveDateView.destroy();
    this.sizeView.destroy();

    this.nameView.model.destroy();
    this.startDateView.model.destroy();
    this.saveDateView.model.destroy();
    this.sizeView.model.destroy();

    this.boxView.destroy();

    TimeMachineCommitView.superclass.destroy.call(this);
  };

  return TimeMachineCommitView;
});

/**
 * TimeMachineNewTreeController
 *
 * @return TimeMachineNewTreeController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/timemachinenewtreecontroller',['lib/extend', 'core/controller', 'ui/statesaver'], function(extend,
    Controller, StateSaver) {
  /**
   * Constructor
   */
  function TimeMachineNewTreeController(view) {
    TimeMachineNewTreeController.superconstructor.call(this, view);

    this.$input = this.view.$view.find('input.treename');
    this.$button = this.view.$view.find('button.createroot');

    this.$input.keydown(this.inputKey.bind(this));
    this.$button.click(this.create.bind(this));
  }
  extend(TimeMachineNewTreeController, Controller);

  /**
   * create a new tree. If no name has been set yet, focus the name input.
   *
   * @return true. always.
   */
  TimeMachineNewTreeController.prototype.create = function() {
    var name;

    name = this.$input.val();
    if (!name) {
      this.$input.focus();
      return;
    }

    if (StateSaver.createNewEmptyTree(name)) {
      this.$input.val('');
    }

    return true;
  };

  /**
   * If Enter is pressed, create a new tree. Default input otherwise.
   *
   * @param evt
   * @return false if event propagation should be stopped
   */
  TimeMachineNewTreeController.prototype.inputKey = function(evt) {
    if (evt.which == 13) {
      // enter
      this.$button.click();

      evt.preventDefault();
      return false;
    }

    return true;
  };

  return TimeMachineNewTreeController;
});

/**
 * TimeMachineView
 *
 * @return TimeMachineView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/timemachineview',['lib/extend', 'core/view', 'ui/timemachinecommitview', 'ui/listview',
    'timemachine/timemachine', 'ui/timemachinenewtreecontroller'], function(
    extend, View, TimeMachineCommitView, ListView, TimeMachine,
    TimeMachineNewTreeController) {
  /**
   * Constructor
   */
  function TimeMachineView($view) {
    TimeMachineView.superconstructor.call(this, undefined, $view);

    this.init();
  }
  extend(TimeMachineView, View);

  TimeMachineView.prototype.init = function() {
    var $button, $container, $template;
    /*
     * Time Machine Commits
     */
    $container = this.$view.find('.rootcommits');
    $template = $container.find('.timemachinecommitview.template');
    this.initCommits = new ListView(TimeMachine.roots, $container, $template,
        TimeMachineCommitView);

    /*
     * Time Machine New Tree
     */
    $container = this.$view.find('.newcommittree');
    this.newcommitTreeController = new TimeMachineNewTreeController(new View(
        undefined, $container));
  };

  return TimeMachineView;
});

/**
 * FileLoadController
 *
 * @return FileLoadController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/statefileloadcontroller',['lib/extend', 'ui/fileloadcontroller', 'ui/statesaver',
    'ui/stateloader', 'ui/toast', 'ui/strings'], function(extend,
    FileLoadController, StateSaver, StateLoader, Toast, Strings) {
  /**
   * Constructor
   *
   * @param $button
   *          the file load button
   */
  function StateFileLoadController($button) {
    StateFileLoadController.superconstructor.call(this, $button);
  }
  extend(StateFileLoadController, FileLoadController);

  /**
   * load the file as json or teams-csv.
   *
   * @param fileContents
   */
  StateFileLoadController.prototype.readFile = function(fileContents) {
    Toast.closeTemporaryToasts();
    try {
      // TODO use filename until the tournament name is stored in the file,
      // too
      StateSaver.newTree(this.file.name.replace(/(\.(json|txt|csv))+$/, ''));
      if (StateLoader.loadString(fileContents)) {
        StateSaver.saveState();

        Toast.closeTemporaryToasts();
        new Toast(Strings.loaded, Toast.LONG);
      } else {
        new Toast(Strings.loadfailed, Toast.LONG);
        // TODO what if something invalid has been returned?
      }
    } catch (err) {
      new Toast(Strings.loadfailed, Toast.LONG);
      // perform a complete reset of the everything related to the
      // tournament
    }
  };

  /**
   * Unload the current save state to avoid confusion. If a tournament fails,
   * there should be no active tournament, instead of just keeping the currently
   * open one.
   */
  StateFileLoadController.prototype.unreadFile = function() {
    StateLoader.unload();
  };

  return StateFileLoadController;
});

/**
 * MessageModel
 *
 * @return MessageModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/messagemodel',['lib/extend', 'core/model', 'core/valuemodel'], function(extend, Model,
    ValueModel) {
  /**
   * Constructor
   */
  function MessageModel(server, apipath, data) {
    MessageModel.superconstructor.call(this);

    this.server = server;
    this.apipath = apipath;
    this.data = data;

    this.status = new ValueModel('unsent');
    this.result = new ValueModel(undefined);

    this.registerListener(this);
  }
  extend(MessageModel, Model);

  MessageModel.prototype.send = function() {
    if (this.server.tokenvalid.get() === false || !this.server.token.get()) {
      return false;
    }
    if (this.status.get() === 'sent') {
      return false;
    }
    this.result.set(undefined);

    this.server.registerMessage();

    $.ajax({
      method: 'POST',
      url: 'https://api.tuvero.de/' + this.apipath,
      data: 'auth=' + this.server.token.get(),
      timeout: 5000,
      success: (function(data) {
        this.result.set(data);
        if (!data || data.error) {
          this.status.set('error');
          this.emit('error', data);
        } else {
          this.status.set('done');
          this.emit('receive', data);
        }
      }).bind(this),
      error: (function(data) {
        this.result.set(data);
        this.status.set('error');
        this.emit('error', data);
      }).bind(this),
      complete: (function(data) {
        this.server.unregisterMessage();
        this.emit('complete', data);
      }).bind(this)
    });

    this.status.set('sent');
    this.emit('send', this.data);

    return true;
  };

  MessageModel.prototype.onsend = function(emitter, event, data) {
  };

  MessageModel.prototype.onreceive = function(emitter, event, data) {
  };

  MessageModel.prototype.onerror = function(emitter, event, data) {
  };

  MessageModel.prototype.oncomplete = function(emitter, event, data) {

  };

  MessageModel.prototype.EVENTS = {
    'error': true,
    'send': true,
    'receive': true,
    'complete': true
  };

  return MessageModel;
});

/**
 * ServerModel
 * 
 * @return ServerModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servermodel',['lib/extend', 'core/model', 'core/valuemodel', 'core/statevaluemodel',
    'ui/backgroundscripts/online', 'ui/messagemodel', 'ui/browser'], function(
    extend, Model, ValueModel, StateValueModel, Online, MessageModel, Browser) {
  /**
   * Constructor
   */
  function ServerModel(token) {
    ServerModel.superconstructor.call(this);

    this.token = new ValueModel(token || undefined);
    this.tokenvalid = new ValueModel(undefined);
    this.openTransactions = new ValueModel(0);

    this.token.registerListener(this);
    this.validateToken();
  }
  extend(ServerModel, Model);

  ServerModel.prototype.EVENTS = {
    'error' : true,
    'authenticate' : true,
    'login' : true,
    'logout' : true,
    'update' : true
  };

  ServerModel.prototype.validateToken = function() {
    var message;

    this.tokenvalid.set(undefined);

    if (!this.token.get()) {
      return;
    }

    message = this.message('/');

    message.onreceive = (function() {
      this.tokenvalid.set(true);
      this.emit('login');
    }).bind(this);

    message.onerror = (function() {
      this.tokenvalid.set(false);
      this.emit('error');
    }).bind(this);

    message.send();
  };

  ServerModel.prototype.setToken = function(token) {
    this.invalidateToken();
    this.token.set(token);
    this.validateToken();
  };

  ServerModel.prototype.createToken = function(token) {
    this.invalidateToken();

    this.registerMessage();

    $.ajax({
      method : 'POST',
      url : 'https://turniere.tuvero.de/profile/token/new/json',
      timeout : 5000,
      xhrFields : {
        withCredentials : true
      },
      success : (function(data) {
        if (!data) {
          this.emit('error');
        } else if (data.error) {
          this.emit('authenticate');
        } else {
          this.setToken(data.fulltoken);
        }
      }).bind(this),
      error : this.emit.bind(this, 'error'),
      complete : (function() {
        this.unregisterMessage();
      }).bind(this)
    });
  };

  ServerModel.prototype.invalidateToken = function() {
    var message;

    if (!this.token.get()) {
      this.tokenvalid.set(false);
      return;
    }

    message = this.message('/token/delete');
    if (message) {
      message.send(); // fire and forget
    }

    this.token.set(undefined);
    this.tokenvalid.set(undefined);

    this.emit('logout');
  };

  ServerModel.prototype.message = function(apipath, data) {
    if (this.tokenvalid.get() === false || !this.token.get()) {
      return undefined;
    }

    // tokenvalid can be true or undefined.
    // true: it's deemed valid
    // undefined: validation pending

    message = new MessageModel(this, apipath, data);

    return message;
  };

  ServerModel.prototype.registerMessage = function() {
    this.openTransactions.set(this.openTransactions.get() + 1);
  };

  ServerModel.prototype.unregisterMessage = function() {
    this.openTransactions.set(this.openTransactions.get() - 1);
  };

  ServerModel.prototype.communicationStatus = function() {
    var causes = {
      'https' : Browser.secure,
      'tuvero' : Browser.legit,
      'online' : Online(),
      'validtoken' : this.token.get() && this.tokenvalid.get()
    };

    causes.all = Object.keys(causes).every(function(value) {
      return causes[value] == true;
    });

    return causes;
  };

  /**
   * Relay 'update' event from this.token
   */
  ServerModel.prototype.onupdate = function() {
    this.emit('update');
  };

  ServerModel.prototype.save = function() {
    var data = ServerModel.superclass.save.call(this);

    data.token = this.token.get() || '';

    return data;
  };

  ServerModel.prototype.restore = function(data) {
    if (!ServerModel.superclass.restore.call(this, data)) {
      return false;
    }

    this.setToken(data.token || undefined);

    return true;
  };

  ServerModel.prototype.SAVEFORMAT = Object
      .create(ServerModel.superclass.SAVEFORMAT);
  ServerModel.prototype.SAVEFORMAT.token = String;

  return ServerModel;
});

/**
 * LoginController
 *
 * @return LoginController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/logincontroller',['lib/extend', 'core/controller'], //
function(extend, Controller) {
  /**
   * Constructor
   */
  function LoginController(view) {
    LoginController.superconstructor.call(this, view);

    this.view.$view.find('.login').click(
        this.model.createToken.bind(this.model));
    this.view.$view.find('.logout').click(
        this.model.invalidateToken.bind(this.model));
  }
  extend(LoginController, Controller);

  return LoginController;
});

/**
 * A ImageView, which updates the value of ValueModel to the DOM
 *
 * @return ImageView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/imageview',['lib/extend', 'ui/attributevalueview'], function(extend,
    AttributeValueView) {

  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance, which implements get() and emits update
   * @param $view
   *          the associated DOM element
   */
  function ImageView(model, $view) {
    ImageView.superconstructor.call(this, model, $view, 'src');
  }
  extend(ImageView, AttributeValueView);

  return ImageView;
});

/**
 * LoginView
 * 
 * @return LoginView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/loginview',['lib/extend', 'core/view', 'ui/valueview', 'ui/logincontroller',
    'jquery', 'core/valuemodel', 'core/classview', 'ui/imageview'], function(
    extend, View, ValueView, LoginController, $, ValueModel, ClassView,
    ImageView) {
  /**
   * Constructor
   */
  function LoginView(model, $view) {
    LoginView.superconstructor.call(this, model, $view);

    this.username = new ValueModel(undefined);
    this.avatar = new ValueModel(undefined);
    this.popupBlocked = new ValueModel(false);
    this.errorModel = new ValueModel(false);
    this.online = new ValueModel(this.model.communicationStatus().online);
    this.errorModel.registerListener(this.online);
    this.online.onupdate = function() {
      this.set(model.communicationStatus().online);
    };

    this.$userinfo = this.$view.find('.userinfo');
    this.$username = this.$view.find('.username');
    this.$avatar = this.$view.find('img.avatar');
    this.$loginbutton = this.$view.find('button.login');
    this.$logoutbutton = this.$view.find('button.logout');
    this.$busy = this.$view.find('.busy');
    this.$domainnotice = this.$view.find('.domainnotice');
    this.$online = this.$view.find('.online');
    this.$offline = this.$view.find('.offline');

    this.userinfovisibility = new ClassView(this.model.tokenvalid,
        this.$userinfo, undefined, 'hidden');
    this.avatarvisibility = new ClassView(this.avatar, this.$avatar, undefined,
        'hidden');
    this.usernamevisibility = new ClassView(this.username, this.$username,
        undefined, 'hidden');
    this.loginbuttonvisibility = new ClassView(this.model.tokenvalid,
        this.$loginbutton, 'hidden', undefined);
    this.logoutbuttonvisibility = new ClassView(this.model.tokenvalid,
        this.$logoutbutton, undefined, 'hidden');
    this.busyvisibility = new ClassView(this.model.openTransactions,
        this.$busy, undefined, 'hidden');

    this.onlineVisibility = new ClassView(this.online, //
    this.$online, undefined, 'hidden');
    this.offlineVisibility = new ClassView(this.online, //
    this.$offline, 'hidden');

    if (this.model.communicationStatus().tuvero) {
      this.$domainnotice.addClass('hidden');
    }

    this.usernameView = new ValueView(this.username, this.$username);

    this.avatarView = new ImageView(this.avatar, this.$avatar);

    this.loginWindow = undefined;
    this.loginPollingTimeout = undefined;
    this.loginWindowSuppressed = new ValueModel(false);

    this.popupBlockedView = new ClassView(this.popupBlocked, this.$view
        .find('.popupnotice'), undefined, 'hidden');

    this.errorView = new ClassView(this.errorModel, this.$view
        .find('.errornotice'), undefined, 'hidden');

    // TODO offlinenotice
    // TODO domainnotice

    $(window).on('beforeunload', (function($) {
      this.closeLoginWindow();
    }).bind(this));

    this.controller = new LoginController(this);
  }
  extend(LoginView, View);

  LoginView.prototype.openLoginWindow = function() {
    this.closeLoginWindow();

    if (this.loginWindowSuppressed.get()) {
      this.loginWindowSuppressed.set(false);

      // loginWindow is supposed to be closed, but has been open while a token
      // creation is happening.
      // This indicates that the login window has been closed without logging
      // in.
      if (this.loginWindow) {
        this.onerror();
        this.loginWindow = undefined; // should be closed anyway
      }

      return false;
    }

    this.loginWindow = window.open('https://turniere.tuvero.de/login');

    if (!this.isLoginWindowOpen()) {
      this.closeLoginWindow();
      this.popupBlocked.set(true);
    } else {
      this.popupBlocked.set(false);
      this.loginWindowSuppressed.set(true);
    }

    return this.isLoginWindowOpen();
  };

  LoginView.prototype.loginPolling = function() {
    var timeout;

    if (this.loginPollingTimeout) {
      return;
    }

    timeout = this.loginPollingTimeout = window.setTimeout((function() {
      if (this.loginPollingTimeout !== timeout) {
        return;
      }
      this.loginPollingTimeout = undefined;

      this.model.createToken();
    }).bind(this), 500);
  };

  LoginView.prototype.closeLoginWindow = function() {
    console.log('closeLoginWindow');
    if (!this.isLoginWindowOpen()) {
      return;
    }

    if (this.loginWindow) {
      this.loginWindow.close();
    }

    if (this.loginPollingTimeout !== undefined) {
      window.clearInterval(this.loginPollingTimeout);
      this.loginPollingInterval = undefined;
    }

    this.loginWindow = undefined;
    this.loginWindowSuppressed.set(false);
  };

  LoginView.prototype.isLoginWindowOpen = function() {
    return !!this.loginWindow && !!this.loginWindow.parent;
  };

  LoginView.prototype.updateProfile = function() {
    if (!this.model.communicationStatus().all) {
      this.username.set(undefined);
      this.avatar.set(undefined);
      return;
    }

    this.errorModel.set(false);

    var msg = this.model.message('/profile');
    msg.onreceive = (function(emitter, event, data) {
      this.username.set(data.displayname);
      this.avatar.set(data.avatar_url);
    }).bind(this);
    msg.onerror = (function() {
      this.errorModel.set(true);
      this.username.set(undefined);
      this.avatar.set(undefined);
    }).bind(this);
    msg.send();
  };

  LoginView.prototype.onlogin = function() {
    this.errorModel.set(false);
    this.suppressLoginWindow = false;
    this.updateProfile();
    this.popupBlocked.set(false);
    this.closeLoginWindow();
  };

  LoginView.prototype.onlogout = function() {
    this.errorModel.set(false);
    this.suppressLoginWindow = false;
    this.updateProfile();
  };

  LoginView.prototype.onerror = function() {
    this.errorModel.set(true);
    this.suppressLoginWindow = false;
    this.updateProfile();
  };

  LoginView.prototype.onauthenticate = function(emitter, event) {
    this.errorModel.set(false);
    if (!this.isLoginWindowOpen()) {
      if (!this.openLoginWindow()) {
        return;
      }
    }

    this.loginPolling();
  };

  return LoginView;
});

/**
 * ServerTournamentModel
 *
 * @return ServerTournamentModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servertournamentmodel',['lib/extend', 'core/model'], function(extend, Model) {
  /**
   * Constructor
   */
  function ServerTournamentModel(server, data) {
    ServerTournamentModel.superconstructor.call(this);

    this.id = data.id || undefined;
    this.name = data.name;
    this.place = data.place;
    this.creator = data.creator_name;
    this.teamsize = data.teamsize;
    this.variant = data.target;
    this.url_www = data.url_www;

    this.registrations = data.registrations || [];

    this.server = server;

    this.server.registerListener(this);
  }
  extend(ServerTournamentModel, Model);

  ServerTournamentModel.prototype.EVENTS = {
    'error' : true,
    'ready' : true
  }

  ServerTournamentModel.prototype.readRegistrations = function() {
    var message = this.server.message('t/' + this.id);

    message.onreceive = (function(emitter, event, data) {
      if (data.registrations) {
        this.registrations = data.registrations;
        this.emit('ready');
      } else {
        this.emit('error');
      }
    }).bind(this);
    message.onerror = (function() {
      this.emit('error');
    }).bind(this);

    message.send();
  };

  return ServerTournamentModel;
});

/**
 * ServerTournamentListModel
 *
 * @return ServerTournamentListModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servertournamentlistmodel',['lib/extend', 'core/listmodel', 'ui/servertournamentmodel', //
'presets'], function(extend, ListModel, ServerTournamentModel, Presets) {
  /**
   * Constructor
   */
  function ServerTournamentListModel(server) {
    ServerTournamentListModel.superconstructor.call(this);

    this.server = server;

    this.server.registerListener(this);
  }
  extend(ServerTournamentListModel, ListModel);

  ServerTournamentListModel.prototype.parseResult = function(data) {
    this.clear();

    Object.keys(data.tournaments).forEach(function(tournamentID) {
      var tournament, tournamentData;
      tournamentData = data.tournaments[tournamentID];
      if (tournamentData.target == Presets.target) {
        tournament = new ServerTournamentModel(this.server, tournamentData);
        this.push(tournament);
      }
    }, this);
  };

  ServerTournamentListModel.prototype.update = function() {
    var message = this.server.message('t');

    message.onreceive = (function(emitter, event, data) {
      this.parseResult(data);
    }).bind(this);
    message.onerror = this.clear.bind(this)

    message.send();
  };

  ServerTournamentListModel.prototype.onlogin = function() {
    this.update();
  };

  ServerTournamentListModel.prototype.onlogout = function() {
    this.clear();
  };

  ServerTournamentListModel.prototype.onerror = function() {
    this.clear();
  };

  return ServerTournamentListModel;
});

/**
 * ServerTournamentLoader
 *
 * @return ServerTournamentLoader
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servertournamentloader',['ui/statesaver', 'ui/state', 'ui/playermodel', 'ui/teammodel'], //
function(StateSaver, State, PlayerModel, TeamModel) {
  /**
   * Constructor
   */
  function ServerTournamentLoader() {
    ServerTournamentLoader.superconstructor.call(this);
  }

  ServerTournamentLoader.prototype.loadTournament = function(tournament) {
    // create new root RefLog with proper name
    StateSaver.createNewEmptyTree(tournament.name);
    // add all players
    State.teamsize.set(tournament.teamsize);

    // TODO switch to teamstab

    tournament.registrations.forEach(function(names) {
      var players;

      while (names.length > State.teamsize.get()) {
        names.pop();
      }
      while (names.length < State.teamsize.get()) {
        names.push('N.N.');
      }

      players = names.map(function(name) {
        var player = new PlayerModel(name);

        if (player.getName() === PlayerModel.NONAME) {
          return undefined;
        }

        return player;
      });

      if (players.indexOf(undefined) === -1) {
        State.teams.push(new TeamModel(players));
      }
    }, this);
  };

  ServerTournamentLoader.loadTournament = //
  ServerTournamentLoader.prototype.loadTournament;

  return ServerTournamentLoader;
});

/**
 * ServerTournamentController
 *
 * @return ServerTournamentController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servertournamentcontroller',['lib/extend', 'core/controller', 'core/listener',
    'ui/servertournamentloader'], function(extend, Controller, Listener,
    ServerTournamentLoader) {
  /**
   * Constructor
   */
  function ServerTournamentController(view) {
    ServerTournamentController.superconstructor.call(this, view);

    this.view.$view.find('button.play').click(
        this.model.readRegistrations.bind(this.model));
    Listener.bind(this.model, 'ready', function() {
      ServerTournamentLoader.loadTournament(this.model);
    }, this);
  }
  extend(ServerTournamentController, Controller);

  return ServerTournamentController;
});

/**
 * ServerTournamentView
 *
 * @return ServerTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/servertournamentview',['lib/extend', 'core/view', 'ui/servertournamentcontroller'], function(
    extend, View, ServerTournamentController) {
  /**
   * Constructor
   */
  function ServerTournamentView(model, $view) {
    ServerTournamentView.superconstructor.call(this, model, $view);

    this.$view.find('.name').text(model.name);
    this.$view.find('.place').text(model.place);
    this.$view.find('.creator').text(model.creator);
    this.$view.find('.teamsize').text(model.teamsize);
    this.$view.find('.url').text(model.url_www);
    this.$view.find('a.url_href').attr('href', model.url_www);

    this.controller = new ServerTournamentController(this);
  }
  extend(ServerTournamentView, View);

  return ServerTournamentView;
});

/**
 * ServerAutoloadModel
 *
 * @return ServerAutoloadModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/serverautoloadmodel',['lib/extend', 'core/model', 'ui/browser', 'ui/servertournamentmodel',
    'ui/servertournamentloader', 'presets'], function(extend, Model, Browser,
    ServerTournamentModel, ServerTournamentLoader, Presets) {
  /**
   * Constructor
   */
  function ServerAutoloadModel(server) {
    ServerAutoloadModel.superconstructor.call(this);

    this.server = server;
    this.tournamentID = this.readTournamentID();

    this.server.registerListener(this);

  }
  extend(ServerAutoloadModel, Model);

  ServerAutoloadModel.prototype.readTournamentID = function() {
    var testresult;
    if (Browser.inithash) {
      testresult = Browser.inithash.match(/^\/?t\/([0-9a-f]+)$/);
      if (testresult && testresult[0] && testresult[1]) {
        return testresult[1];
      }
    }

    return undefined;
  };

  /**
   * event function
   */
  ServerAutoloadModel.prototype.onlogin = function() {
    var message;
    if (this.tournamentID) {

      message = this.server.message('t/' + this.tournamentID);
      message.onreceive = (function(emitter, event, data) {
        if (data && data.registrations && data.target === Presets.target) {
          var model = new ServerTournamentModel(this.server, data);
          ServerTournamentLoader.loadTournament(model);
          if (window.location.hash.replace(/^#/, '') == Browser.inithash) {
            window.location.hash = '';
          }
        }
      }).bind(this);
      message.send();
    }
  };

  return ServerAutoloadModel;
});

/**
 * 
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/hometab',['lib/extend', 'jquery', 'core/view', 'ui/state', './strings',
    './toast', './browser', 'ui/timemachineview', 'ui/statesaver',
    'ui/statefileloadcontroller', 'core/valuemodel', 'core/classview',
    'ui/browser', 'ui/servermodel', 'ui/loginview', 'ui/storage', 'presets',
    'ui/servertournamentlistmodel', 'ui/servertournamentview', 'ui/listview',
    'ui/serverautoloadmodel'], function(extend, $, View, State, Strings, Toast,
    Browser, TimeMachineView, StateSaver, StateFileLoadController, ValueModel,
    ClassView, Browser, ServerModel, LoginView, Storage, Presets,
    ServerTournamentListModel, ServerTournamentView, ListView,
    ServerAutoloadModel) {
  /**
   * represents a whole team tab
   * 
   * TODO write a TabView superclass with common functions
   * 
   * TODO isolate common tab-related function
   * 
   * @param $tab
   *          the tab DOM element
   */
  function HomeTab($tab) {
    HomeTab.superconstructor.call(this, undefined, $tab);

    this.init();
  }
  extend(HomeTab, View);

  /**
   * initialize the tab functionality
   * 
   * TODO maybe split it into multiple autodetected functions?
   */
  HomeTab.prototype.init = function() {
    var $button, $errorlink, browserstring, $container, $input, $template;

    // TODO move to a controller
    $button = this.$view.find('button.reset');
    $button.click(function() {
      if (confirm(Strings.clearstorage)) {
        StateSaver.removeEverything();
      }
    });

    // TODO move to a view
    $errorlink = this.$view.find('a.errorlink');
    $errorlink.attr('href', $errorlink.attr('href') + '&browser='
        + Browser.name + ' ' + Browser.version);

    /*
     * Time Machine
     */
    $container = this.$view.find('.timemachineview');
    this.timeMachineView = new TimeMachineView($container);

    /*
     * tournament loader
     */
    $button = this.$view.find('button.load');
    this.fileLoadController = new StateFileLoadController($button);

    $container = this.$view.find('.chromerecommendation');
    this.chromeRecommendationClassView = new ClassView(new ValueModel(
        Browser.name == 'Chrome'), $container, 'hidden');

    /*
     * LoginView, ServerTournamentView
     */

    this.serverModel = Storage.register(Presets.names.apitoken, ServerModel);
    this.serverAutoloadModel = new ServerAutoloadModel(this.serverModel);

    this.serverTournamentListModel = new ServerTournamentListModel(
        this.serverModel);
    $container = this.$view.find('.servertournaments');
    $template = $container.find('.template')
    this.serverTournamentListView = new ListView(
        this.serverTournamentListModel, $container, $template,
        ServerTournamentView);

    $container = this.$view.find('.loginview');
    this.loginView = new LoginView(this.serverModel, $container);
    if (!this.serverModel.token.get()) {
      this.loginView.loginWindowSuppressed.set(true);
      this.serverModel.createToken();
    }
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="home"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new HomeTab($tab);
    }
  });

  return HomeTab;
});

/**
 * A LengthView, which writes the length of a ListModel to a DOM element
 *
 * @return LengthView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/lengthview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * Constructor
   *
   * @param model
   *          a ListModel instance
   * @param $view
   *          the associated DOM element
   */
  function LengthView(model, $view) {
    LengthView.superconstructor.call(this, model, $view);

    this.update();
  }
  extend(LengthView, View);

  /**
   * write the playernames and teamnumber to the DOM
   */
  LengthView.prototype.update = function() {
    this.$view.text(this.model.length);
  };

  /**
   * Callback listener
   */
  LengthView.prototype.onresize = function() {
    this.update();
  };

  return LengthView;
});

/**
 * on a list element click, runs the callback function. Can handle other events
 * as well
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/listclickcontroller',['jquery', 'lib/extend', 'core/controller', 'core/valuemodel'], function($, extend,
    Controller, ValueModel) {
  /**
   * Constructor
   *
   * The optional argument, options, can contain multiple options:
   *
   *
   * options.active: a ValueModel instance. When it's false, events are ignored
   *
   * options.callbackthis: use as the "this" for the callback function
   *
   * options.event: use this event instead of 'click', e.g. 'mousedown'
   *
   * options.selector: use this selector instead of '>' to select specific or
   * deeper nested DOM elements
   *
   *
   * @param view
   *          a ListView instance
   * @param callback
   *          the callback function: callback(model, index)
   * @param options
   *          Optional. An option object. See above
   */
  function ListClickController(view, callback, options) {
    var listview, listmodel;
    ListClickController.superconstructor.call(this, view);

    options = options || {};
    options.active = options.active || new ValueModel(true);
    options.callbackthis = options.callbackthis || window;
    options.event = options.event || 'click';
    if (this.view.$view.prop('tagName') === 'TABLE') {
      options.selector = options.selector || '> tbody >';
    } else {
      options.selector = options.selector || '>';
    }

    listview = this.view;
    listmodel = this.model;

    /**
     * handle the click action
     */
    this.view.$view.on(options.event, options.selector, function(e) {
      var $subview, index;

      if (options.active.get()) {
        $subview = $(this);
        index = listview.indexOf($subview);
        if (index !== -1) {
          callback.call(options.callbackthis, listmodel, index);
          e.preventDefault();
          return false;
        }
      }
    });
  }
  extend(ListClickController, Controller);

  return ListClickController;
});

/**
 * NewTournamentController
 *
 * @return NewTournamentController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/newtournamentcontroller',['jquery', 'lib/extend', 'core/controller', 'core/tournamentindex', './strings',
    './tournamentcontroller', 'presets'], function($, extend, Controller,
    TournamentIndex, Strings, TournamentController, Presets) {
  /**
   * Constructor
   */
  function NewTournamentController(view) {
    var controller, $tournamentsize;
    NewTournamentController.superconstructor.call(this, view);

    controller = this;

    this.$tournamentsize = this.view.$view.find('input.tournamentsize');
    this.$buttons = this.view.$view.find('button[data-system]');

    this.$tournamentsize.attr('max', this.model.numTeams);
    this.$tournamentsize.val(this.model.numTeams);
    controller.updateViewHeight();

    this.$tournamentsize.on('change keypress mousewheel', function() {
      controller.updateViewHeight();
      window.setTimeout(controller.updateViewHeight.bind(controller), 1);
    });

    this.$buttons.click(function(e) {
      var $button, type, size;

      $button = $(this);
      type = $button.attr('data-system');

      size = Number(controller.$tournamentsize.val());

      controller.createTournament(type, size);
    });
  }
  extend(NewTournamentController, Controller);

  /**
   * @param size
   *          a tournament size
   * @return true if the size is valid for a tournament, false otherwise
   */
  NewTournamentController.prototype.validateSize = function(size) {
    return size >= 2 && size <= this.model.numTeams;
  };

  NewTournamentController.prototype.updateViewHeight = function() {
    var size;

    size = Number(this.$tournamentsize.val());

    if (this.validateSize(size)) {
      this.view.$view.attr('rowspan', size);
    }
  };

  NewTournamentController.prototype.createTournament = function(type, size) {
    var tournament, ranking, i, imax, rankingorder;

    if (!this.validateSize(size)) {
      return;
    }

    rankingorder = ['wins'];
    if (Presets.systems[type] && Presets.systems[type].ranking) {
      rankingorder = Presets.systems[type].ranking.slice(0);
    }

    tournament = TournamentIndex.createTournament(type, rankingorder);

    tournament.getName().set(Strings['defaultname' + tournament.SYSTEM]);

    ranking = this.model.tournaments.getGlobalRanking(this.model.teams.length);

    imax = Math.min(this.model.firstTeamID + size, //
    ranking.displayOrder.length);

    for (i = this.model.firstTeamID; i < imax; i += 1) {
      tournament.addTeam(ranking.displayOrder[i]);
    }

    if (tournament) {
      this.model.tournaments.push(tournament, this.model.firstTeamID);
    }

    TournamentController.initiateNameChange(tournament);
  };

  return NewTournamentController;
});

/**
 * NewTournamentView
 *
 * @return NewTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/newtournamentview',['jquery', 'lib/extend', 'core/view', './newtournamentcontroller',
    'presets'], function($, extend, View, NewTournamentController, Presets) {
  /**
   * Constructor
   *
   * @param firstID
   * @param lastID
   * @param $view
   * @param tournaments
   * @param teams
   */
  function NewTournamentView(firstTeamID, numTeams, $view, tournaments, teams) {
    NewTournamentView.superconstructor.call(this, undefined, $view);

    this.$view.addClass('newsystem');

    if (numTeams < 2) {
      this.$view.addClass('notenoughteams');
    }

    // anonymous model
    this.model.firstTeamID = firstTeamID;
    this.model.numTeams = numTeams;
    this.model.tournaments = tournaments;
    this.model.teams = teams;

    this.$view.find('button').each(function() {
      var $button, system;

      $button = $(this);
      system = $button.attr('data-system');

      if (system && !Presets.systems[system]) {
        $button.hide();
      }
    });

    this.controller = new NewTournamentController(this);
  }
  extend(NewTournamentView, View);

  return NewTournamentView;
});

/**
 * SystemTableRowView
 *
 * @return SystemTableRowView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/systemtablerowview',['jquery', 'lib/extend', 'core/view', './teamview',
    './newtournamentview', './generictournamentview'], function($, extend,
    View, TeamView, NewTournamentView, GenericTournamentView) {
  /**
   * Constructor
   *
   * @param index
   *          the team index for this line
   * @param $view
   *          the DOM element of a single table row
   * @param teams
   *          a ListModel of TeamModels
   * @param tournaments
   *          a ListModel of TournamentModels
   * @param viewPopulator
   *          a TournamentViewPopulator instance for creation of the ".system"
   *          cells
   */
  function SystemTableRowView(index, $view, teams, tournaments, viewPopulator,
      $newTournamentTemplate) {
    SystemTableRowView.superconstructor.call(this, undefined, $view);

    this.teamID = index;
    this.teams = teams;
    this.tournaments = tournaments;
    this.teamView = new TeamView(teams.get(index), this.$view);

    this.tournamentRank = -1;
    this.globalRank = -1;

    this.updatepending = undefined;

    this.$tournamentrank = this.$view.find('.tournamentrank');
    this.$globalrank = this.$view.find('.rank');
    this.tournamentView = undefined;
    this.viewPopulator = viewPopulator;

    this.updateEverything();

    this.teams.registerListener(this);
    this.tournaments.registerListener(this);

  }
  extend(SystemTableRowView, View);

  SystemTableRowView.prototype.updateRankTexts = function() {
    var ranking, globalRank, tournamentRank;

    ranking = this.tournaments.getGlobalRanking(this.teams.length);
    globalRank = ranking.globalRanks[this.teamID];
    tournamentRank = ranking.tournamentRanks[this.teamID];

    if (this.globalRank !== globalRank) {
      this.$globalrank.text(globalRank + 1);
      this.globalRank = globalRank;
    }

    if (this.tournamentRank !== tournamentRank) {
      this.$tournamentrank.text(tournamentRank + 1);
      this.tournamentRank = tournamentRank;
    }
  };

  /**
   * adds/removes the .lastrow class on demand
   *
   * @param ranking
   *          a global ranking object
   */
  SystemTableRowView.prototype.updateLastRowClass = function() {
    var tournamentID, displayID, nextTeamID, nextTournamentID, ranking;

    ranking = this.tournaments.getGlobalRanking(this.teams.length);
    tournamentID = ranking.tournamentIDs[this.teamID];
    displayID = ranking.displayOrder.indexOf(this.teamID);
    if (displayID + 1 == this.teams.length) {
      this.$view.addClass('lastrow');
      return;
    }

    nextTeamID = ranking.displayOrder[displayID + 1];
    nextTournamentID = ranking.tournamentIDs[nextTeamID];

    if (tournamentID !== nextTournamentID) {
      this.$view.addClass('lastrow');
    } else {
      this.$view.removeClass('lastrow');
    }
  };

  /**
   * finds out if the current team is the first team in the tournament and
   * creates a new TournamentView, if necessary.
   */
  SystemTableRowView.prototype.updateSystem = function() {
    // too many variables.
    // TODO extract methods + reduce variables
    var ranking, displayID, tournamentID, isFirstInTournament, previousTeamID;
    var rankingLength, nextDisplayID, nextTeamID, tournamentSize, tournament;

    ranking = this.tournaments.getGlobalRanking(this.teams.length);
    displayID = ranking.displayOrder.indexOf(this.teamID);
    tournamentID = ranking.tournamentIDs[this.teamID];

    isFirstInTournament = false;
    if (displayID === 0) {
      isFirstInTournament = true;
    } else {
      previousTeamID = ranking.displayOrder[displayID - 1];

      if (ranking.tournamentIDs[previousTeamID] !== tournamentID) {
        isFirstInTournament = true;
      }
    }

    if (this.tournamentView) {
      this.tournamentView.destroy();
      this.tournamentView = undefined;
      this.$view.removeClass('firstrow');
    }

    if (!isFirstInTournament) {
      return;
    }

    rankingLength = ranking.displayOrder.length;
    nextDisplayID = displayID + 1;
    for (; nextDisplayID < rankingLength; nextDisplayID += 1) {
      nextTeamID = ranking.displayOrder[nextDisplayID];
      if (ranking.tournamentIDs[nextTeamID] !== tournamentID) {
        break;
      }
    }

    tournamentSize = nextDisplayID - displayID;

    $view = $('<td>').addClass('system');

    tournament = this.tournaments.get(tournamentID);
    this.viewPopulator.populate(tournament, $view);

    if (tournament) {
      this.tournamentView = new GenericTournamentView(tournament, $view,
          this.tournaments);
    } else {
      this.tournamentView = new NewTournamentView(displayID, tournamentSize,
          $view, this.tournaments, this.teams);
    }

    this.$view.append($view);
    this.$view.addClass('firstrow');
  };

  SystemTableRowView.prototype.updateEverything = function() {
    this.updateRankTexts();
    this.updateLastRowClass();
    this.updateSystem();
  };

  SystemTableRowView.prototype.onupdate = function(emitter, event, data) {
    var rowview = this;
    if (emitter === this.tournaments) {
      if (this.updatepending === undefined) {
        this.updatepending = true;
        window.setTimeout(function() {
          rowview.updateEverything();
          rowview.updatepending = undefined;
        }, 1);
      }
    }
  };

  SystemTableRowView.prototype.oninsert = function(emitter, event, data) {
    if (emitter === this.teams) {
      this.updateEverything();
    }
  };

  SystemTableRowView.prototype.onremove = function(emitter, event, data) {
    if (emitter === this.teams) {
      this.updateEverything();
    }
  };

  SystemTableRowView.prototype.destroy = function() {
    if (this.tournamentView) {
      this.tournamentView.destroy();
    }

    SystemTableRowView.superclass.destroy.call(this);
  };

  return SystemTableRowView;
});

/**
 * SystemListView
 *
 * @return SystemListView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/systemlistview',['lib/extend', './listview', './teamtableview', 'core/orderlistmodel',
    'core/listener', './systemtablerowview'], function(extend, ListView,
    TeamTableView, OrderListModel, Listener, SystemTableRowView) {
  /**
   * Constructor
   *
   * @param teams
   *          a ListModel of TeamModels
   * @param $view
   *          the associated DOM subtree
   * @param tournaments
   *          a ListModel of TournamentModels
   * @param teamsize
   *          a ValueModel which stores the team size
   * @param tournamentViewFactory
   *          a TournamentView factory
   *
   */
  function SystemListView(teams, $view, tournaments, teamsize,
      tournamentViewFactory) {
    var orderList, updateTimeout;

    orderList = new OrderListModel();
    SystemListView.superconstructor.call(this, orderList, $view, $view
        .find('.team.template'), SystemTableRowView, teams, tournaments,
        tournamentViewFactory);

    this.teams = teams;
    this.tournaments = tournaments;

    updateTimeout = undefined;

    Listener.bind(tournaments, 'update', function(model, event, data) {
      var list = this;
      if (updateTimeout === undefined) {
        window.setTimeout(function() {
          list.updateOrder();
          updateTimeout = undefined;
        }, 1);
      }
    }, this);

    Listener.bind(teams, 'insert,remove', function(model, event, data) {
      var list = this;
      if (event === 'remove') {
        list.removeAfter(data.id);
      }

      if (updateTimeout === undefined) {
        window.setTimeout(function() {
          list.updateOrder();
          updateTimeout = undefined;
        }, 1);
      }
    }, this);

    this.updateOrder();

    view = new TeamTableView(this, teamsize);
  }
  extend(SystemListView, ListView);

  /**
   * Update the row order to match the global ranking displayOrder
   */
  SystemListView.prototype.updateOrder = function() {
    var ranking, order;

    ranking = this.tournaments.getGlobalRanking(this.teams.length);
    order = ranking.displayOrder;

    this.model.enforceOrder(order);
  };

  /**
   * remove all teams with an ID after and including firstID, regardless of the
   * display order
   *
   * @param firstID
   *          the first ID to remove
   */
  SystemListView.prototype.removeAfter = function(firstID) {
    var order = this.model.map(function(teamID) {
      return teamID;
    }).filter(function(id) {
      return id < firstID;
    });

    this.model.enforceOrder(order);
  };

  return SystemListView;
});

/**
 * GenericTournamentView
 *
 * @return GenericTournamentView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentviewpopulator',['jquery', 'lib/extend', 'core/view', './generictournamentview'], //
function($, extend, View, GenericTournamentView) {
  /**
   * Constructor
   *
   * @param $templatesArray
   *          a list of DOM elements which are templates
   */
  function TournamentViewPopulator($templatesArray) {
    var $templates = {};

    $templatesArray.each(function() {
      var $template, type;
      $template = $(this);
      type = $template.attr('data-system');

      $templates[type] = $template;
    });

    this.$templates = $templates;
  }
  extend(GenericTournamentView, View);

  /**
   * populate a GenericTournamentView container with content, depending on the
   * tournament type. If the tournament is undefined, the "undefined" system
   * will be populated, i.e. the NewTournamentView container for starting new
   * tournaments.
   *
   * @param tournament
   *          a TournamentModel instance
   * @param $view
   *          an empty container for the actual view
   */
  TournamentViewPopulator.prototype.populate = function(tournament, $view) {
    var type;

    type = tournament && tournament.SYSTEM;

    if (this.$templates[type] === undefined) {
      console.error('system template has not been loaded: ' + type);
    } else {
      $view.append(this.$templates[type].children().clone());
    }
  };

  return TournamentViewPopulator;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/newtab',['lib/extend', 'jquery', 'core/view', 'ui/state', './systemlistview',
    './tournamentviewpopulator', './checkboxview', 'core/classview',
    'ui/tabshandle'], function(extend, $, View, State, SystemListView,
    TournamentViewPopulator, CheckBoxView, ClassView, TabsHandle) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function NewTab($tab) {
    NewTab.superconstructor.call(this, undefined, $tab);

    this.init();

    this.update();

    State.teams.registerListener(this);
  }
  extend(NewTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  NewTab.prototype.init = function() {
    var $view, factory, $templates, value;

    $templates = this.$view.find('.template[data-system]').detach();
    factory = new TournamentViewPopulator($templates);
    $view = this.$view.find('.systemtable');
    view = new SystemListView(State.teams, $view, State.tournaments,
        State.teamsize, factory);

    // name maxwidth checkbox
    value = State.tabOptions.nameMaxWidth;
    $view = this.$view.find('>.options input.maxwidth');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $view);
    this.maxwidthClassView = new ClassView(value, this.$view, 'maxwidth',
        'nomaxwidth');

    // player names checkbox
    value = State.tabOptions.showNames;
    $view = this.$view.find('>.options input.shownames');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $view);
    this.maxwidthClassView = new ClassView(value, this.$view, undefined,
        'hidenames');

    this.$view.find('.boxview.template').detach();
  };

  /**
   * show/hide the tab and update it as necessary
   */
  NewTab.prototype.update = function() {
    if (State.teams.length < 2) {
      TabsHandle.hide('new');
    } else {
      TabsHandle.show('new');
    }
  };

  /**
   * the number of teams has changed
   */
  NewTab.prototype.onresize = function() {
    this.update();
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="new"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new NewTab($tab);
    }
  });

  return NewTab;
});

/**
 * Controller for adding a new player and handling invalid player names on input
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/newteamcontroller',['jquery', 'lib/extend', 'core/controller', './playermodel',
    './teammodel'], function($, extend, Controller, PlayerModel, TeamModel) {
  /**
   * Constructor
   *
   * @param view
   *          the associated NewTeamView
   */
  function NewTeamController(view) {
    var controller;
    NewTeamController.superconstructor.call(this, view);

    controller = this;

    this.$players = this.view.$players;

    /*
     * add a new team at form submission
     */
    this.view.$view.submit(function(e) {
      controller.createNewTeam();
      e.preventDefault();
      return false;
    });
  }
  extend(NewTeamController, Controller);

  /**
   * reads the playernames from the newteam form
   *
   * @return an array of player names
   */
  NewTeamController.prototype.readPlayerNames = function() {
    var names;

    names = this.$players.map(function(id, player) {
      var $player;
      $player = $(player);

      if ($player.prop('disabled')) {
        return undefined;
      }
      return $player.val();
    }).get();

    while (names.length > 0 && names[names.length - 1] === undefined) {
      names.pop();
    }

    return names;
  };

  /**
   * Add a new team after reading the names from the registered input fields and
   * push it to this.model, which is supposed to be a ListModel.
   *
   * If a player name is invalid (whitespace-only or empty), team creation is
   * aborted and the first invalid input field is focused
   */
  NewTeamController.prototype.createNewTeam = function() {
    var names, players;

    names = this.readPlayerNames();

    if (names.length === 0) {
      console.error('NewTeamController: all input fields disabled?');
      return;
    }

    players = names.map(function(name) {
      var player;

      player = new PlayerModel(name);

      if (player.getName() === PlayerModel.NONAME) {
        return undefined;
      }

      return player;
    });

    if (players.indexOf(undefined) === -1) {
      this.model.push(new TeamModel(players));
      this.view.resetNames();
    }

    this.view.focusEmpty();
  };

  return NewTeamController;
});

/**
 * Represents a form with input elements and submit method, with which a new
 * team is to be added to the associated ListModel
 *
 * @return NewTeamView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/newteamview',['jquery', 'lib/extend', 'core/view', './newteamcontroller'], function(
    $, extend, View, NewTeamController) {
  /**
   * Constructor
   *
   * @param model
   *          a ListModel for containing the teams
   * @param $view
   *          a form which contains two input elements and a submit button
   * @param teamsize
   *          Optional. A ValueModel instance which represents the team size.
   */
  function NewTeamView(model, $view, teamsize) {
    NewTeamView.superconstructor.call(this, model, $view);

    this.$players = this.$view.find('input.playername');
    this.$lines = this.$view.find('>.names>');

    if (teamsize) {
      this.teamsize = teamsize;
      this.teamsize.registerListener(this);
      this.updateTeamSize();
    }

    this.controller = new NewTeamController(this);
  }
  extend(NewTeamView, View);

  /**
   * clear the name input fields
   */
  NewTeamView.prototype.resetNames = function() {
    this.$players.val('');
    if (this.$players.typeahead) {
      this.$players.typeahead('val', '');
    }
  };

  /**
   * focus the first empty or whitespace-only name input field
   */
  NewTeamView.prototype.focusEmpty = function() {
    this.$players.each(function() {
      var $this;

      $this = $(this);

      if (!$this.attr('disabled') && /^\s*$/.test($this.val())) {
        $(this).focus();
        return false;
      }
    });
  };

  /**
   * update the entry team size by enabling/disabling the input fields
   */
  NewTeamView.prototype.updateTeamSize = function() {
    var teamsize;

    if (!this.teamsize) {
      console.error('NewTeamView.updateTeamSize called '
          + 'without a valid teamsize model');
      return;
    }

    teamsize = this.teamsize.get();

    this.$players.each(function(index) {
      if (index < teamsize) {
        $(this).prop('disabled', false);
      } else {
        $(this).prop('disabled', true);
      }
    });

    this.$lines.each(function(index) {
      if (index < teamsize) {
        $(this).show();
      } else {
        $(this).hide();
      }
    });
  };

  /**
   * Callback function, after resetting the teams
   *
   * Note to self: the 'reset' event is fired by the model, which is a ListView
   * containing the teams. Do not fire 'reset' on this model manually!
   */
  NewTeamView.prototype.onreset = function() {
    this.resetNames();
  };

  /**
   * Callback function
   *
   * @param emitter
   */
  NewTeamView.prototype.onupdate = function(emitter) {
    if (emitter === this.teamsize) {
      this.updateTeamSize();
    }
  };

  return NewTeamView;
});

/**
 * NoRegModel
 *
 * @return NoRegModel
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/noregmodel',['lib/extend', 'core/valuemodel', 'core/tournamentmodel'], function(
    extend, ValueModel, TournamentModel) {
  /**
   * Constructor
   */
  function NoRegModel(tournaments) {
    this.tournaments = tournaments;
    NoRegModel.superconstructor.call(this, this.isClosed());

    this.tournaments.registerListener(this);
    this.tournaments.closedTournaments.registerListener(this);
  }
  extend(NoRegModel, ValueModel);

  NoRegModel.prototype.isClosed = function() {
    var tournamentID;

    for (tournamentID = 0; tournamentID < this.tournaments.length; //
    tournamentID += 1) {
      if (this.tournaments.get(tournamentID).state.get() !== 'initial'
          || !this.tournaments.closedTournaments.includes(tournamentID)) {
        return true;
      }
    }

    return false;
  };

  NoRegModel.prototype.onupdate = function() {
    NoRegModel.superclass.set.call(this, this.isClosed());
  };

  NoRegModel.prototype.set = undefined;

  return NoRegModel;
});

/**
 * hide preregistration elements as soon as the first team has been registered
 *
 * @return PreregCloserView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/preregcloserview',['lib/extend', 'core/view'], function(extend, View) {

  /**
   * Constructor
   *
   * @param model
   *          a ListModel of the teams
   * @param $view
   *          a container for all affected DOM elements
   */
  function PreregCloserView(model, $view) {
    PreregCloserView.superconstructor.call(this, model, $view);

    this.updateStatus();
  }
  extend(PreregCloserView, View);

  /**
   * update the preregistration status
   */
  PreregCloserView.prototype.updateStatus = function() {
    if (this.model.length === 0) {
      this.$view.removeClass('noprereg');
    } else {
      this.$view.addClass('noprereg');
    }
  };

  /**
   * Callback function
   */
  PreregCloserView.prototype.onresize = function() {
    this.updateStatus();
  };

  return PreregCloserView;
});

/**
 * RankingView
 *
 * @return RankingView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/rankingview',['lib/extend', 'ui/templateview', './strings', 'ui/teamview'], function(
    extend, TemplateView, Strings, TeamView) {
  /**
   * Constructor
   *
   * @param model
   *          a RankingModel instance
   * @param $view
   *          a jQuery object representing a RankingView table
   * @param teamList
   *          a ListModel of TeamModel instances, to which the team ids are
   *          corresponding
   * @param abbreviate
   *          a ValueModel instance which indicates whether this
   */
  function RankingView(model, $view, teamList, abbreviate) {
    RankingView.superconstructor.call(this, model, $view, $view
        .find('.rankingrow.template'));

    this.$rankingheader = this.$view.find('.rankingheader');
    this.$headercomponenttemplate = this.$rankingheader.find('.component');
    this.$headercomponenttemplate.detach();
    this.$headernametemplate = this.$rankingheader.find('.name');
    this.$headernametemplate.detach();
    this.$componenttemplate = this.$template.find('.component').detach();

    this.teamList = teamList;
    this.teamViews = [];
    this.abbreviate = abbreviate;

    this.updateTimeout = undefined;

    // TODO use some standardized defer-statement
    this.onupdate(this.model, 'update');

    this.abbreviate.registerListener(this);
  }
  extend(RankingView, TemplateView);

  RankingView.prototype.reset = function() {
    this.$view.find('.rankingrow').remove();
    this.teamViews.forEach(function(teamView) {
      teamView.destroy();
    });
    this.teamViews = [];
  };

  RankingView.prototype.update = function() {
    var ranks, teamsize, i;

    ranks = this.model.get();
    if (!ranks) {
      return false;
    }

    this.reset();

    teamsize = 0;
    ranks.displayOrder.forEach(function(teamIndex) {
      var size = this.teamList.get(teamIndex)
          && this.teamList.get(teamIndex).length || 0;
      if (teamsize < size) {
        teamsize = size;
      }
    }, this);

    this.$view.find('.rankingheader .name').remove();
    for (i = 0; i < teamsize; i += 1) {
      this.$rankingheader.append(this.$headernametemplate.clone());
    }

    this.$view.find('.rankingheader .component').remove();
    ranks.components.forEach(function(componentName) {
      var name;
      if (this.useAbbreviations()) {
        name = Strings['ranking_short_' + componentName];
      } else {
        name = Strings['ranking_medium_' + componentName];
      }
      this.$rankingheader.append(this.$headercomponenttemplate.clone().text(
          name));
    }, this);

    ranks.displayOrder.forEach(function(teamIndex, rank) {
      var i, $row, team, player;

      team = this.teamList.get(ranks.ids[teamIndex]);

      $row = this.$template.clone();
      $row.find('.rank').text(ranks.ranks[teamIndex] + 1);
      this.teamViews.push(new TeamView(team, $row));

      ranks.components.forEach(function(componentName) {
        $row.append(this.$componenttemplate.clone().text(
            ranks[componentName][teamIndex]));
      }, this);

      this.$view.append($row);
    }, this);
  };

  RankingView.prototype.onupdate = function(emitter, event, data) {
    var rankingview = this;
    if (this.updateTimeout === undefined) {
      this.updateTimeout = window.setTimeout(function() {
        rankingview.update();
        rankingview.updateTimeout = undefined;
      }, 1);
    }
  };

  RankingView.prototype.useAbbreviations = function() {
    return this.abbreviate.get();
  };

  RankingView.prototype.destroy = function() {
    this.reset();

    RankingView.superclass.destroy.call(this);
  };

  return RankingView;
});

/**
 * TournamentRankingView
 *
 * @return TournamentRankingView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/tournamentrankingview',['lib/extend', 'core/view', './rankingview', './listview',
    './popoutboxview', './correctionview', './teamtableview',
    'core/valuemodel', 'core/listener', 'ui/tournamentrenamecontroller'], //
function(extend, View, RankingView, ListView, PopoutBoxView, CorrectionView,
    TeamTableView, ValueModel, Listener, TournamentRenameController) {
  /**
   * Constructor
   *
   * @param model
   *          a TournamentModel instance
   * @param $view
   *          the container of the object
   * @param teams
   *          a ListModel of TeamModel instances which is referenced by index by
   *          TournamentModel.getRanking()
   */
  function TournamentRankingView(model, $view, teams, abbreviate) {
    var $popout = $view.clone();
    TournamentRankingView.superconstructor.call(this, model, $view);

    this.renameController = new TournamentRenameController(new View(model,
        this.$view.find('.tournamentname.rename')));
    this.boxview = new PopoutBoxView(this.$view, $popout, function($view) {
      return new TournamentRankingView(model, $view, teams, abbreviate);
    });

    this.$ranking = this.$view.find('.rankingview');
    this.rankingview = new RankingView(this.model.getRanking(), this.$ranking,
        teams, abbreviate);

    this.$corrections = this.$view.find('.correctiontable');
    this.$correctionrow = this.$corrections.find('.correctionrow.template')
        .detach();
    this.corrections = new ListView(this.model.getCorrections(),
        this.$corrections, this.$correctionrow, CorrectionView);
    this.correctionTeamHideListener = new TeamTableView(this.corrections,
        new ValueModel(3));

    this.$names = this.$view.find('.tournamentname');

    Listener.bind(this.model.getName(), 'update', this.updateNames.bind(this));
    Listener.bind(this.model.getState(), 'update', this.updateVisibility
        .bind(this));

    this.updateNames();
    this.updateVisibility();
  }
  extend(TournamentRankingView, View);

  TournamentRankingView.prototype.updateNames = function() {
    this.$names.text(this.model.getName().get());
  };

  TournamentRankingView.prototype.updateVisibility = function() {
    if (this.model.getState().get() === 'initial') {
      this.$view.addClass('hidden');
    } else {
      this.$view.removeClass('hidden');
    }
  };

  return TournamentRankingView;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/rankingtab',['lib/extend', 'jquery', 'core/view', './listview', 'ui/state',
    './checkboxview', 'core/classview', './tournamentrankingview',
    'ui/tabshandle', './closedtournamentcollapselistener'], function(extend, $,
    View, ListView, State, CheckBoxView, ClassView, TournamentRankingView,
    TabsHandle, ClosedTournamentCollapseListener) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function RankingTab($tab) {
    RankingTab.superconstructor.call(this, undefined, $tab);

    this.init();

    this.update();

    State.tournaments.registerListener(this);
  }
  extend(RankingTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  RankingTab.prototype.init = function() {
    var $template, $container, value;

    // name maxwidth checkbox
    value = State.tabOptions.nameMaxWidth;
    $container = this.$view.find('>.options input.maxwidth');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, 'maxwidth',
        'nomaxwidth');

    // player names checkbox
    value = State.tabOptions.showNames;
    $container = this.$view.find('>.options input.shownames');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, undefined,
        'hidenames');

    // list/table selection checkbox
    this.rankingabbreviations = State.tabOptions.rankingAbbreviations;
    $container = this.$view.find('>.options input.abbreviate');
    this.abbreviateCheckBoxView = new CheckBoxView(this.rankingabbreviations,
        $container);

    // rankinglist
    $container = this.$view.find('.tournamentlist');
    $template = $container.find('.tournament.template');
    this.tournamentList = new ListView(State.tournaments, $container,
        $template, TournamentRankingView, State.teams,
        this.rankingabbreviations);

    // HACK: close tournaments
    this.collapseListener = new ClosedTournamentCollapseListener(
        this.tournamentList);
  };

  /**
   * show/hide the tab and update it as necessary
   */
  RankingTab.prototype.update = function() {
    var i, isRunning;

    isRunning = false;

    for (i = 0; !isRunning && i < State.tournaments.length; i += 1) {
      isRunning = State.tournaments.get(i).getState().get() !== 'initial';
    }

    if (isRunning) {
      TabsHandle.show('ranking');
    } else {
      TabsHandle.hide('ranking');
    }
  };

  /**
   * a tournament state has been changed
   *
   * @param emitter
   * @param event
   * @param data
   */
  RankingTab.prototype.onupdate = function(emitter, event, data) {
    if (emitter !== State.tournaments) {
      this.update();
    }
  };

  /**
   * a tournament has been added
   *
   * @param emitter
   * @param event
   * @param data
   */
  RankingTab.prototype.oninsert = function(emitter, event, data) {
    data.object.getState().registerListener(this);
    this.update();
  };

  /**
   * a tournament has been removed
   *
   * @param emitter
   * @param event
   * @param data
   */
  RankingTab.prototype.onremove = function(emitter, event, data) {
    data.object.getState().unregisterListener(this);
    this.update();
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="ranking"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new RankingTab($tab);
    }
  });

  return RankingTab;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/settingstab',['lib/extend', 'jquery', 'core/view', './csvexportcontroller',
    'ui/fontsizeview'], function(extend, $, View,
    CSVExportController, FontSizeView) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function SettingsTab($tab) {
    SettingsTab.superconstructor.call(this, undefined, $tab);

    this.init();
  }
  extend(SettingsTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  SettingsTab.prototype.init = function() {
    var $container;

    this.$fontsizeview = this.$view.find('.fontsizeview').eq(0);
    this.fontsizeview = new FontSizeView(this.$fontsizeview, $('body'));

    /*
     * CSV buttons
     */
    $container = this.$view.find('.csv');
    this.csvExportController = new CSVExportController(new View(undefined,
        $container));
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="settings"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new SettingsTab($tab);
    }
  });

  return SettingsTab;
});

/**
 * Manage the state and visibility of the splash screen
 *
 * @return Splash
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/splash',['jquery', 'ui/browser'], function($, Browser) {
  var Splash;

  Splash = {
    hide: function() {
      console.error('Splash.hide() called before pageload');
    },
    loading: function() {
      console.error('Splash.loading() called before pageload');
    }
  };

  $(function($) {
    var $splash;

    function setState(state) {
      $splash.removeClass();
      $splash.addClass(state);
    }

    $splash = $('#splash');

    // TODO move to another function
    if (Browser.name == 'MSIE' && Browser.version < 9) {
      setState('oldinternetexplorer');
      return;
    }

    setState('starting');

    Splash.valid = true;

    Splash.loading = function() {
      setState('restoring');
    };

    Splash.update = function() {
      setState('update');
      $('#tabs').show();
    };

    Splash.hide = function() {
      setState('ready');

      $('body').removeClass('splash');

      setTimeout(function() {
        $splash.addClass('hidden');
      }, 1000);
    };

    Splash.error = function() {
      setState('error');
    };
  });

  return Splash;
});

/**
 * TeamFormatDownloadController
 *
 * @return TeamFormatDownloadController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamformatdownloadcontroller',['lib/extend', 'core/controller', 'lib/FileSaver', 'lib/Blob',
    './toast', './strings', 'presets', 'ui/state'], function(extend,
    Controller, saveAs, Blob, Toast, Strings, Presets, State) {
  var examplefiles;

  examplefiles = [];
  examplefiles[1] = 'Teilnehmer 1\n' + 'Teilnehmer 2\n' + 'Teilnehmer 3\n'
      + 'Teilnehmer 4\n' + '\n# Hinweis: Tete-a-tete -> ein Name pro Zeile\n';

  examplefiles[2] = 'Erik E. Lorenz, Fabian "Fabe" Böttcher\n'
      + 'Spieler 3, Spieler 4\n' + 'Spieler 5, Spieler 6\n'
      + 'Spieler 7, Spieler 8\n'
      + '\n# Hinweis: Doublette -> Zwei Namen pro Zeile, mit Komma getrennt\n';

  examplefiles[3] = 'Erik E. Lorenz, Fabian "Fabe" Böttcher, Spieler 3\n'
      + 'Spieler 4, Spieler 5, Spieler 6\n'
      + 'Spieler 7, Spieler 8, Spieler 9\n'
      + '\n# Hinweis: Triplette -> Drei Namen pro Zeile, mit Komma getrennt\n';

  /**
   * Constructor
   *
   * @param view
   *          a View instance, which contains the button
   */
  function TeamFormatDownloadController(view) {
    TeamFormatDownloadController.superconstructor.call(this, view);

    this.view.$view.click(this.save.bind(this));
  }
  extend(TeamFormatDownloadController, Controller);

  TeamFormatDownloadController.prototype.save = function() {
    var blob;

    try {
      blob = new Blob([examplefiles[State.teamsize.get()] || examplefiles[2]]);
      saveAs(blob, Presets.names.teamsfile);
    } catch (e) {
      console.error(e.stack);
      new Toast(Strings.savefailed);
    }
  };

  return TeamFormatDownloadController;
});

/**
 * handle team removals
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamremovecontroller',['jquery', 'lib/extend', 'core/controller', 'core/valuemodel',
    './listclickcontroller', 'core/classview', 'core/view', './toast',
    './strings', 'core/listener'], function($, extend, Controller, ValueModel,
    ListClickController, ClassView, View, Toast, Strings, Listener) {

  /**
   * Constructor
   */
  function TeamRemoveController(views, $activatebutton, $tab) {
    var active;
    TeamRemoveController.superconstructor.call(this, new View(undefined,
        $activatebutton));

    this.views = views;
    active = new ValueModel(false);

    this.toast = undefined;
    this.initToast(active);

    this.clickControllers = this.views.map(function(view) {
      var options;

      options = {
        active: active,
        event: 'mousedown',
        callbackthis: active
      };

      return new ListClickController(view,
          TeamRemoveController.removalCallback, options);
    });

    this.classview = new ClassView(active, $tab, 'deletion');

    $activatebutton.click(function(e) {
      // activate/deactivate when clicking the button
      active.set(!active.get());
      e.preventDefault();
      return false;
    }).blur(function() {
      active.set(false);
    });

    $(document).keydown(function(e) {
      if (active.get() && e.which === 27) {
        active.set(false);
        e.preventDefault();
        return false;
      }
    });
  }

  extend(TeamRemoveController, Controller);

  TeamRemoveController.prototype.initToast = function(active) {
    Listener.bind(active, 'update', function() {
      if (active.get()) {
        if (this.toast === undefined) {
          this.toast = new Toast(Strings.teamdeleteprompt, Toast.INFINITE);
        } else {
          this.toast.display();
        }
      } else {
        if (this.toast) {
          this.toast.close();
        }
      }
    }, this);
  };

  /**
   * remove a team from the list of teams
   *
   * @param model
   *          a ListModel instance
   * @param index
   *          the index to remove from model
   */
  TeamRemoveController.removalCallback = function(model, index) {
    var team, playerid;

    // HACK start
    // Change the player names to an error message. Change ID, too.
    team = model.get(index);
    if (team) {
      for (playerid = 0; playerid < team.length; playerid += 1) {
        team.getPlayer(playerid).name = Strings.display_error;
      }
    }
    team.setID('ERROR');
    // HACK end

    model.remove(index);

    this.set(false);
  };

  return TeamRemoveController;
});

/**
 * @return TeamSizeController
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamsizecontroller',['jquery', 'lib/extend', 'core/controller'], function($, extend, Controller) {
  /**
   * Constructor
   *
   * @param view
   *          the TeamSizeView
   */
  function TeamSizeController(view) {
    var $buttons, model;
    TeamSizeController.superconstructor.call(this, view);

    $buttons = this.view.$buttons;
    model = this.model;

    /**
     * adjust the team size: get the index of the clicked button and calculate
     * the team size from it. Increment and set.
     */
    $buttons.click(function() {
      var teamsize;

      teamsize = $buttons.index($(this)) + 1;

      if (teamsize > 0) {
        model.set(teamsize);
      }
    });
  }
  extend(TeamSizeController, Controller);

  return TeamSizeController;
});

/**
 * A container with number of buttons with which the team size can be set. The
 * order of the buttons indicates the team size, starting at 1. The button
 * representinc the current team size will be selected
 *
 * @return TeamSizeView
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/teamsizeview',['lib/extend', 'core/view', './teamsizecontroller'], function(extend, View,
    TeamSizeController) {

  /**
   * Constructor
   *
   * @param model
   *          a ValueModel instance which represents the team size
   */
  function TeamSizeView(model, $view) {
    TeamSizeView.superconstructor.call(this, model, $view);

    this.$buttons = this.$view.find('>button');

    this.update();

    this.controller = new TeamSizeController(this);
  }
  extend(TeamSizeView, View);

  /**
   * unselect all buttons and select the current one.
   *
   * When driven by update events, ValueModel.set() should avoid sending events
   * when the new and old values match, i.e. there's no actual change
   */
  TeamSizeView.prototype.update = function() {
    var teamsize;

    teamsize = this.model.get();

    this.$buttons.removeClass('selected');
    this.$buttons.eq(teamsize - 1).addClass('selected');
  };

  /**
   * Callback function
   */
  TeamSizeView.prototype.onupdate = function() {
    this.update();
  };

  return TeamSizeView;
});

/**
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/teamstab',['jquery', 'lib/extend', 'core/view', './listview', './teamview',
    'ui/state', './newteamview', './lengthview', './teamsizeview',
    './preregcloserview', './checkboxview', 'core/classview', './tabshandle',
    './teamremovecontroller', './teamtableview', './inputview',
    './teamsfileloadcontroller', 'presets', 'ui/noregmodel',
    './deleteallteamscontroller', './autocompletionmodel',
    './autocompletionview', './teamformatdownloadcontroller',
    'timemachine/timemachine', 'ui/storage'], function($, extend, View,
    ListView, TeamView, State, NewTeamView, LengthView, TeamSizeView,
    PreregCloserView, CheckBoxView, ClassView, TabsHandle,
    TeamRemoveController, TeamTableView, InputView, TeamsFileLoadController,
    Presets, NoRegModel, DeleteAllTeamsController, AutocompletionModel,
    AutocompletionView, TeamFormatDownloadController, TimeMachine, Storage) {
  /**
   * represents a whole team tab
   *
   * TODO write a TabView superclass with common functions
   *
   * TODO isolate common tab-related function
   *
   * @param $tab
   *          the tab DOM element
   */
  function TeamsTab($tab) {
    TeamsTab.superconstructor.call(this, undefined, $tab);

    this.init();

    this.update();

    TimeMachine.commit.registerListener(this);
  }
  extend(TeamsTab, View);

  /**
   * initialize the tab functionality
   *
   * TODO maybe split it into multiple autodetected functions?
   */
  TeamsTab.prototype.init = function() {
    var $template, $container, $button, value;

    // teamsize bugfix
    if (State.teamsize.get() < Presets.registration.minteamsize) {
      State.teamsize.set(Presets.registration.minteamsize);
    }
    if (State.teamsize.get() > Presets.registration.maxteamsize) {
      State.teamsize.set(Presets.registration.maxteamsize);
    }

    // teamlist
    $container = this.$view.find('>.teamlist');
    $template = $container.find('.team.template');
    this.teamList = new ListView(State.teams, $container, $template, TeamView);

    // teamtable
    $container = this.$view.find('>.teamtable');
    $template = $container.find('.team.template');
    this.teamTable = new ListView(State.teams, $container, $template, //
    TeamView);

    // registration
    $container = this.$view.find('>.newteamview');
    this.newTeamView = new NewTeamView(State.teams, $container, //
    State.teamsize);

    // number of teams
    $container = this.$view.find('> h2 > .numteams');
    this.lengthView = new LengthView(State.teams, $container);

    // change team size
    $container = this.$view.find('> .teamsizeview');
    if ($container.length !== 0) {
      this.teamSizeView = new TeamSizeView(State.teamsize, $container);
    }

    // hide team size buttons when a team has been registered
    this.teamSizeCloserView = new PreregCloserView(State.teams, this.$view);

    // hide registration and removal buttons after the first tournament
    this.regVisibilityView = new ClassView(new NoRegModel(State.tournaments),
        this.$view, 'noreg');

    // name maxwidth checkbox
    value = State.tabOptions.nameMaxWidth;
    $container = this.$view.find('>.options input.maxwidth');
    this.maxwidthCheckBoxView = new CheckBoxView(value, $container);
    this.maxwidthClassView = new ClassView(value, this.$view, 'maxwidth',
        'nomaxwidth');

    // list/table selection checkbox
    value = State.tabOptions.teamTable;
    $container = this.$view.find('>.options input.showtable');
    this.showtableCheckBoxView = new CheckBoxView(value, $container);
    this.showtableClassView = new ClassView(value, this.$view, 'showtable');

    // update the tab when the team size changes
    if (Presets.registration.teamsizeicon) {
      TabsHandle.bindTabOpts('teams', State.teamsize);
    }

    // team removal controllers
    $container = this.$view.find('>button.delete');
    this.teamRemoveController = new TeamRemoveController([this.teamList,
        this.teamTable], $container, this.$view);

    $container = this.$view.find('>button.deleteall');
    this.deleteAllTeamsController = new DeleteAllTeamsController(new View(
        undefined, $container));

    // hide teamTable content depending on state
    this.teamTableView = new TeamTableView(this.teamTable, State.teamsize);

    $button = this.$view.find('>button.fileloadteams');
    this.teamsFileLoadController = new TeamsFileLoadController($button);

    this.autocompletionModel = Storage.register(Presets.names.dbplayername,
        AutocompletionModel);
    this.autocompletionModel.download(Presets.names.playernameurl);

    $container = this.$view.find('input.playername');
    this.autocompletionView = new AutocompletionView(this.autocompletionModel,
        $container);

    $container = this.$view.find('.downloadcsvexample');
    this.downloadexamplecontroller = new TeamFormatDownloadController(new View(
        undefined, $container));
  };

  TeamsTab.prototype.onupdate = function() {
    this.update();
  };

  TeamsTab.prototype.update = function() {
    if (TimeMachine.commit.get()) {
      TabsHandle.show('teams');
    } else {
      TabsHandle.hide('teams');
    }
  };

  // FIXME CHEAP HACK AHEAD
  $(function($) {
    var $tab;

    $tab = $('#tabs > [data-tab="teams"]');
    if ($tab.length && $('#testmain').length === 0) {
      return new TeamsTab($tab);
    }
  });

  return TeamsTab;
});

/**
 * Emit toasts when a team action is performed in the teams tab, i.e. adding,
 * removing or renaming.
 *
 * @return TeamToastsListener
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('ui/teamtoastslistener',['lib/extend', 'core/listener', 'ui/state', './listcollectormodel',
    './teammodel', './toast', './strings'], function(extend, Listener, State,
    ListCollectorModel, TeamModel, Toast, Strings) {

  function TeamToastsListener(emitter) {
    TeamToastsListener.superconstructor.call(this, emitter);
  }
  extend(TeamToastsListener, Listener);

  TeamToastsListener.prototype.onupdate = function(teamlist, event, data) {
    var newname, team, player;

    team = data.source;
    if (team) {
      player = team.getPlayer(data.id);
      if (player) {
        newname = player.getName();
        return new Toast(Strings.namechanged.replace('%s', newname));
      }
    }
  };

  TeamToastsListener.prototype.oninsert = function(teamlist, event, data) {
    var teamno;

    teamno = data.id;
    return new Toast(Strings.teamadded.replace('%s', teamno + 1));
  };

  TeamToastsListener.prototype.onremove = function(teamlist, event, data) {
    var teamno;

    teamno = data.id;
    return new Toast(Strings.teamdeleted.replace('%s', teamno + 1));
  };

  TeamToastsListener.listeners = {};

  TeamToastsListener.init = function() {
    // FIXME move this to the storage file, or associate it somehow otherwise
    TeamToastsListener.listeners.teams = new TeamToastsListener(State.teams);
    TeamToastsListener.listeners.namechange = new TeamToastsListener(
        new ListCollectorModel(State.teams, TeamModel));
  };

  return TeamToastsListener;
});

/**
 * common.js: loads each requirejs-compatible script file (except tests)
 *
 * This file is automatically generated as part of the build process.
 * Do not attempt manual changes
 *
 * @return Common
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/common',[
  'lib/Blob',
  'lib/diff',
  'lib/extend',
  'lib/FileSaver',
  'lib/jquery',
  'lib/modernizr',
  'lib/typeahead',
  'core/absolutematrix',
  'core/antisymmetricmatrixmodel',
  'core/binningreferencelistmodel',
  'core/byeresult',
  'core/classview',
  'core/combinedreferencelistmodel',
  'core/controller',
  'core/correctionmodel',
  'core/correctionreferencemodel',
  'core/delegatematrix',
  'core/emitter',
  'core/indexedlistmodel',
  'core/indexedmodel',
  'core/kotournamentmodel',
  'core/lengthmodel',
  'core/listener',
  'core/listexclusionlistener',
  'core/listmodel',
  'core/listupdatelistener',
  'core/maplistmodel',
  'core/matchmodel',
  'core/matchreferencemodel',
  'core/matchresult',
  'core/matrixmodel',
  'core/model',
  'core/orderlistmodel',
  'core/positivematrix',
  'core/propertymodel',
  'core/propertyvaluemodel',
  'core/random',
  'core/rankingbuchholzcomponent',
  'core/rankingbuchholzlistener',
  'core/rankingbyelistener',
  'core/rankingcomponentindex',
  'core/rankingcomponent',
  'core/rankingdatalistenerindex',
  'core/rankingdatalistener',
  'core/rankingdownvoteslistener',
  'core/rankingfinebuchholzcomponent',
  'core/rankingfinebuchholzlistener',
  'core/rankinggamematrixlistener',
  'core/rankingheadtoheadcomponent',
  'core/rankingheadtoheadlistener',
  'core/rankingidcomponent',
  'core/rankingkocomponent',
  'core/rankingkolistener',
  'core/rankinglostpointscomponent',
  'core/rankinglostpointslistener',
  'core/rankingmapper',
  'core/rankingmodel',
  'core/rankingnumgamescomponent',
  'core/rankingnumgameslistener',
  'core/rankingpointscomponent',
  'core/rankingpointslistener',
  'core/rankingsaldocomponent',
  'core/rankingsaldolistener',
  'core/rankingsonneborncomponent',
  'core/rankingsonnebornlistener',
  'core/rankingtaccomponent',
  'core/rankingtaclistener',
  'core/rankingupvoteslistener',
  'core/rankingvotescomponent',
  'core/rankingvoteslistener',
  'core/rankingwinscomponent',
  'core/rankingwinslistener',
  'core/rankingwinsmatrixlistener',
  'core/readonlylistmodel',
  'core/referencelistmodel',
  'core/resultreferencemodel',
  'core/rle',
  'core/roundtournamentmodel',
  'core/selectionvaluemodel',
  'core/sortedreferencelistmodel',
  'core/statevaluemodel',
  'core/swisstournamentmodel',
  'core/symmetricmatrixmodel',
  'core/tabimageview',
  'core/tabmenucontroller',
  'core/tabmenuview',
  'core/tabmodel',
  'core/tournamentindex',
  'core/tournamentlistmodel',
  'core/tournamentmodel',
  'core/transposedifferencematrix',
  'core/transposesummatrix',
  'core/trianglematrixmodel',
  'core/type',
  'core/uniquelistmodel',
  'core/valuemodel',
  'core/vectormodel',
  'core/view',
  'timemachine/commitmodel',
  'timemachine/keymodel',
  'timemachine/query',
  'timemachine/reflog',
  'timemachine/timemachine',
  'ui/attributevalueview',
  'ui/autocompletionmodel',
  'ui/autocompletionview',
  'ui/backgroundscripts/autosave',
  'ui/backgroundscripts/dropstyle',
  'ui/backgroundscripts/featuredetect',
  'ui/backgroundscripts/fonthotkeys',
  'ui/backgroundscripts/initboxviews',
  'ui/backgroundscripts/matchtoasts',
  'ui/backgroundscripts/online',
  'ui/backgroundscripts/print',
  'ui/backgroundscripts/reset',
  'ui/backgroundscripts/save',
  'ui/backgroundscripts/statetoasts',
  'ui/backgroundscripts/tournamenterrortoasts',
  'ui/binarytreemodel',
  'ui/boxcontroller',
  'ui/boxview',
  'ui/browserinfocontroller',
  'ui/browserinfoview',
  'ui/browser',
  'ui/checkboxcontroller',
  'ui/checkboxview',
  'ui/closedtournamentcollapselistener',
  'ui/correctionview',
  'ui/csvexportcontroller',
  'ui/debug',
  'ui/debugtab',
  'ui/deleteallteamscontroller',
  'ui/fileloadcontroller',
  'ui/filesavermodel',
  'ui/finishroundcontroller',
  'ui/fontsizecontroller',
  'ui/fontsizemodel',
  'ui/fontsizeview',
  'ui/gamestab',
  'ui/generictournamenthistoryview',
  'ui/generictournamentview',
  'ui/historytab',
  'ui/hometab',
  'ui/imageview',
  'ui/inlinelistview',
  'ui/inputview',
  'ui/kohistoryview',
  'ui/koline',
  'ui/kolineview',
  'ui/kolistmodel',
  'ui/komatchresultview',
  'ui/kotournamentcontroller',
  'ui/kotournamentview',
  'ui/kotreeposition',
  'ui/kotreeview',
  'ui/legacyloadermodel',
  'ui/legacystoragekeyconverter',
  'ui/lengthview',
  'ui/listcleanuplistener',
  'ui/listclickcontroller',
  'ui/listcollectormodel',
  'ui/listview',
  'ui/loadedimagesview',
  'ui/logincontroller',
  'ui/loginview',
  'ui/matchcontroller',
  'ui/matchresultcontroller',
  'ui/matchresultview',
  'ui/matchtableview',
  'ui/matchview',
  'ui/messagemodel',
  'ui/newtab',
  'ui/newteamcontroller',
  'ui/newteamview',
  'ui/newtournamentcontroller',
  'ui/newtournamentview',
  'ui/noregmodel',
  'ui/optionstemplate',
  'ui/playermodel',
  'ui/popoutboxview',
  'ui/popoutcontroller',
  'ui/preregcloserview',
  'ui/progresslistmodel',
  'ui/progressroundview',
  'ui/progressrowview',
  'ui/progresstableview',
  'ui/rankingcomponentview',
  'ui/rankingordercontroller',
  'ui/rankingorderview',
  'ui/rankingtab',
  'ui/rankingview',
  'ui/registeridscontroller',
  'ui/registerteamscontroller',
  'ui/renamecontroller',
  'ui/requiremodsshortcut',
  'ui/reversematchreferencemodel',
  'ui/reverseresultreferencemodel',
  'ui/roundtournamentview',
  'ui/serverautoloadmodel',
  'ui/servermodel',
  'ui/servertournamentcontroller',
  'ui/servertournamentlistmodel',
  'ui/servertournamentloader',
  'ui/servertournamentmodel',
  'ui/servertournamentview',
  'ui/settingstab',
  'ui/splash',
  'ui/stateclassview',
  'ui/statefileloadcontroller',
  'ui/state',
  'ui/stateloader',
  'ui/statemodel',
  'ui/statesaver',
  'ui/storage',
  'ui/strings',
  'ui/swissmaxroundview',
  'ui/swisstournamentcontroller',
  'ui/swisstournamentview',
  'ui/swissvotepropcontroller',
  'ui/swissvotepropview',
  'ui/swissvotesview',
  'ui/systemlistview',
  'ui/systemtablerowview',
  'ui/tabshandle',
  'ui/teamcontroller',
  'ui/teamformatdownloadcontroller',
  'ui/teammodel',
  'ui/teamremovecontroller',
  'ui/teamsfileloadcontroller',
  'ui/teamsizecontroller',
  'ui/teamsizeview',
  'ui/teamstab',
  'ui/teamtableview',
  'ui/teamtoastslistener',
  'ui/teamview',
  'ui/templateview',
  'ui/textview',
  'ui/timemachinecommitcontroller',
  'ui/timemachinecommitview',
  'ui/timemachinenewtreecontroller',
  'ui/timemachineview',
  'ui/toast',
  'ui/tournamentcontroller',
  'ui/tournamenthistoryview',
  'ui/tournamentmatchesview',
  'ui/tournamentrankingview',
  'ui/tournamentrenamecontroller',
  'ui/tournamentview',
  'ui/tournamentviewpopulator',
  'ui/unicodehelper',
  'ui/update',
  'ui/valueview'
], function(undefined) {
  var Common = function(str) {
    var module = require.s.contexts._.defined[str];
    if (!module) {
      throw new Error('module "' + str +
        '" is undefined, not loaded or equals 0 in some way => ' + module);
    }
    return module;
  };

  return Common;
});

/*!
 * QUnit 1.14.0
 * http://qunitjs.com/
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-01-31T16:40Z
 */

(function( window ) {

var QUnit,
	assert,
	config,
	onErrorFnPrev,
	testId = 0,
	fileName = (sourceFromStacktrace( 0 ) || "" ).replace(/(:\d+)+\)?/, "").replace(/.+\//, ""),
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	// Keep a local reference to Date (GH-283)
	Date = window.Date,
	setTimeout = window.setTimeout,
	clearTimeout = window.clearTimeout,
	defined = {
		document: typeof window.document !== "undefined",
		setTimeout: typeof window.setTimeout !== "undefined",
		sessionStorage: (function() {
			var x = "qunit-test-string";
			try {
				sessionStorage.setItem( x, x );
				sessionStorage.removeItem( x );
				return true;
			} catch( e ) {
				return false;
			}
		}())
	},
	/**
	 * Provides a normalized error string, correcting an issue
	 * with IE 7 (and prior) where Error.prototype.toString is
	 * not properly implemented
	 *
	 * Based on http://es5.github.com/#x15.11.4.4
	 *
	 * @param {String|Error} error
	 * @return {String} error message
	 */
	errorString = function( error ) {
		var name, message,
			errorString = error.toString();
		if ( errorString.substring( 0, 7 ) === "[object" ) {
			name = error.name ? error.name.toString() : "Error";
			message = error.message ? error.message.toString() : "";
			if ( name && message ) {
				return name + ": " + message;
			} else if ( name ) {
				return name;
			} else if ( message ) {
				return message;
			} else {
				return "Error";
			}
		} else {
			return errorString;
		}
	},
	/**
	 * Makes a clone of an object using only Array or Object as base,
	 * and copies over the own enumerable properties.
	 *
	 * @param {Object} obj
	 * @return {Object} New object with only the own properties (recursively).
	 */
	objectValues = function( obj ) {
		// Grunt 0.3.x uses an older version of jshint that still has jshint/jshint#392.
		/*jshint newcap: false */
		var key, val,
			vals = QUnit.is( "array", obj ) ? [] : {};
		for ( key in obj ) {
			if ( hasOwn.call( obj, key ) ) {
				val = obj[key];
				vals[key] = val === Object(val) ? objectValues(val) : val;
			}
		}
		return vals;
	};


// Root QUnit object.
// `QUnit` initialized at top of scope
QUnit = {

	// call on start of module test to prepend name to all tests
	module: function( name, testEnvironment ) {
		config.currentModule = name;
		config.currentModuleTestEnvironment = testEnvironment;
		config.modules[name] = true;
	},

	asyncTest: function( testName, expected, callback ) {
		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		QUnit.test( testName, expected, callback, true );
	},

	test: function( testName, expected, callback, async ) {
		var test,
			nameHtml = "<span class='test-name'>" + escapeText( testName ) + "</span>";

		if ( arguments.length === 2 ) {
			callback = expected;
			expected = null;
		}

		if ( config.currentModule ) {
			nameHtml = "<span class='module-name'>" + escapeText( config.currentModule ) + "</span>: " + nameHtml;
		}

		test = new Test({
			nameHtml: nameHtml,
			testName: testName,
			expected: expected,
			async: async,
			callback: callback,
			module: config.currentModule,
			moduleTestEnvironment: config.currentModuleTestEnvironment,
			stack: sourceFromStacktrace( 2 )
		});

		if ( !validTest( test ) ) {
			return;
		}

		test.queue();
	},

	// Specify the number of expected assertions to guarantee that failed test (no assertions are run at all) don't slip through.
	expect: function( asserts ) {
		if (arguments.length === 1) {
			config.current.expected = asserts;
		} else {
			return config.current.expected;
		}
	},

	start: function( count ) {
		// QUnit hasn't been initialized yet.
		// Note: RequireJS (et al) may delay onLoad
		if ( config.semaphore === undefined ) {
			QUnit.begin(function() {
				// This is triggered at the top of QUnit.load, push start() to the event loop, to allow QUnit.load to finish first
				setTimeout(function() {
					QUnit.start( count );
				});
			});
			return;
		}

		config.semaphore -= count || 1;
		// don't start until equal number of stop-calls
		if ( config.semaphore > 0 ) {
			return;
		}
		// ignore if start is called more often then stop
		if ( config.semaphore < 0 ) {
			config.semaphore = 0;
			QUnit.pushFailure( "Called start() while already started (QUnit.config.semaphore was 0 already)", null, sourceFromStacktrace(2) );
			return;
		}
		// A slight delay, to avoid any current callbacks
		if ( defined.setTimeout ) {
			setTimeout(function() {
				if ( config.semaphore > 0 ) {
					return;
				}
				if ( config.timeout ) {
					clearTimeout( config.timeout );
				}

				config.blocking = false;
				process( true );
			}, 13);
		} else {
			config.blocking = false;
			process( true );
		}
	},

	stop: function( count ) {
		config.semaphore += count || 1;
		config.blocking = true;

		if ( config.testTimeout && defined.setTimeout ) {
			clearTimeout( config.timeout );
			config.timeout = setTimeout(function() {
				QUnit.ok( false, "Test timed out" );
				config.semaphore = 1;
				QUnit.start();
			}, config.testTimeout );
		}
	}
};

// We use the prototype to distinguish between properties that should
// be exposed as globals (and in exports) and those that shouldn't
(function() {
	function F() {}
	F.prototype = QUnit;
	QUnit = new F();
	// Make F QUnit's constructor so that we can add to the prototype later
	QUnit.constructor = F;
}());

/**
 * Config object: Maintain internal state
 * Later exposed as QUnit.config
 * `config` initialized at top of scope
 */
config = {
	// The queue of tests to run
	queue: [],

	// block until document ready
	blocking: true,

	// when enabled, show only failing tests
	// gets persisted through sessionStorage and can be changed in UI via checkbox
	hidepassed: false,

	// by default, run previously failed tests first
	// very useful in combination with "Hide passed tests" checked
	reorder: true,

	// by default, modify document.title when suite is done
	altertitle: true,

	// by default, scroll to top of the page when suite is done
	scrolltop: true,

	// when enabled, all tests must call expect()
	requireExpects: false,

	// add checkboxes that are persisted in the query-string
	// when enabled, the id is set to `true` as a `QUnit.config` property
	urlConfig: [
		{
			id: "noglobals",
			label: "Check for Globals",
			tooltip: "Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings."
		},
		{
			id: "notrycatch",
			label: "No try-catch",
			tooltip: "Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings."
		}
	],

	// Set of all modules.
	modules: {},

	// logging callback queues
	begin: [],
	done: [],
	log: [],
	testStart: [],
	testDone: [],
	moduleStart: [],
	moduleDone: []
};

// Initialize more QUnit.config and QUnit.urlParams
(function() {
	var i, current,
		location = window.location || { search: "", protocol: "file:" },
		params = location.search.slice( 1 ).split( "&" ),
		length = params.length,
		urlParams = {};

	if ( params[ 0 ] ) {
		for ( i = 0; i < length; i++ ) {
			current = params[ i ].split( "=" );
			current[ 0 ] = decodeURIComponent( current[ 0 ] );

			// allow just a key to turn on a flag, e.g., test.html?noglobals
			current[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;
			if ( urlParams[ current[ 0 ] ] ) {
				urlParams[ current[ 0 ] ] = [].concat( urlParams[ current[ 0 ] ], current[ 1 ] );
			} else {
				urlParams[ current[ 0 ] ] = current[ 1 ];
			}
		}
	}

	QUnit.urlParams = urlParams;

	// String search anywhere in moduleName+testName
	config.filter = urlParams.filter;

	// Exact match of the module name
	config.module = urlParams.module;

	config.testNumber = [];
	if ( urlParams.testNumber ) {

		// Ensure that urlParams.testNumber is an array
		urlParams.testNumber = [].concat( urlParams.testNumber );
		for ( i = 0; i < urlParams.testNumber.length; i++ ) {
			current = urlParams.testNumber[ i ];
			config.testNumber.push( parseInt( current, 10 ) );
		}
	}

	// Figure out if we're running the tests from a server or not
	QUnit.isLocal = location.protocol === "file:";
}());

extend( QUnit, {

	config: config,

	// Initialize the configuration options
	init: function() {
		extend( config, {
			stats: { all: 0, bad: 0 },
			moduleStats: { all: 0, bad: 0 },
			started: +new Date(),
			updateRate: 1000,
			blocking: false,
			autostart: true,
			autorun: false,
			filter: "",
			queue: [],
			semaphore: 1
		});

		var tests, banner, result,
			qunit = id( "qunit" );

		if ( qunit ) {
			qunit.innerHTML =
				"<h1 id='qunit-header'>" + escapeText( document.title ) + "</h1>" +
				"<h2 id='qunit-banner'></h2>" +
				"<div id='qunit-testrunner-toolbar'></div>" +
				"<h2 id='qunit-userAgent'></h2>" +
				"<ol id='qunit-tests'></ol>";
		}

		tests = id( "qunit-tests" );
		banner = id( "qunit-banner" );
		result = id( "qunit-testresult" );

		if ( tests ) {
			tests.innerHTML = "";
		}

		if ( banner ) {
			banner.className = "";
		}

		if ( result ) {
			result.parentNode.removeChild( result );
		}

		if ( tests ) {
			result = document.createElement( "p" );
			result.id = "qunit-testresult";
			result.className = "result";
			tests.parentNode.insertBefore( result, tests );
			result.innerHTML = "Running...<br/>&nbsp;";
		}
	},

	// Resets the test setup. Useful for tests that modify the DOM.
	/*
	DEPRECATED: Use multiple tests instead of resetting inside a test.
	Use testStart or testDone for custom cleanup.
	This method will throw an error in 2.0, and will be removed in 2.1
	*/
	reset: function() {
		var fixture = id( "qunit-fixture" );
		if ( fixture ) {
			fixture.innerHTML = config.fixture;
		}
	},

	// Safe object type checking
	is: function( type, obj ) {
		return QUnit.objectType( obj ) === type;
	},

	objectType: function( obj ) {
		if ( typeof obj === "undefined" ) {
			return "undefined";
		}

		// Consider: typeof null === object
		if ( obj === null ) {
			return "null";
		}

		var match = toString.call( obj ).match(/^\[object\s(.*)\]$/),
			type = match && match[1] || "";

		switch ( type ) {
			case "Number":
				if ( isNaN(obj) ) {
					return "nan";
				}
				return "number";
			case "String":
			case "Boolean":
			case "Array":
			case "Date":
			case "RegExp":
			case "Function":
				return type.toLowerCase();
		}
		if ( typeof obj === "object" ) {
			return "object";
		}
		return undefined;
	},

	push: function( result, actual, expected, message ) {
		if ( !config.current ) {
			throw new Error( "assertion outside test context, was " + sourceFromStacktrace() );
		}

		var output, source,
			details = {
				module: config.current.module,
				name: config.current.testName,
				result: result,
				message: message,
				actual: actual,
				expected: expected
			};

		message = escapeText( message ) || ( result ? "okay" : "failed" );
		message = "<span class='test-message'>" + message + "</span>";
		output = message;

		if ( !result ) {
			expected = escapeText( QUnit.jsDump.parse(expected) );
			actual = escapeText( QUnit.jsDump.parse(actual) );
			output += "<table><tr class='test-expected'><th>Expected: </th><td><pre>" + expected + "</pre></td></tr>";

			if ( actual !== expected ) {
				output += "<tr class='test-actual'><th>Result: </th><td><pre>" + actual + "</pre></td></tr>";
				output += "<tr class='test-diff'><th>Diff: </th><td><pre>" + QUnit.diff( expected, actual ) + "</pre></td></tr>";
			}

			source = sourceFromStacktrace();

			if ( source ) {
				details.source = source;
				output += "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText( source ) + "</pre></td></tr>";
			}

			output += "</table>";
		}

		runLoggingCallbacks( "log", QUnit, details );

		config.current.assertions.push({
			result: !!result,
			message: output
		});
	},

	pushFailure: function( message, source, actual ) {
		if ( !config.current ) {
			throw new Error( "pushFailure() assertion outside test context, was " + sourceFromStacktrace(2) );
		}

		var output,
			details = {
				module: config.current.module,
				name: config.current.testName,
				result: false,
				message: message
			};

		message = escapeText( message ) || "error";
		message = "<span class='test-message'>" + message + "</span>";
		output = message;

		output += "<table>";

		if ( actual ) {
			output += "<tr class='test-actual'><th>Result: </th><td><pre>" + escapeText( actual ) + "</pre></td></tr>";
		}

		if ( source ) {
			details.source = source;
			output += "<tr class='test-source'><th>Source: </th><td><pre>" + escapeText( source ) + "</pre></td></tr>";
		}

		output += "</table>";

		runLoggingCallbacks( "log", QUnit, details );

		config.current.assertions.push({
			result: false,
			message: output
		});
	},

	url: function( params ) {
		params = extend( extend( {}, QUnit.urlParams ), params );
		var key,
			querystring = "?";

		for ( key in params ) {
			if ( hasOwn.call( params, key ) ) {
				querystring += encodeURIComponent( key ) + "=" +
					encodeURIComponent( params[ key ] ) + "&";
			}
		}
		return window.location.protocol + "//" + window.location.host +
			window.location.pathname + querystring.slice( 0, -1 );
	},

	extend: extend,
	id: id,
	addEvent: addEvent,
	addClass: addClass,
	hasClass: hasClass,
	removeClass: removeClass
	// load, equiv, jsDump, diff: Attached later
});

/**
 * @deprecated: Created for backwards compatibility with test runner that set the hook function
 * into QUnit.{hook}, instead of invoking it and passing the hook function.
 * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.
 * Doing this allows us to tell if the following methods have been overwritten on the actual
 * QUnit object.
 */
extend( QUnit.constructor.prototype, {

	// Logging callbacks; all receive a single argument with the listed properties
	// run test/logs.html for any related changes
	begin: registerLoggingCallback( "begin" ),

	// done: { failed, passed, total, runtime }
	done: registerLoggingCallback( "done" ),

	// log: { result, actual, expected, message }
	log: registerLoggingCallback( "log" ),

	// testStart: { name }
	testStart: registerLoggingCallback( "testStart" ),

	// testDone: { name, failed, passed, total, runtime }
	testDone: registerLoggingCallback( "testDone" ),

	// moduleStart: { name }
	moduleStart: registerLoggingCallback( "moduleStart" ),

	// moduleDone: { name, failed, passed, total }
	moduleDone: registerLoggingCallback( "moduleDone" )
});

if ( !defined.document || document.readyState === "complete" ) {
	config.autorun = true;
}

QUnit.load = function() {
	runLoggingCallbacks( "begin", QUnit, {} );

	// Initialize the config, saving the execution queue
	var banner, filter, i, j, label, len, main, ol, toolbar, val, selection,
		urlConfigContainer, moduleFilter, userAgent,
		numModules = 0,
		moduleNames = [],
		moduleFilterHtml = "",
		urlConfigHtml = "",
		oldconfig = extend( {}, config );

	QUnit.init();
	extend(config, oldconfig);

	config.blocking = false;

	len = config.urlConfig.length;

	for ( i = 0; i < len; i++ ) {
		val = config.urlConfig[i];
		if ( typeof val === "string" ) {
			val = {
				id: val,
				label: val
			};
		}
		config[ val.id ] = QUnit.urlParams[ val.id ];
		if ( !val.value || typeof val.value === "string" ) {
			urlConfigHtml += "<input id='qunit-urlconfig-" + escapeText( val.id ) +
				"' name='" + escapeText( val.id ) +
				"' type='checkbox'" +
				( val.value ? " value='" + escapeText( val.value ) + "'" : "" ) +
				( config[ val.id ] ? " checked='checked'" : "" ) +
				" title='" + escapeText( val.tooltip ) +
				"'><label for='qunit-urlconfig-" + escapeText( val.id ) +
				"' title='" + escapeText( val.tooltip ) + "'>" + val.label + "</label>";
		} else {
			urlConfigHtml += "<label for='qunit-urlconfig-" + escapeText( val.id ) +
				"' title='" + escapeText( val.tooltip ) +
				"'>" + val.label +
				": </label><select id='qunit-urlconfig-" + escapeText( val.id ) +
				"' name='" + escapeText( val.id ) +
				"' title='" + escapeText( val.tooltip ) +
				"'><option></option>";
			selection = false;
			if ( QUnit.is( "array", val.value ) ) {
				for ( j = 0; j < val.value.length; j++ ) {
					urlConfigHtml += "<option value='" + escapeText( val.value[j] ) + "'" +
						( config[ val.id ] === val.value[j] ?
							(selection = true) && " selected='selected'" :
							"" ) +
						">" + escapeText( val.value[j] ) + "</option>";
				}
			} else {
				for ( j in val.value ) {
					if ( hasOwn.call( val.value, j ) ) {
						urlConfigHtml += "<option value='" + escapeText( j ) + "'" +
							( config[ val.id ] === j ?
								(selection = true) && " selected='selected'" :
								"" ) +
							">" + escapeText( val.value[j] ) + "</option>";
					}
				}
			}
			if ( config[ val.id ] && !selection ) {
				urlConfigHtml += "<option value='" + escapeText( config[ val.id ] ) +
					"' selected='selected' disabled='disabled'>" +
					escapeText( config[ val.id ] ) +
					"</option>";
			}
			urlConfigHtml += "</select>";
		}
	}
	for ( i in config.modules ) {
		if ( config.modules.hasOwnProperty( i ) ) {
			moduleNames.push(i);
		}
	}
	numModules = moduleNames.length;
	moduleNames.sort( function( a, b ) {
		return a.localeCompare( b );
	});
	moduleFilterHtml += "<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' " +
		( config.module === undefined  ? "selected='selected'" : "" ) +
		">< All Modules ></option>";


	for ( i = 0; i < numModules; i++) {
			moduleFilterHtml += "<option value='" + escapeText( encodeURIComponent(moduleNames[i]) ) + "' " +
				( config.module === moduleNames[i] ? "selected='selected'" : "" ) +
				">" + escapeText(moduleNames[i]) + "</option>";
	}
	moduleFilterHtml += "</select>";

	// `userAgent` initialized at top of scope
	userAgent = id( "qunit-userAgent" );
	if ( userAgent ) {
		userAgent.innerHTML = navigator.userAgent;
	}

	// `banner` initialized at top of scope
	banner = id( "qunit-header" );
	if ( banner ) {
		banner.innerHTML = "<a href='" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + "'>" + banner.innerHTML + "</a> ";
	}

	// `toolbar` initialized at top of scope
	toolbar = id( "qunit-testrunner-toolbar" );
	if ( toolbar ) {
		// `filter` initialized at top of scope
		filter = document.createElement( "input" );
		filter.type = "checkbox";
		filter.id = "qunit-filter-pass";

		addEvent( filter, "click", function() {
			var tmp,
				ol = id( "qunit-tests" );

			if ( filter.checked ) {
				ol.className = ol.className + " hidepass";
			} else {
				tmp = " " + ol.className.replace( /[\n\t\r]/g, " " ) + " ";
				ol.className = tmp.replace( / hidepass /, " " );
			}
			if ( defined.sessionStorage ) {
				if (filter.checked) {
					sessionStorage.setItem( "qunit-filter-passed-tests", "true" );
				} else {
					sessionStorage.removeItem( "qunit-filter-passed-tests" );
				}
			}
		});

		if ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( "qunit-filter-passed-tests" ) ) {
			filter.checked = true;
			// `ol` initialized at top of scope
			ol = id( "qunit-tests" );
			ol.className = ol.className + " hidepass";
		}
		toolbar.appendChild( filter );

		// `label` initialized at top of scope
		label = document.createElement( "label" );
		label.setAttribute( "for", "qunit-filter-pass" );
		label.setAttribute( "title", "Only show tests and assertions that fail. Stored in sessionStorage." );
		label.innerHTML = "Hide passed tests";
		toolbar.appendChild( label );

		urlConfigContainer = document.createElement("span");
		urlConfigContainer.innerHTML = urlConfigHtml;
		// For oldIE support:
		// * Add handlers to the individual elements instead of the container
		// * Use "click" instead of "change" for checkboxes
		// * Fallback from event.target to event.srcElement
		addEvents( urlConfigContainer.getElementsByTagName("input"), "click", function( event ) {
			var params = {},
				target = event.target || event.srcElement;
			params[ target.name ] = target.checked ?
				target.defaultValue || true :
				undefined;
			window.location = QUnit.url( params );
		});
		addEvents( urlConfigContainer.getElementsByTagName("select"), "change", function( event ) {
			var params = {},
				target = event.target || event.srcElement;
			params[ target.name ] = target.options[ target.selectedIndex ].value || undefined;
			window.location = QUnit.url( params );
		});
		toolbar.appendChild( urlConfigContainer );

		if (numModules > 1) {
			moduleFilter = document.createElement( "span" );
			moduleFilter.setAttribute( "id", "qunit-modulefilter-container" );
			moduleFilter.innerHTML = moduleFilterHtml;
			addEvent( moduleFilter.lastChild, "change", function() {
				var selectBox = moduleFilter.getElementsByTagName("select")[0],
					selectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);

				window.location = QUnit.url({
					module: ( selectedModule === "" ) ? undefined : selectedModule,
					// Remove any existing filters
					filter: undefined,
					testNumber: undefined
				});
			});
			toolbar.appendChild(moduleFilter);
		}
	}

	// `main` initialized at top of scope
	main = id( "qunit-fixture" );
	if ( main ) {
		config.fixture = main.innerHTML;
	}

	if ( config.autostart ) {
		QUnit.start();
	}
};

if ( defined.document ) {
	addEvent( window, "load", QUnit.load );
}

// `onErrorFnPrev` initialized at top of scope
// Preserve other handlers
onErrorFnPrev = window.onerror;

// Cover uncaught exceptions
// Returning true will suppress the default browser handler,
// returning false will let it run.
window.onerror = function ( error, filePath, linerNr ) {
	var ret = false;
	if ( onErrorFnPrev ) {
		ret = onErrorFnPrev( error, filePath, linerNr );
	}

	// Treat return value as window.onerror itself does,
	// Only do our handling if not suppressed.
	if ( ret !== true ) {
		if ( QUnit.config.current ) {
			if ( QUnit.config.current.ignoreGlobalErrors ) {
				return true;
			}
			QUnit.pushFailure( error, filePath + ":" + linerNr );
		} else {
			QUnit.test( "global failure", extend( function() {
				QUnit.pushFailure( error, filePath + ":" + linerNr );
			}, { validTest: validTest } ) );
		}
		return false;
	}

	return ret;
};

function done() {
	config.autorun = true;

	// Log the last module results
	if ( config.previousModule ) {
		runLoggingCallbacks( "moduleDone", QUnit, {
			name: config.previousModule,
			failed: config.moduleStats.bad,
			passed: config.moduleStats.all - config.moduleStats.bad,
			total: config.moduleStats.all
		});
	}
	delete config.previousModule;

	var i, key,
		banner = id( "qunit-banner" ),
		tests = id( "qunit-tests" ),
		runtime = +new Date() - config.started,
		passed = config.stats.all - config.stats.bad,
		html = [
			"Tests completed in ",
			runtime,
			" milliseconds.<br/>",
			"<span class='passed'>",
			passed,
			"</span> assertions of <span class='total'>",
			config.stats.all,
			"</span> passed, <span class='failed'>",
			config.stats.bad,
			"</span> failed."
		].join( "" );

	if ( banner ) {
		banner.className = ( config.stats.bad ? "qunit-fail" : "qunit-pass" );
	}

	if ( tests ) {
		id( "qunit-testresult" ).innerHTML = html;
	}

	if ( config.altertitle && defined.document && document.title ) {
		// show ✖ for good, ✔ for bad suite result in title
		// use escape sequences in case file gets loaded with non-utf-8-charset
		document.title = [
			( config.stats.bad ? "\u2716" : "\u2714" ),
			document.title.replace( /^[\u2714\u2716] /i, "" )
		].join( " " );
	}

	// clear own sessionStorage items if all tests passed
	if ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {
		// `key` & `i` initialized at top of scope
		for ( i = 0; i < sessionStorage.length; i++ ) {
			key = sessionStorage.key( i++ );
			if ( key.indexOf( "qunit-test-" ) === 0 ) {
				sessionStorage.removeItem( key );
			}
		}
	}

	// scroll back to top to show results
	if ( config.scrolltop && window.scrollTo ) {
		window.scrollTo(0, 0);
	}

	runLoggingCallbacks( "done", QUnit, {
		failed: config.stats.bad,
		passed: passed,
		total: config.stats.all,
		runtime: runtime
	});
}

/** @return Boolean: true if this test should be ran */
function validTest( test ) {
	var include,
		filter = config.filter && config.filter.toLowerCase(),
		module = config.module && config.module.toLowerCase(),
		fullName = ( test.module + ": " + test.testName ).toLowerCase();

	// Internally-generated tests are always valid
	if ( test.callback && test.callback.validTest === validTest ) {
		delete test.callback.validTest;
		return true;
	}

	if ( config.testNumber.length > 0 ) {
		if ( inArray( test.testNumber, config.testNumber ) < 0 ) {
			return false;
		}
	}

	if ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {
		return false;
	}

	if ( !filter ) {
		return true;
	}

	include = filter.charAt( 0 ) !== "!";
	if ( !include ) {
		filter = filter.slice( 1 );
	}

	// If the filter matches, we need to honour include
	if ( fullName.indexOf( filter ) !== -1 ) {
		return include;
	}

	// Otherwise, do the opposite
	return !include;
}

// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)
// Later Safari and IE10 are supposed to support error.stack as well
// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack
function extractStacktrace( e, offset ) {
	offset = offset === undefined ? 3 : offset;

	var stack, include, i;

	if ( e.stacktrace ) {
		// Opera
		return e.stacktrace.split( "\n" )[ offset + 3 ];
	} else if ( e.stack ) {
		// Firefox, Chrome
		stack = e.stack.split( "\n" );
		if (/^error$/i.test( stack[0] ) ) {
			stack.shift();
		}
		if ( fileName ) {
			include = [];
			for ( i = offset; i < stack.length; i++ ) {
				if ( stack[ i ].indexOf( fileName ) !== -1 ) {
					break;
				}
				include.push( stack[ i ] );
			}
			if ( include.length ) {
				return include.join( "\n" );
			}
		}
		return stack[ offset ];
	} else if ( e.sourceURL ) {
		// Safari, PhantomJS
		// hopefully one day Safari provides actual stacktraces
		// exclude useless self-reference for generated Error objects
		if ( /qunit.js$/.test( e.sourceURL ) ) {
			return;
		}
		// for actual exceptions, this is useful
		return e.sourceURL + ":" + e.line;
	}
}
function sourceFromStacktrace( offset ) {
	try {
		throw new Error();
	} catch ( e ) {
		return extractStacktrace( e, offset );
	}
}

/**
 * Escape text for attribute or text content.
 */
function escapeText( s ) {
	if ( !s ) {
		return "";
	}
	s = s + "";
	// Both single quotes and double quotes (for attributes)
	return s.replace( /['"<>&]/g, function( s ) {
		switch( s ) {
			case "'":
				return "&#039;";
			case "\"":
				return "&quot;";
			case "<":
				return "&lt;";
			case ">":
				return "&gt;";
			case "&":
				return "&amp;";
		}
	});
}

function synchronize( callback, last ) {
	config.queue.push( callback );

	if ( config.autorun && !config.blocking ) {
		process( last );
	}
}

function process( last ) {
	function next() {
		process( last );
	}
	var start = new Date().getTime();
	config.depth = config.depth ? config.depth + 1 : 1;

	while ( config.queue.length && !config.blocking ) {
		if ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {
			config.queue.shift()();
		} else {
			setTimeout( next, 13 );
			break;
		}
	}
	config.depth--;
	if ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {
		done();
	}
}

function saveGlobal() {
	config.pollution = [];

	if ( config.noglobals ) {
		for ( var key in window ) {
			if ( hasOwn.call( window, key ) ) {
				// in Opera sometimes DOM element ids show up here, ignore them
				if ( /^qunit-test-output/.test( key ) ) {
					continue;
				}
				config.pollution.push( key );
			}
		}
	}
}

function checkPollution() {
	var newGlobals,
		deletedGlobals,
		old = config.pollution;

	saveGlobal();

	newGlobals = diff( config.pollution, old );
	if ( newGlobals.length > 0 ) {
		QUnit.pushFailure( "Introduced global variable(s): " + newGlobals.join(", ") );
	}

	deletedGlobals = diff( old, config.pollution );
	if ( deletedGlobals.length > 0 ) {
		QUnit.pushFailure( "Deleted global variable(s): " + deletedGlobals.join(", ") );
	}
}

// returns a new Array with the elements that are in a but not in b
function diff( a, b ) {
	var i, j,
		result = a.slice();

	for ( i = 0; i < result.length; i++ ) {
		for ( j = 0; j < b.length; j++ ) {
			if ( result[i] === b[j] ) {
				result.splice( i, 1 );
				i--;
				break;
			}
		}
	}
	return result;
}

function extend( a, b ) {
	for ( var prop in b ) {
		if ( hasOwn.call( b, prop ) ) {
			// Avoid "Member not found" error in IE8 caused by messing with window.constructor
			if ( !( prop === "constructor" && a === window ) ) {
				if ( b[ prop ] === undefined ) {
					delete a[ prop ];
				} else {
					a[ prop ] = b[ prop ];
				}
			}
		}
	}

	return a;
}

/**
 * @param {HTMLElement} elem
 * @param {string} type
 * @param {Function} fn
 */
function addEvent( elem, type, fn ) {
	if ( elem.addEventListener ) {

		// Standards-based browsers
		elem.addEventListener( type, fn, false );
	} else if ( elem.attachEvent ) {

		// support: IE <9
		elem.attachEvent( "on" + type, fn );
	} else {

		// Caller must ensure support for event listeners is present
		throw new Error( "addEvent() was called in a context without event listener support" );
	}
}

/**
 * @param {Array|NodeList} elems
 * @param {string} type
 * @param {Function} fn
 */
function addEvents( elems, type, fn ) {
	var i = elems.length;
	while ( i-- ) {
		addEvent( elems[i], type, fn );
	}
}

function hasClass( elem, name ) {
	return (" " + elem.className + " ").indexOf(" " + name + " ") > -1;
}

function addClass( elem, name ) {
	if ( !hasClass( elem, name ) ) {
		elem.className += (elem.className ? " " : "") + name;
	}
}

function removeClass( elem, name ) {
	var set = " " + elem.className + " ";
	// Class name may appear multiple times
	while ( set.indexOf(" " + name + " ") > -1 ) {
		set = set.replace(" " + name + " " , " ");
	}
	// If possible, trim it for prettiness, but not necessarily
	elem.className = typeof set.trim === "function" ? set.trim() : set.replace(/^\s+|\s+$/g, "");
}

function id( name ) {
	return defined.document && document.getElementById && document.getElementById( name );
}

function registerLoggingCallback( key ) {
	return function( callback ) {
		config[key].push( callback );
	};
}

// Supports deprecated method of completely overwriting logging callbacks
function runLoggingCallbacks( key, scope, args ) {
	var i, callbacks;
	if ( QUnit.hasOwnProperty( key ) ) {
		QUnit[ key ].call(scope, args );
	} else {
		callbacks = config[ key ];
		for ( i = 0; i < callbacks.length; i++ ) {
			callbacks[ i ].call( scope, args );
		}
	}
}

// from jquery.js
function inArray( elem, array ) {
	if ( array.indexOf ) {
		return array.indexOf( elem );
	}

	for ( var i = 0, length = array.length; i < length; i++ ) {
		if ( array[ i ] === elem ) {
			return i;
		}
	}

	return -1;
}

function Test( settings ) {
	extend( this, settings );
	this.assertions = [];
	this.testNumber = ++Test.count;
}

Test.count = 0;

Test.prototype = {
	init: function() {
		var a, b, li,
			tests = id( "qunit-tests" );

		if ( tests ) {
			b = document.createElement( "strong" );
			b.innerHTML = this.nameHtml;

			// `a` initialized at top of scope
			a = document.createElement( "a" );
			a.innerHTML = "Rerun";
			a.href = QUnit.url({ testNumber: this.testNumber });

			li = document.createElement( "li" );
			li.appendChild( b );
			li.appendChild( a );
			li.className = "running";
			li.id = this.id = "qunit-test-output" + testId++;

			tests.appendChild( li );
		}
	},
	setup: function() {
		if (
			// Emit moduleStart when we're switching from one module to another
			this.module !== config.previousModule ||
				// They could be equal (both undefined) but if the previousModule property doesn't
				// yet exist it means this is the first test in a suite that isn't wrapped in a
				// module, in which case we'll just emit a moduleStart event for 'undefined'.
				// Without this, reporters can get testStart before moduleStart  which is a problem.
				!hasOwn.call( config, "previousModule" )
		) {
			if ( hasOwn.call( config, "previousModule" ) ) {
				runLoggingCallbacks( "moduleDone", QUnit, {
					name: config.previousModule,
					failed: config.moduleStats.bad,
					passed: config.moduleStats.all - config.moduleStats.bad,
					total: config.moduleStats.all
				});
			}
			config.previousModule = this.module;
			config.moduleStats = { all: 0, bad: 0 };
			runLoggingCallbacks( "moduleStart", QUnit, {
				name: this.module
			});
		}

		config.current = this;

		this.testEnvironment = extend({
			setup: function() {},
			teardown: function() {}
		}, this.moduleTestEnvironment );

		this.started = +new Date();
		runLoggingCallbacks( "testStart", QUnit, {
			name: this.testName,
			module: this.module
		});

		/*jshint camelcase:false */


		/**
		 * Expose the current test environment.
		 *
		 * @deprecated since 1.12.0: Use QUnit.config.current.testEnvironment instead.
		 */
		QUnit.current_testEnvironment = this.testEnvironment;

		/*jshint camelcase:true */

		if ( !config.pollution ) {
			saveGlobal();
		}
		if ( config.notrycatch ) {
			this.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );
			return;
		}
		try {
			this.testEnvironment.setup.call( this.testEnvironment, QUnit.assert );
		} catch( e ) {
			QUnit.pushFailure( "Setup failed on " + this.testName + ": " + ( e.message || e ), extractStacktrace( e, 1 ) );
		}
	},
	run: function() {
		config.current = this;

		var running = id( "qunit-testresult" );

		if ( running ) {
			running.innerHTML = "Running: <br/>" + this.nameHtml;
		}

		if ( this.async ) {
			QUnit.stop();
		}

		this.callbackStarted = +new Date();

		if ( config.notrycatch ) {
			this.callback.call( this.testEnvironment, QUnit.assert );
			this.callbackRuntime = +new Date() - this.callbackStarted;
			return;
		}

		try {
			this.callback.call( this.testEnvironment, QUnit.assert );
			this.callbackRuntime = +new Date() - this.callbackStarted;
		} catch( e ) {
			this.callbackRuntime = +new Date() - this.callbackStarted;

			QUnit.pushFailure( "Died on test #" + (this.assertions.length + 1) + " " + this.stack + ": " + ( e.message || e ), extractStacktrace( e, 0 ) );
			// else next test will carry the responsibility
			saveGlobal();

			// Restart the tests if they're blocking
			if ( config.blocking ) {
				QUnit.start();
			}
		}
	},
	teardown: function() {
		config.current = this;
		if ( config.notrycatch ) {
			if ( typeof this.callbackRuntime === "undefined" ) {
				this.callbackRuntime = +new Date() - this.callbackStarted;
			}
			this.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );
			return;
		} else {
			try {
				this.testEnvironment.teardown.call( this.testEnvironment, QUnit.assert );
			} catch( e ) {
				QUnit.pushFailure( "Teardown failed on " + this.testName + ": " + ( e.message || e ), extractStacktrace( e, 1 ) );
			}
		}
		checkPollution();
	},
	finish: function() {
		config.current = this;
		if ( config.requireExpects && this.expected === null ) {
			QUnit.pushFailure( "Expected number of assertions to be defined, but expect() was not called.", this.stack );
		} else if ( this.expected !== null && this.expected !== this.assertions.length ) {
			QUnit.pushFailure( "Expected " + this.expected + " assertions, but " + this.assertions.length + " were run", this.stack );
		} else if ( this.expected === null && !this.assertions.length ) {
			QUnit.pushFailure( "Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.", this.stack );
		}

		var i, assertion, a, b, time, li, ol,
			test = this,
			good = 0,
			bad = 0,
			tests = id( "qunit-tests" );

		this.runtime = +new Date() - this.started;
		config.stats.all += this.assertions.length;
		config.moduleStats.all += this.assertions.length;

		if ( tests ) {
			ol = document.createElement( "ol" );
			ol.className = "qunit-assert-list";

			for ( i = 0; i < this.assertions.length; i++ ) {
				assertion = this.assertions[i];

				li = document.createElement( "li" );
				li.className = assertion.result ? "pass" : "fail";
				li.innerHTML = assertion.message || ( assertion.result ? "okay" : "failed" );
				ol.appendChild( li );

				if ( assertion.result ) {
					good++;
				} else {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}

			// store result when possible
			if ( QUnit.config.reorder && defined.sessionStorage ) {
				if ( bad ) {
					sessionStorage.setItem( "qunit-test-" + this.module + "-" + this.testName, bad );
				} else {
					sessionStorage.removeItem( "qunit-test-" + this.module + "-" + this.testName );
				}
			}

			if ( bad === 0 ) {
				addClass( ol, "qunit-collapsed" );
			}

			// `b` initialized at top of scope
			b = document.createElement( "strong" );
			b.innerHTML = this.nameHtml + " <b class='counts'>(<b class='failed'>" + bad + "</b>, <b class='passed'>" + good + "</b>, " + this.assertions.length + ")</b>";

			addEvent(b, "click", function() {
				var next = b.parentNode.lastChild,
					collapsed = hasClass( next, "qunit-collapsed" );
				( collapsed ? removeClass : addClass )( next, "qunit-collapsed" );
			});

			addEvent(b, "dblclick", function( e ) {
				var target = e && e.target ? e.target : window.event.srcElement;
				if ( target.nodeName.toLowerCase() === "span" || target.nodeName.toLowerCase() === "b" ) {
					target = target.parentNode;
				}
				if ( window.location && target.nodeName.toLowerCase() === "strong" ) {
					window.location = QUnit.url({ testNumber: test.testNumber });
				}
			});

			// `time` initialized at top of scope
			time = document.createElement( "span" );
			time.className = "runtime";
			time.innerHTML = this.runtime + " ms";

			// `li` initialized at top of scope
			li = id( this.id );
			li.className = bad ? "fail" : "pass";
			li.removeChild( li.firstChild );
			a = li.firstChild;
			li.appendChild( b );
			li.appendChild( a );
			li.appendChild( time );
			li.appendChild( ol );

		} else {
			for ( i = 0; i < this.assertions.length; i++ ) {
				if ( !this.assertions[i].result ) {
					bad++;
					config.stats.bad++;
					config.moduleStats.bad++;
				}
			}
		}

		runLoggingCallbacks( "testDone", QUnit, {
			name: this.testName,
			module: this.module,
			failed: bad,
			passed: this.assertions.length - bad,
			total: this.assertions.length,
			runtime: this.runtime,
			// DEPRECATED: this property will be removed in 2.0.0, use runtime instead
			duration: this.runtime
		});

		QUnit.reset();

		config.current = undefined;
	},

	queue: function() {
		var bad,
			test = this;

		synchronize(function() {
			test.init();
		});
		function run() {
			// each of these can by async
			synchronize(function() {
				test.setup();
			});
			synchronize(function() {
				test.run();
			});
			synchronize(function() {
				test.teardown();
			});
			synchronize(function() {
				test.finish();
			});
		}

		// `bad` initialized at top of scope
		// defer when previous test run passed, if storage is available
		bad = QUnit.config.reorder && defined.sessionStorage &&
						+sessionStorage.getItem( "qunit-test-" + this.module + "-" + this.testName );

		if ( bad ) {
			run();
		} else {
			synchronize( run, true );
		}
	}
};

// `assert` initialized at top of scope
// Assert helpers
// All of these must either call QUnit.push() or manually do:
// - runLoggingCallbacks( "log", .. );
// - config.current.assertions.push({ .. });
assert = QUnit.assert = {
	/**
	 * Asserts rough true-ish result.
	 * @name ok
	 * @function
	 * @example ok( "asdfasdf".length > 5, "There must be at least 5 chars" );
	 */
	ok: function( result, msg ) {
		if ( !config.current ) {
			throw new Error( "ok() assertion outside test context, was " + sourceFromStacktrace(2) );
		}
		result = !!result;
		msg = msg || ( result ? "okay" : "failed" );

		var source,
			details = {
				module: config.current.module,
				name: config.current.testName,
				result: result,
				message: msg
			};

		msg = "<span class='test-message'>" + escapeText( msg ) + "</span>";

		if ( !result ) {
			source = sourceFromStacktrace( 2 );
			if ( source ) {
				details.source = source;
				msg += "<table><tr class='test-source'><th>Source: </th><td><pre>" +
					escapeText( source ) +
					"</pre></td></tr></table>";
			}
		}
		runLoggingCallbacks( "log", QUnit, details );
		config.current.assertions.push({
			result: result,
			message: msg
		});
	},

	/**
	 * Assert that the first two arguments are equal, with an optional message.
	 * Prints out both actual and expected values.
	 * @name equal
	 * @function
	 * @example equal( format( "Received {0} bytes.", 2), "Received 2 bytes.", "format() replaces {0} with next argument" );
	 */
	equal: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		QUnit.push( expected == actual, actual, expected, message );
	},

	/**
	 * @name notEqual
	 * @function
	 */
	notEqual: function( actual, expected, message ) {
		/*jshint eqeqeq:false */
		QUnit.push( expected != actual, actual, expected, message );
	},

	/**
	 * @name propEqual
	 * @function
	 */
	propEqual: function( actual, expected, message ) {
		actual = objectValues(actual);
		expected = objectValues(expected);
		QUnit.push( QUnit.equiv(actual, expected), actual, expected, message );
	},

	/**
	 * @name notPropEqual
	 * @function
	 */
	notPropEqual: function( actual, expected, message ) {
		actual = objectValues(actual);
		expected = objectValues(expected);
		QUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );
	},

	/**
	 * @name deepEqual
	 * @function
	 */
	deepEqual: function( actual, expected, message ) {
		QUnit.push( QUnit.equiv(actual, expected), actual, expected, message );
	},

	/**
	 * @name notDeepEqual
	 * @function
	 */
	notDeepEqual: function( actual, expected, message ) {
		QUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );
	},

	/**
	 * @name strictEqual
	 * @function
	 */
	strictEqual: function( actual, expected, message ) {
		QUnit.push( expected === actual, actual, expected, message );
	},

	/**
	 * @name notStrictEqual
	 * @function
	 */
	notStrictEqual: function( actual, expected, message ) {
		QUnit.push( expected !== actual, actual, expected, message );
	},

	"throws": function( block, expected, message ) {
		var actual,
			expectedOutput = expected,
			ok = false;

		// 'expected' is optional
		if ( !message && typeof expected === "string" ) {
			message = expected;
			expected = null;
		}

		config.current.ignoreGlobalErrors = true;
		try {
			block.call( config.current.testEnvironment );
		} catch (e) {
			actual = e;
		}
		config.current.ignoreGlobalErrors = false;

		if ( actual ) {

			// we don't want to validate thrown error
			if ( !expected ) {
				ok = true;
				expectedOutput = null;

			// expected is an Error object
			} else if ( expected instanceof Error ) {
				ok = actual instanceof Error &&
					 actual.name === expected.name &&
					 actual.message === expected.message;

			// expected is a regexp
			} else if ( QUnit.objectType( expected ) === "regexp" ) {
				ok = expected.test( errorString( actual ) );

			// expected is a string
			} else if ( QUnit.objectType( expected ) === "string" ) {
				ok = expected === errorString( actual );

			// expected is a constructor
			} else if ( actual instanceof expected ) {
				ok = true;

			// expected is a validation function which returns true is validation passed
			} else if ( expected.call( {}, actual ) === true ) {
				expectedOutput = null;
				ok = true;
			}

			QUnit.push( ok, actual, expectedOutput, message );
		} else {
			QUnit.pushFailure( message, null, "No exception was thrown." );
		}
	}
};

/**
 * @deprecated since 1.8.0
 * Kept assertion helpers in root for backwards compatibility.
 */
extend( QUnit.constructor.prototype, assert );

/**
 * @deprecated since 1.9.0
 * Kept to avoid TypeErrors for undefined methods.
 */
QUnit.constructor.prototype.raises = function() {
	QUnit.push( false, false, false, "QUnit.raises has been deprecated since 2012 (fad3c1ea), use QUnit.throws instead" );
};

/**
 * @deprecated since 1.0.0, replaced with error pushes since 1.3.0
 * Kept to avoid TypeErrors for undefined methods.
 */
QUnit.constructor.prototype.equals = function() {
	QUnit.push( false, false, false, "QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead" );
};
QUnit.constructor.prototype.same = function() {
	QUnit.push( false, false, false, "QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead" );
};

// Test for equality any JavaScript type.
// Author: Philippe Rathé <prathe@gmail.com>
QUnit.equiv = (function() {

	// Call the o related callback with the given arguments.
	function bindCallbacks( o, callbacks, args ) {
		var prop = QUnit.objectType( o );
		if ( prop ) {
			if ( QUnit.objectType( callbacks[ prop ] ) === "function" ) {
				return callbacks[ prop ].apply( callbacks, args );
			} else {
				return callbacks[ prop ]; // or undefined
			}
		}
	}

	// the real equiv function
	var innerEquiv,
		// stack to decide between skip/abort functions
		callers = [],
		// stack to avoiding loops from circular referencing
		parents = [],
		parentsB = [],

		getProto = Object.getPrototypeOf || function ( obj ) {
			/*jshint camelcase:false */
			return obj.__proto__;
		},
		callbacks = (function () {

			// for string, boolean, number and null
			function useStrictEquality( b, a ) {
				/*jshint eqeqeq:false */
				if ( b instanceof a.constructor || a instanceof b.constructor ) {
					// to catch short annotation VS 'new' annotation of a
					// declaration
					// e.g. var i = 1;
					// var j = new Number(1);
					return a == b;
				} else {
					return a === b;
				}
			}

			return {
				"string": useStrictEquality,
				"boolean": useStrictEquality,
				"number": useStrictEquality,
				"null": useStrictEquality,
				"undefined": useStrictEquality,

				"nan": function( b ) {
					return isNaN( b );
				},

				"date": function( b, a ) {
					return QUnit.objectType( b ) === "date" && a.valueOf() === b.valueOf();
				},

				"regexp": function( b, a ) {
					return QUnit.objectType( b ) === "regexp" &&
						// the regex itself
						a.source === b.source &&
						// and its modifiers
						a.global === b.global &&
						// (gmi) ...
						a.ignoreCase === b.ignoreCase &&
						a.multiline === b.multiline &&
						a.sticky === b.sticky;
				},

				// - skip when the property is a method of an instance (OOP)
				// - abort otherwise,
				// initial === would have catch identical references anyway
				"function": function() {
					var caller = callers[callers.length - 1];
					return caller !== Object && typeof caller !== "undefined";
				},

				"array": function( b, a ) {
					var i, j, len, loop, aCircular, bCircular;

					// b could be an object literal here
					if ( QUnit.objectType( b ) !== "array" ) {
						return false;
					}

					len = a.length;
					if ( len !== b.length ) {
						// safe and faster
						return false;
					}

					// track reference to avoid circular references
					parents.push( a );
					parentsB.push( b );
					for ( i = 0; i < len; i++ ) {
						loop = false;
						for ( j = 0; j < parents.length; j++ ) {
							aCircular = parents[j] === a[i];
							bCircular = parentsB[j] === b[i];
							if ( aCircular || bCircular ) {
								if ( a[i] === b[i] || aCircular && bCircular ) {
									loop = true;
								} else {
									parents.pop();
									parentsB.pop();
									return false;
								}
							}
						}
						if ( !loop && !innerEquiv(a[i], b[i]) ) {
							parents.pop();
							parentsB.pop();
							return false;
						}
					}
					parents.pop();
					parentsB.pop();
					return true;
				},

				"object": function( b, a ) {
					/*jshint forin:false */
					var i, j, loop, aCircular, bCircular,
						// Default to true
						eq = true,
						aProperties = [],
						bProperties = [];

					// comparing constructors is more strict than using
					// instanceof
					if ( a.constructor !== b.constructor ) {
						// Allow objects with no prototype to be equivalent to
						// objects with Object as their constructor.
						if ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||
							( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {
								return false;
						}
					}

					// stack constructor before traversing properties
					callers.push( a.constructor );

					// track reference to avoid circular references
					parents.push( a );
					parentsB.push( b );

					// be strict: don't ensure hasOwnProperty and go deep
					for ( i in a ) {
						loop = false;
						for ( j = 0; j < parents.length; j++ ) {
							aCircular = parents[j] === a[i];
							bCircular = parentsB[j] === b[i];
							if ( aCircular || bCircular ) {
								if ( a[i] === b[i] || aCircular && bCircular ) {
									loop = true;
								} else {
									eq = false;
									break;
								}
							}
						}
						aProperties.push(i);
						if ( !loop && !innerEquiv(a[i], b[i]) ) {
							eq = false;
							break;
						}
					}

					parents.pop();
					parentsB.pop();
					callers.pop(); // unstack, we are done

					for ( i in b ) {
						bProperties.push( i ); // collect b's properties
					}

					// Ensures identical properties name
					return eq && innerEquiv( aProperties.sort(), bProperties.sort() );
				}
			};
		}());

	innerEquiv = function() { // can take multiple arguments
		var args = [].slice.apply( arguments );
		if ( args.length < 2 ) {
			return true; // end transition
		}

		return (function( a, b ) {
			if ( a === b ) {
				return true; // catch the most you can
			} else if ( a === null || b === null || typeof a === "undefined" ||
					typeof b === "undefined" ||
					QUnit.objectType(a) !== QUnit.objectType(b) ) {
				return false; // don't lose time with error prone cases
			} else {
				return bindCallbacks(a, callbacks, [ b, a ]);
			}

			// apply transition with (1..n) arguments
		}( args[0], args[1] ) && innerEquiv.apply( this, args.splice(1, args.length - 1 )) );
	};

	return innerEquiv;
}());

/**
 * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |
 * http://flesler.blogspot.com Licensed under BSD
 * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008
 *
 * @projectDescription Advanced and extensible data dumping for Javascript.
 * @version 1.0.0
 * @author Ariel Flesler
 * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}
 */
QUnit.jsDump = (function() {
	function quote( str ) {
		return "\"" + str.toString().replace( /"/g, "\\\"" ) + "\"";
	}
	function literal( o ) {
		return o + "";
	}
	function join( pre, arr, post ) {
		var s = jsDump.separator(),
			base = jsDump.indent(),
			inner = jsDump.indent(1);
		if ( arr.join ) {
			arr = arr.join( "," + s + inner );
		}
		if ( !arr ) {
			return pre + post;
		}
		return [ pre, inner + arr, base + post ].join(s);
	}
	function array( arr, stack ) {
		var i = arr.length, ret = new Array(i);
		this.up();
		while ( i-- ) {
			ret[i] = this.parse( arr[i] , undefined , stack);
		}
		this.down();
		return join( "[", ret, "]" );
	}

	var reName = /^function (\w+)/,
		jsDump = {
			// type is used mostly internally, you can fix a (custom)type in advance
			parse: function( obj, type, stack ) {
				stack = stack || [ ];
				var inStack, res,
					parser = this.parsers[ type || this.typeOf(obj) ];

				type = typeof parser;
				inStack = inArray( obj, stack );

				if ( inStack !== -1 ) {
					return "recursion(" + (inStack - stack.length) + ")";
				}
				if ( type === "function" )  {
					stack.push( obj );
					res = parser.call( this, obj, stack );
					stack.pop();
					return res;
				}
				return ( type === "string" ) ? parser : this.parsers.error;
			},
			typeOf: function( obj ) {
				var type;
				if ( obj === null ) {
					type = "null";
				} else if ( typeof obj === "undefined" ) {
					type = "undefined";
				} else if ( QUnit.is( "regexp", obj) ) {
					type = "regexp";
				} else if ( QUnit.is( "date", obj) ) {
					type = "date";
				} else if ( QUnit.is( "function", obj) ) {
					type = "function";
				} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== "undefined" && typeof obj.nodeType === "undefined" ) {
					type = "window";
				} else if ( obj.nodeType === 9 ) {
					type = "document";
				} else if ( obj.nodeType ) {
					type = "node";
				} else if (
					// native arrays
					toString.call( obj ) === "[object Array]" ||
					// NodeList objects
					( typeof obj.length === "number" && typeof obj.item !== "undefined" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === "undefined" ) ) )
				) {
					type = "array";
				} else if ( obj.constructor === Error.prototype.constructor ) {
					type = "error";
				} else {
					type = typeof obj;
				}
				return type;
			},
			separator: function() {
				return this.multiline ?	this.HTML ? "<br />" : "\n" : this.HTML ? "&nbsp;" : " ";
			},
			// extra can be a number, shortcut for increasing-calling-decreasing
			indent: function( extra ) {
				if ( !this.multiline ) {
					return "";
				}
				var chr = this.indentChar;
				if ( this.HTML ) {
					chr = chr.replace( /\t/g, "   " ).replace( / /g, "&nbsp;" );
				}
				return new Array( this.depth + ( extra || 0 ) ).join(chr);
			},
			up: function( a ) {
				this.depth += a || 1;
			},
			down: function( a ) {
				this.depth -= a || 1;
			},
			setParser: function( name, parser ) {
				this.parsers[name] = parser;
			},
			// The next 3 are exposed so you can use them
			quote: quote,
			literal: literal,
			join: join,
			//
			depth: 1,
			// This is the list of parsers, to modify them, use jsDump.setParser
			parsers: {
				window: "[Window]",
				document: "[Document]",
				error: function(error) {
					return "Error(\"" + error.message + "\")";
				},
				unknown: "[Unknown]",
				"null": "null",
				"undefined": "undefined",
				"function": function( fn ) {
					var ret = "function",
						// functions never have name in IE
						name = "name" in fn ? fn.name : (reName.exec(fn) || [])[1];

					if ( name ) {
						ret += " " + name;
					}
					ret += "( ";

					ret = [ ret, QUnit.jsDump.parse( fn, "functionArgs" ), "){" ].join( "" );
					return join( ret, QUnit.jsDump.parse(fn,"functionCode" ), "}" );
				},
				array: array,
				nodelist: array,
				"arguments": array,
				object: function( map, stack ) {
					/*jshint forin:false */
					var ret = [ ], keys, key, val, i;
					QUnit.jsDump.up();
					keys = [];
					for ( key in map ) {
						keys.push( key );
					}
					keys.sort();
					for ( i = 0; i < keys.length; i++ ) {
						key = keys[ i ];
						val = map[ key ];
						ret.push( QUnit.jsDump.parse( key, "key" ) + ": " + QUnit.jsDump.parse( val, undefined, stack ) );
					}
					QUnit.jsDump.down();
					return join( "{", ret, "}" );
				},
				node: function( node ) {
					var len, i, val,
						open = QUnit.jsDump.HTML ? "&lt;" : "<",
						close = QUnit.jsDump.HTML ? "&gt;" : ">",
						tag = node.nodeName.toLowerCase(),
						ret = open + tag,
						attrs = node.attributes;

					if ( attrs ) {
						for ( i = 0, len = attrs.length; i < len; i++ ) {
							val = attrs[i].nodeValue;
							// IE6 includes all attributes in .attributes, even ones not explicitly set.
							// Those have values like undefined, null, 0, false, "" or "inherit".
							if ( val && val !== "inherit" ) {
								ret += " " + attrs[i].nodeName + "=" + QUnit.jsDump.parse( val, "attribute" );
							}
						}
					}
					ret += close;

					// Show content of TextNode or CDATASection
					if ( node.nodeType === 3 || node.nodeType === 4 ) {
						ret += node.nodeValue;
					}

					return ret + open + "/" + tag + close;
				},
				// function calls it internally, it's the arguments part of the function
				functionArgs: function( fn ) {
					var args,
						l = fn.length;

					if ( !l ) {
						return "";
					}

					args = new Array(l);
					while ( l-- ) {
						// 97 is 'a'
						args[l] = String.fromCharCode(97+l);
					}
					return " " + args.join( ", " ) + " ";
				},
				// object calls it internally, the key part of an item in a map
				key: quote,
				// function calls it internally, it's the content of the function
				functionCode: "[code]",
				// node calls it internally, it's an html attribute value
				attribute: quote,
				string: quote,
				date: quote,
				regexp: literal,
				number: literal,
				"boolean": literal
			},
			// if true, entities are escaped ( <, >, \t, space and \n )
			HTML: false,
			// indentation unit
			indentChar: "  ",
			// if true, items in a collection, are separated by a \n, else just a space.
			multiline: true
		};

	return jsDump;
}());

/*
 * Javascript Diff Algorithm
 *  By John Resig (http://ejohn.org/)
 *  Modified by Chu Alan "sprite"
 *
 * Released under the MIT license.
 *
 * More Info:
 *  http://ejohn.org/projects/javascript-diff-algorithm/
 *
 * Usage: QUnit.diff(expected, actual)
 *
 * QUnit.diff( "the quick brown fox jumped over", "the quick fox jumps over" ) == "the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over"
 */
QUnit.diff = (function() {
	/*jshint eqeqeq:false, eqnull:true */
	function diff( o, n ) {
		var i,
			ns = {},
			os = {};

		for ( i = 0; i < n.length; i++ ) {
			if ( !hasOwn.call( ns, n[i] ) ) {
				ns[ n[i] ] = {
					rows: [],
					o: null
				};
			}
			ns[ n[i] ].rows.push( i );
		}

		for ( i = 0; i < o.length; i++ ) {
			if ( !hasOwn.call( os, o[i] ) ) {
				os[ o[i] ] = {
					rows: [],
					n: null
				};
			}
			os[ o[i] ].rows.push( i );
		}

		for ( i in ns ) {
			if ( hasOwn.call( ns, i ) ) {
				if ( ns[i].rows.length === 1 && hasOwn.call( os, i ) && os[i].rows.length === 1 ) {
					n[ ns[i].rows[0] ] = {
						text: n[ ns[i].rows[0] ],
						row: os[i].rows[0]
					};
					o[ os[i].rows[0] ] = {
						text: o[ os[i].rows[0] ],
						row: ns[i].rows[0]
					};
				}
			}
		}

		for ( i = 0; i < n.length - 1; i++ ) {
			if ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&
						n[ i + 1 ] == o[ n[i].row + 1 ] ) {

				n[ i + 1 ] = {
					text: n[ i + 1 ],
					row: n[i].row + 1
				};
				o[ n[i].row + 1 ] = {
					text: o[ n[i].row + 1 ],
					row: i + 1
				};
			}
		}

		for ( i = n.length - 1; i > 0; i-- ) {
			if ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&
						n[ i - 1 ] == o[ n[i].row - 1 ]) {

				n[ i - 1 ] = {
					text: n[ i - 1 ],
					row: n[i].row - 1
				};
				o[ n[i].row - 1 ] = {
					text: o[ n[i].row - 1 ],
					row: i - 1
				};
			}
		}

		return {
			o: o,
			n: n
		};
	}

	return function( o, n ) {
		o = o.replace( /\s+$/, "" );
		n = n.replace( /\s+$/, "" );

		var i, pre,
			str = "",
			out = diff( o === "" ? [] : o.split(/\s+/), n === "" ? [] : n.split(/\s+/) ),
			oSpace = o.match(/\s+/g),
			nSpace = n.match(/\s+/g);

		if ( oSpace == null ) {
			oSpace = [ " " ];
		}
		else {
			oSpace.push( " " );
		}

		if ( nSpace == null ) {
			nSpace = [ " " ];
		}
		else {
			nSpace.push( " " );
		}

		if ( out.n.length === 0 ) {
			for ( i = 0; i < out.o.length; i++ ) {
				str += "<del>" + out.o[i] + oSpace[i] + "</del>";
			}
		}
		else {
			if ( out.n[0].text == null ) {
				for ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {
					str += "<del>" + out.o[n] + oSpace[n] + "</del>";
				}
			}

			for ( i = 0; i < out.n.length; i++ ) {
				if (out.n[i].text == null) {
					str += "<ins>" + out.n[i] + nSpace[i] + "</ins>";
				}
				else {
					// `pre` initialized at top of scope
					pre = "";

					for ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {
						pre += "<del>" + out.o[n] + oSpace[n] + "</del>";
					}
					str += " " + out.n[i].text + nSpace[i] + pre;
				}
			}
		}

		return str;
	};
}());

// For browser, export only select globals
if ( typeof window !== "undefined" ) {
	extend( window, QUnit.constructor.prototype );
	window.QUnit = QUnit;
}

// For CommonJS environments, export everything
if ( typeof module !== "undefined" && module.exports ) {
	module.exports = QUnit;
}


// Get a reference to the global object, like window in browsers
}( (function() {
	return this;
})() ));

define("qunit", (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
        QUnit.config.autoload = false;
        QUnit.config.autostart = false;
      };
        ret = fn.apply(global, arguments);
        return ret || global.QUnit;
    };
}(this)));

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/absolutematrix',[],function() {
  return function(QUnit, getModule) {
    var DelegateMatrix;

    AbsoluteMatrix = getModule('core/absolutematrix');
    DelegateMatrix = getModule('core/delegatematrix');
    MatrixModel = getModule('core/matrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('AbsoluteMatrix', function() {
      // constructor validation
      var a, m;

      QUnit.ok(extend.isSubclass(AbsoluteMatrix, DelegateMatrix),
          'AbsoluteMatrix is a DelegateMatrix subclass');

      m = new MatrixModel(5);
      a = new AbsoluteMatrix(m);
      [0, 1, 2, 3, 4].forEach(function(row) {
        [0, 1, 2, 3, 4].forEach(function(col) {
          m.set(row, col, 12 - (row * a.length + col));
        });
      });

      QUnit.equal(a.get(0, 0), 12, 'get() get() returns the absolute value');
      QUnit.equal(a.get(3, 2), 5, 'get() get() returns the absolute value');
      QUnit.equal(a.get(1, 0), 7, 'get() get() returns the absolute value');
      QUnit.equal(a.get(2, 2), 0, 'get() get() returns the absolute value');
      QUnit.equal(a.get(4, 4), 12, 'get() get() returns the absolute value');

      QUnit.equal(a.get(-1, 2), undefined, 'get() out of bounds (row low)');
      QUnit.equal(a.get(2, -9), undefined, 'get() out of bounds (col low)');
      QUnit.equal(a.get(5, 3), undefined, 'get() out of bounds (row high)');
      QUnit.equal(a.get(3, 7531), undefined, 'get() out of bounds (col high)');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/antisymmetricmatrixmodel',[],function() {
  return function(QUnit, getModule) {
    var MatrixModel, AntisymmetricMatrixModel, extend;

    MatrixModel = getModule('core/matrixmodel');
    AntisymmetricMatrixModel = getModule('core/antisymmetricmatrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('AntisymmetricMatrixModel', function() {
      // constructor validation
      var a;

      QUnit.ok(extend.isSubclass(AntisymmetricMatrixModel, MatrixModel),
          'AntisymmetricMatrixModel is subclass of MatrixModel');

      a = new AntisymmetricMatrixModel(5);

      QUnit.equal(a.length, 5, 'length at initialization is accepted');

      QUnit.equal(a.set(0, 4, 5), a, 'set() above the main diagonal works');
      QUnit.equal(a.get(0, 4), 5, 'get() confirms the written value');
      QUnit.equal(a.get(4, 0), -5, 'get() confirms the antisymmetric mapping');

      QUnit.equal(a.set(2, 2, 5), a, 'set() on the main diagonal works');
      QUnit.equal(a.get(2, 2), 5, 'get() confirms the main diagonal value');

      QUnit.equal(a.set(4, 3, 3), a, 'set() below main diagonal works');
      QUnit.equal(a.get(4, 3), 3, 'get() confirms the value');
      QUnit.equal(a.get(3, 4), -3, 'get() confirms the antisymmetric value');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/binningreferencelistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, BinningReferenceListModel, ListModel;

    extend = getModule('lib/extend');
    BinningReferenceListModel = getModule('core/binningreferencelistmodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('BinningReferenceListModel', function() {
      var success, binlist, bin, list, binningFunction;

      QUnit.ok(extend.isSubclass(BinningReferenceListModel, ListModel),
          'BinningReferenceListModel is subclass of ListModel');

      success = false;
      try {
        binlist = new BinningReferenceListModel();
      } catch (e) {
        success = true;
      }
      QUnit.ok(success, 'empty construction throws an error');

      success = false;
      list = new ListModel();
      try {
        binlist = new BinningReferenceListModel(list);
      } catch (e) {
        success = true;
      }
      QUnit.ok(success, 'missing binning function throws an error');

      success = false;
      binningFunction = function(num) {
        return num % 10;
      };
      try {
        binlist = new BinningReferenceListModel(undefined);
      } catch (e) {
        success = true;
      }
      QUnit.ok(success, 'missing bin list throws an error');

      binlist = new BinningReferenceListModel(list, binningFunction);
      QUnit.ok(binlist, 'proper construction');
      QUnit.equal(binlist.length, 0, 'initial length is 0');

      list.push(4);
      QUnit.equal(binlist.length, 1, "there's one bin now");
      QUnit.equal(binlist.getBinName(0), 4, 'bin has correct name');

      bin = binlist.getBin(4);
      QUnit.equal(bin.length, 1, 'bin contains an element');
      QUnit.deepEqual(bin.asArray(), [4], 'bin 4 contains the number 4');

      list.push(14);
      QUnit.equal(binlist.length, 1, "there's still only one bin");
      QUnit.deepEqual(bin.asArray(), [4, 14], 'bin 4 contains the number 14');

      list.insert(0, 24);
      QUnit.deepEqual(bin.asArray(), [24, 4, 14],
          'order of original list is preserved');

      list.push(1);
      list.push(12);
      list.push(53);

      QUnit.equal(binlist.length, 4, 'More insertions: 4 bins');

      list.pop();
      QUnit.equal(binlist.length, 3,
          'only 3 bins after the removal of a unique number');

      list = new ListModel([4, 1, 2, 53, 16, 5, 8, 9, 0, 7]);
      binlist = new BinningReferenceListModel(list, binningFunction);
      QUnit.equal(binlist.length, 10,
          'auto-initialization from existing values');
      QUnit.equal(binlist.getBin(3).get(0), 53,
          'binlist contains actual values, not indices');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/byeresult',[],function() {
  return function(QUnit, getModule) {
    var extend, ByeResult, MatchResult;

    extend = getModule('lib/extend');
    ByeResult = getModule('core/byeresult');
    MatchResult = getModule('core/matchresult');

    QUnit.test('ByeResult', function() {
      var bye, data;

      QUnit.ok(extend.isSubclass(ByeResult, MatchResult),
          'ByeResult is subclass of MatchResult');

      /*
       * construction
       */
      bye = new ByeResult(5, [13, 7], 3, 9);
      QUnit.equal(bye.getID(), 3, 'id matches the argument');
      QUnit.equal(bye.getGroup(), 9, 'group matches the argument');
      QUnit.equal(bye.length, 2, 'bye has two teams');
      QUnit.equal(bye.getTeamID(0), 5, 'first team matches the argument');
      QUnit.equal(bye.getTeamID(1), 5, 'second team matches the argument');
      QUnit.deepEqual(bye.score, [13, 7], 'score matches the argument');
      QUnit.equal(bye.isBye(), true, 'bye.isBye() is true');

      /*
       * save/restore
       */
      data = bye.save();
      QUnit.ok(data, 'save() returns');

      // Not a typo. Bye is supposed to be converted into a matchresult.
      bye = new MatchResult();
      QUnit.ok(bye.restore(data), 'restore() returns');
      QUnit.equal(bye.getID(), 3, 'id matches the argument');
      QUnit.equal(bye.getGroup(), 9, 'group matches the argument');
      QUnit.equal(bye.length, 2, 'bye has two teams');
      QUnit.equal(bye.getTeamID(0), 5, 'first team matches the argument');
      QUnit.equal(bye.getTeamID(1), 5, 'second team matches the argument');
      QUnit.deepEqual(bye.score, [13, 7], 'score matches the argument');
      QUnit.equal(bye.isBye(), true, 'bye.isBye() is true');

      /*
       * isRunningMatch()
       */
      QUnit.equal(bye.isRunningMatch(), false, 'byes are not running matches');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/combinedreferencelistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, CombinedReferenceListModel, ListModel;

    extend = getModule('lib/extend');
    CombinedReferenceListModel = getModule('core/combinedreferencelistmodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('CombinedReferenceListModel', function() {
      var list1, list2, combined, success;
      QUnit.ok(extend.isSubclass(CombinedReferenceListModel, ListModel),
          'CombinedReferenceListModel is subclass of ListModel');

      success = false;
      try {
        combined = new CombinedReferenceListModel();
      } catch (e) {
        success = true;
      }
      QUnit.ok(success, 'empty construction currently fails');

      list1 = new ListModel();

      combined = new CombinedReferenceListModel(list1);
      QUnit.ok(combined, 'construction with a single list works');
      QUnit.equal(combined.length, 0, 'initial length is 0');

      list1.push(5);
      QUnit.equal(combined.length, 1, 'an element gets added');
      QUnit.deepEqual(combined.asArray(), [5], 'correct element was added');

      list1.insert(0, 1);
      QUnit.deepEqual(combined.asArray(), [1, 5], 'insertion is mirrored');

      list1.push(8);
      QUnit.deepEqual(combined.asArray(), [1, 5, 8], 'push is mirrored');

      list1.remove(1);
      QUnit.deepEqual(combined.asArray(), [1, 8], 'remove is mirrored');

      list1.pop();
      QUnit.deepEqual(combined.asArray(), [1], 'pop is mirrored');

      list1.clear();
      QUnit.deepEqual(combined.asArray(), [], 'clear is mirrored');

      list1 = new ListModel([1, 3, 5]);
      list2 = new ListModel([2, 4, 6]);
      combined = new CombinedReferenceListModel(list1, list2);
      QUnit.deepEqual(combined.asArray(), [1, 3, 5, 2, 4, 6],
          'multiple lists are appended');

      list2.insert(1, 13);
      QUnit.deepEqual(combined.asArray(), [1, 3, 5, 2, 13, 4, 6],
          'list offsets are correct');

      list1.clear();
      QUnit.deepEqual(combined.asArray(), [2, 13, 4, 6],
          'clear() shifts all following elements towards the front');

      list1 = new ListModel([1, 3, 5]);
      combined = new CombinedReferenceListModel(list1,
          new CombinedReferenceListModel(list1),
          new CombinedReferenceListModel(list1));
      QUnit.deepEqual(combined.asArray(), [1, 3, 5, 1, 3, 5, 1, 3, 5],
          'combining the same list three times');

      list1.push(7);
      QUnit.deepEqual(combined.asArray(), [1, 3, 5, 7, 1, 3, 5, 7, 1, 3, 5, 7],
          'pushing to the triply-combined list');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/correctionmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, MatchModel, MatchResult, CorrectionModel, Model;

    extend = getModule('lib/extend');
    MatchModel = getModule('core/matchmodel');
    MatchResult = getModule('core/matchresult');
    CorrectionModel = getModule('core/correctionmodel');
    Model = getModule('core/model');

    QUnit.test('CorrectionModel', function() {
      var match, result, result2, correction, data, success;

      QUnit.ok(extend.isSubclass(CorrectionModel, Model),
          'CorrectionModel is subclass of Model');

      match = new MatchModel([1, 4], 0, 1);
      result = new MatchResult(match, [13, 7]);
      result2 = new MatchResult(result, [7, 13]);
      correction = new CorrectionModel(result, result2);

      QUnit.ok(correction, 'construction works');
      QUnit.equal(correction.before, result, "'before' stored as reference");
      QUnit.equal(correction.after, result2, "'after' stored as reference");

      /*
       * erronuous construction -> throw
       */
      try {
        correction = new CorrectionModel('asd', {
          pi: 3
        });
        success = false;
      } catch (e) {
        success = true;
      }

      QUnit.ok(success, 'the constructor throws on invalid values');

      /*
       * default construction
       */

      correction = new CorrectionModel();
      QUnit.ok(correction, 'default construction works');
      QUnit.deepEqual(correction.before, new MatchResult(),
          'default construction of pre-correction result');
      QUnit.deepEqual(correction.after, new MatchResult(),
          'default construction of post-correction result');

      /*
       * save/restore
       */
      correction = new CorrectionModel(result, result2);
      data = correction.save();
      QUnit.ok(data, 'save() returns');

      correction = new CorrectionModel();
      QUnit.ok(correction.restore(data), 'restore() returns');
      QUnit.deepEqual(correction.before, result,
          'restore() restores the pre-correction result');
      QUnit.deepEqual(correction.after, result2,
          'restore() restores the post-correction result');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/correctionreferencemodel',[],function() {
  return function(QUnit, getModule) {
    var extend, CorrectionReferenceModel, CorrectionModel, MatchResult, MatchModel, ListModel;

    extend = getModule('lib/extend');
    CorrectionReferenceModel = getModule('core/correctionreferencemodel');
    CorrectionModel = getModule('core/correctionmodel');
    MatchModel = getModule('core/matchmodel');
    MatchResult = getModule('core/matchresult');
    ListModel = getModule('core/listmodel');

    QUnit.test('CorrectionReferenceModel', function() {
      var result, result2, correction, reference, teams;
      QUnit.ok(extend.isSubclass(CorrectionReferenceModel, CorrectionModel),
          'CorrectionReferenceModel is subclass of CorrectionModel');

      teams = new ListModel();
      teams.push(5);
      teams.push(3);
      teams.push(6);
      teams.push(1);
      teams.push(13);
      teams.push(0);

      result = new MatchResult(new MatchModel([5, 3], 1, 2), [13, 7]);
      result2 = new MatchResult(new MatchModel([2, 4], 2, 1), [8, 9]);

      correction = new CorrectionModel(result, result2);

      reference = new CorrectionReferenceModel(correction, teams);
      QUnit.equal(reference.before.result, result,
          'before result reference is set');
      QUnit.equal(reference.after.result, result2,
          'after result reference is set');

      QUnit.deepEqual(reference.before.teams, [0, 1],
          'before teams correctly referenced');
      QUnit.deepEqual(reference.after.teams, [6, 13],
          'after teams correctly referenced');
      QUnit.deepEqual(reference.before.score, result.score,
          'before score is correct');
      QUnit.deepEqual(reference.after.score, result2.score,
          'after score is correct');

      QUnit.equal(reference.before.getID(), 1, 'before id matches');
      QUnit.equal(reference.after.getID(), 2, 'after id matches');
      QUnit.equal(reference.before.getGroup(), 2, 'before group matches');
      QUnit.equal(reference.after.getGroup(), 1, 'after group matches');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/delegatematrix',[],function() {
  return function(QUnit, getModule) {
    var DelegateMatrix;

    DelegateMatrix = getModule('core/delegatematrix');
    MatrixModel = getModule('core/matrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('DelegateMatrix', function() {
      // constructor validation
      var a, m, state;

      QUnit.ok(extend.isSubclass(DelegateMatrix, MatrixModel),
          'DelegateMatrix is a MatrixModel subclass');

      state = true;
      try {
        a = new DelegateMatrix();
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'empty initialization fails');

      state = true;
      try {
        a = new DelegateMatrix(5);
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'initialization with size fails');

      m = new MatrixModel(5);
      a = new DelegateMatrix(m);
      QUnit.ok(a, 'proper initialization');

      state = true;
      try {
        a.set(1, 2, 3);
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'set() throws');

      state = true;
      try {
        a.remove(1);
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'remove() throws');

      state = true;
      try {
        a.resize(1);
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'resize() throws');

      state = true;
      try {
        a.fill(1);
      } catch (e) {
        state = false;
      }
      QUnit.equal(state, false, 'fill() throws');

      [0, 1, 2, 3, 4].forEach(function(row) {
        [0, 1, 2, 3, 4].forEach(function(col) {
          m.set(row, col, 12 - (row * a.length + col));
        });
      });

      QUnit.equal(a.get(0, 0), 12, 'get() delegates to the linked matrix');
      QUnit.equal(a.get(3, 2), -5, 'get() delegates to the linked matrix');
      QUnit.equal(a.get(1, 0), 7, 'get() delegates to the linked matrix');
      QUnit.equal(a.get(4, 4), -12, 'get() delegates to the linked matrix');

      QUnit.equal(a.get(-1, 2), undefined, 'get() out of bounds (row low)');
      QUnit.equal(a.get(2, -9), undefined, 'get() out of bounds (col low)');
      QUnit.equal(a.get(5, 3), undefined, 'get() out of bounds (row high)');
      QUnit.equal(a.get(3, 7531), undefined, 'get() out of bounds (col high)');
    });
  };
});

/**
 * Event Emitter tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/emitter',[],function() {
  return function(QUnit, getModule) {
    var Emitter;

    Emitter = getModule('core/emitter');

    QUnit.test('Emitter', function() {
      var emitter, listener, listener2, eventcounter, resetcounter, retval;

      eventcounter = resetcounter = 0;

      emitter = undefined;
      listener = undefined;

      listener = {
        /**
         * test function
         */
        onundefined: function() {
          this.onreset();
        },
        /**
         * test function
         */
        onreset: function() {
          eventcounter = 0;
          resetcounter += 1;
        },
        /**
         * test function
         */
        onevent: function(_emitter, event) {
          eventcounter += 1;
          QUnit.equal(this, listener, 'onevent(): this equals listener');
          QUnit.equal(_emitter, emitter,
              'onevent(): first argument equals emitter ');
          QUnit.equal(event, 'event',
              'onevent(): second argument equals event string');
        },
        emitters: []
      };

      listener2 = {
        /**
         * test function
         */
        onevent: function() {
          eventcounter += 1;
        },
        emitters: []
      };

      emitter = new Emitter();
      emitter.EVENTS = {
        'asd': true,
        'event': true,
        'reset': true
      };

      retval = emitter.emit('asd');

      QUnit.equal(retval, false,
          'Emitter: unreceived event returns false on emit()');

      emitter.registerListener(listener).registerListener(listener2);
      QUnit.equal(eventcounter + resetcounter, 0,
          'counters are at a zero state after listener registration');

      retval = emitter.emit('event');
      QUnit.equal(eventcounter, 2, "both listeners received 'event'");
      QUnit.equal(retval, true,
          'Emitter: received event returns true on emit()');

      emitter.registerListener(listener);
      retval = emitter.emit('event');
      QUnit.equal(eventcounter, 4, 'Cannot register an event listener twice');

      retval = emitter.emit('reset');
      QUnit.equal(eventcounter, 0, "counter was reset during 'reset' event");
      QUnit.equal(resetcounter, 1, 'reset was processed');

      retval = emitter.emit('event');
      retval = emitter.emit();
      QUnit.equal(resetcounter, 1,
          'default event (undefined) was not processed');
      QUnit.equal(eventcounter, 2,
          'onundefined callback function was not processed');

      emitter.emit('thisEventIsInvalid');
      QUnit.equal(eventcounter, 2, 'unspecified events are not processed');

      emitter.unregisterListener(listener);
      retval = emitter.emit('event');
      QUnit.equal(eventcounter, 3,
          'unregistered listeners do not receive events');

      retval = emitter.listeners.indexOf(listener);
      QUnit.equal(retval, -1, 'listeners are removed from emitter.listeners');
      retval = listener.emitters.indexOf(emitter);
      QUnit.equal(retval, -1, 'emitters are removed from listener.emitters');

      /*
       * emit+unregister test
       *
       * When unregistering a listener from a currently emitting emitter, the
       * listeners array is manipulated, possibly causing listeners to be
       * skipped. This is an error, which should be fixed
       */

      emitter = new Emitter();
      emitter.EVENTS = {
        'evt': true
      };
      listener2 = {
        success: false,
        onevt: function() {
          this.success = true;
        },
        emitters: []
      };
      listener = {
        onevt: function() {
          emitter.unregisterListener(this);
        },
        emitters: []
      };
      emitter.registerListener(listener);
      emitter.registerListener(listener2);
      emitter.emit('evt');
      QUnit.equal(listener2.success, true,
          'unregister during emit should not cause listeners to be skipped');

      /*
       * Mixin tests: when instantiating the emitter multiple times, the
       * 'listeners' array should not be overwritten!
       */

      emitter = new Emitter();
      emitter.EVENTS = {
        'evt': true
      };
      listener2.success = false;
      emitter.registerListener(listener2);
      Emitter.call(emitter); // mix-in
      emitter.emit('evt');
      QUnit.equal(listener2.success, true,
          'Mixin-initialization of an emitter preserves the listeners');

      /*
       * testing memory leak due to invalid forEach call
       */
      emitter = new Emitter();
      listener = {
        emitters: []
      };
      listener2 = {
        emitters: []
      };
      emitter.registerListener(listener);
      emitter.registerListener(listener2);
      emitter.destroy();

      QUnit.equal(listener.emitters.length, 0,
          'memleak: first listener was unregistered');
      QUnit.equal(listener2.emitters.length, 0,
          'memleak: second listener was unregistered');
    });
  };
});

/**
 * Unit tests for IndexedListModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/indexedlistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, IndexedListModel, IndexedModel, ListModel;

    extend = getModule('lib/extend');
    IndexedListModel = getModule('core/indexedlistmodel');
    ListModel = getModule('core/listmodel');
    IndexedModel = getModule('core/indexedmodel');

    QUnit.test('IndexedListModel', function() {
      var list;

      QUnit.ok(extend.isSubclass(IndexedListModel, ListModel),
          'IndexedListModel is subclass of ListModel');

      list = new IndexedListModel();

      list.push(new IndexedModel());
      list.push(new IndexedModel());
      list.push(new IndexedModel());
      QUnit.equal(list.get(0).getID(), 0,
          'push into empty indexed list sets the proper id');
      QUnit.equal(list.get(1).getID(), 1,
          'push into empty indexed list sets the proper id');
      QUnit.equal(list.get(2).getID(), 2,
          'push into empty indexed list sets the proper id');

      list.pop();
      QUnit.equal(list.get(0).getID(), 0, 'pop does not affect any indices');
      QUnit.equal(list.get(1).getID(), 1, 'pop does not affect any indices');

      list.push(new IndexedModel());
      list.push(new IndexedModel());

      list.remove(0);
      QUnit.equal(list.get(0).getID(), 0,
          'remove(0) adjusts all following indices');
      QUnit.equal(list.get(1).getID(), 1,
          'remove(0) adjusts all following indices');
      QUnit.equal(list.get(2).getID(), 2,
          'remove(0) adjusts all following indices');

      list.remove(1);
      QUnit.equal(list.get(0).getID(), 0,
          'remove(1) adjusts all following indices');
      QUnit.equal(list.get(1).getID(), 1,
          'remove(2) adjusts all following indices');

      list.clear();
      QUnit.equal(list.length, 0, 'clearing a non-empty list does not throw');

      list = new IndexedListModel();
      list.clear();
      QUnit.equal(list.length, 0, 'clearing an empty list does not throw');
    });
  };
});

/**
 * Unit tests for IndexedModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/indexedmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, IndexedModel, Model;

    extend = getModule('lib/extend');
    Model = getModule('core/model');
    IndexedModel = getModule('core/indexedmodel');

    QUnit.test('IndexedModel', function() {
      var model, listener, data;

      QUnit.ok(extend.isSubclass(IndexedModel, Model),
          'IndexedModel is subclass of Model');

      listener = {
        updatecount: 0,
        /**
         * Callback listener
         */
        onupdate: function() {
          listener.updatecount += 1;
        },
        /**
         * counter reset
         */
        reset: function() {
          listener.updatecount = 0;
        },
        emitters: []
      };

      model = new IndexedModel();
      QUnit.equal(model.getID(), -1, 'empty initialization sets id to -1');

      model.setID(0);
      QUnit.equal(model.getID(), 0,
          'setID(0) actually sets the id to 0, not -1');

      model = new IndexedModel(5);

      QUnit.equal(model.getID(), 5, 'proper initialization sets id');

      model.registerListener(listener);

      model.setID(8);
      QUnit.equal(model.getID(), 8, 'setID sets the id');
      QUnit.equal(listener.updatecount, 1, 'setID emits update');

      listener.reset();
      model.setID(8);
      QUnit.equal(listener.updatecount, 0,
          'setID does not emit update if the ids are identical');

      model.setID();
      QUnit.equal(model.getID(), -1, 'empty setID sets the id to -1');

      model.setID(5);
      data = model.save();
      QUnit.ok(data, 'Model.save() returns something');
      model = new IndexedModel(3);
      QUnit.equal(model.restore(data), true, 'restore() works');
      QUnit.equal(model.getID(), 5, 'save() and restore() work');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/kotournamentmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, KOTournamentModel, TournamentModel;

    extend = getModule('lib/extend');
    KOTournamentModel = getModule('core/kotournamentmodel');
    TournamentModel = getModule('core/tournamentmodel');

    QUnit.test('KOTournamentModel', function() {
      var ids, result, ref, tournament;

      QUnit.ok(extend.isSubclass(KOTournamentModel, TournamentModel),
          'KOTournamentModel is subclass of TournamentModel');

      ids = [];
      while (ids.length <= 33) {
        ids.push(ids.length);
      }

      /*
       * Tree traversal functions
       */
      result = ids.map(function(id) {
        return KOTournamentModel.ceilPowerOfTwo(id);
      });
      ref = [1, 1, 2, 4, 4, 8, 8, 8, 8, 16, 16, 16, 16, 16, 16, 16, 16, 32, 32,
          32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 64];
      QUnit.deepEqual(result, ref, 'ceilPowerOfTwo()');

      result = ids.map(function(id) {
        return KOTournamentModel.nextRoundMatchID(id);
      });
      ref = [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16];
      QUnit.deepEqual(result, ref, 'nextRoundMatchID()');

      result = ids.map(function(id) {
        return KOTournamentModel.isSecondInNextRound(id);
      });
      ref = [false, false, false, true, false, true, false, true, false, true,
          false, true, false, true, false, true, false, true, false, true,
          false, true, false, true, false, true, false, true, false, true,
          false, true, false, true];
      QUnit.deepEqual(result, ref, 'isSecondInNextRound()');

      result = ids.map(function(id) {
        return KOTournamentModel.complementaryMatchID(id);
      });
      ref = [1, 0, 3, 2, 5, 4, 7, 6, 9, 8, 11, 10, 13, 12, 15, 14, 17, 16, 19,
          18, 21, 20, 23, 22, 25, 24, 27, 26, 29, 28, 31, 30, 33, 32];
      QUnit.deepEqual(result, ref, 'complementaryMatchID()');

      result = ids.slice(0, 16).map(function(id) {
        return KOTournamentModel.firstMatchIDOfRound(id);
      });
      ref = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192,
          16384, 32768];
      QUnit.deepEqual(result, ref, 'firstMatchIDOfRound()');

      result = ids.slice(0, 16).map(function(id) {
        return KOTournamentModel.numMatchesInRound(id);
      });
      ref = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192,
          16384, 32768];
      QUnit.deepEqual(result, ref, 'numMatchesInRound()');

      result = ids.map(function(id) {
        return KOTournamentModel.roundOfMatchID(id);
      });
      ref = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4,
          4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5];
      QUnit.deepEqual(result, ref, 'roundOfMatchID()');

      result = ids.map(function(id) {
        return KOTournamentModel.loserGroupID(0, id);
      });
      ref = [0, 0, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 8, 8, 8, 8, 8, 8,
          8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 16, 16];
      QUnit.deepEqual(result, ref, 'loserGroupID(0)');

      result = ids.map(function(id) {
        return KOTournamentModel.loserGroupID(8, id);
      });
      ref = ref.map(function(a) {
        return a + 8;
      });
      QUnit.deepEqual(result, ref, 'loserGroupID(8)');

      result = ids.map(function(id) {
        return KOTournamentModel.initialRoundForTeams(id);
      });
      ref = [-1, -1, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4,
          4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5];
      QUnit.deepEqual(result, ref, 'loserGroupID()');

      result = ids.map(function(id) {
        return KOTournamentModel.roundsInGroup(id);
      });
      ref = [30, 1, 2, 1, 3, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 5, 1, 2, 1, 3, 1,
          2, 1, 4, 1, 2, 1, 3, 1, 2, 1, 6, 1];
      QUnit.deepEqual(result, ref, 'roundsInGroup()');

      result = ids.map(function(id) {
        return KOTournamentModel.parentGroup(id);
      });
      ref = [0, 0, 0, 2, 0, 4, 4, 6, 0, 8, 8, 10, 8, 12, 12, 14, 0, 16, 16, 18,
          16, 20, 20, 22, 16, 24, 24, 26, 24, 28, 28, 30, 0, 32];
      QUnit.deepEqual(result, ref, 'parentGroup()');

      /*
       * initial matches
       */
      tournament = new KOTournamentModel();
      tournament.addTeam(0);
      tournament.addTeam(1);
      tournament.addTeam(2);

      QUnit.ok(tournament.run(), 'run() with 3 teams succeeds');
      QUnit.equal(tournament.getProperty('komode'), 'matched',
          'initial ko mode is "matched"');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/lengthmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, LengthModel, ValueModel, ListModel;

    extend = getModule('lib/extend');
    ListModel = getModule('core/listmodel');
    LengthModel = getModule('core/lengthmodel');
    ValueModel = getModule('core/valuemodel');

    QUnit.test('LengthModel', function() {
      var length, list, success;
      QUnit.ok(extend.isSubclass(LengthModel, ValueModel),
          'LengthModel is subclass of ValueModel');

      success = false;
      try {
        new LengthModel();
      } catch (e) {
        success = true;
      }

      QUnit.ok(success, 'empty construction fails');

      list = new ListModel([1, 2, 3]);

      length = new LengthModel(list);

      QUnit.equal(length.get(), 3,
          'constructor reads the initial length of the list');

      list.pop();
      QUnit.equal(length.get(), 2, 'list.pop() is mirrored');

      list.push('asd');
      QUnit.equal(length.get(), 3, 'list.push() is mirrored');

      list.clear();
      QUnit.equal(length.get(), 0, 'list.clear() is mirrored');

    });
  };
});

/**
 * tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/listener',[],function() {
  return function(QUnit, getModule) {
    var Emitter, Listener;

    Emitter = getModule('core/emitter');
    Listener = getModule('core/listener');

    QUnit.test('Listener', function() {
      var emitter, emitter2, listener, ref;

      emitter = new Emitter();
      emitter2 = new Emitter();
      emitter2.numListeners = function() {
        return this.listeners.length;
      };

      listener = new Listener(emitter);
      listener.updatecount = 0;
      listener.onupdate = function() {
        this.updatecount += 1;
      };
      listener.numEmitters = function() {
        return this.emitters.length;
      };

      QUnit.equal(listener.numEmitters(), 1,
          'listener initializes with an emitter');

      emitter.emit('update');
      QUnit.equal(listener.updatecount, 1,
          'update event received from emitter1');

      emitter2.registerListener(listener);
      QUnit.equal(listener.numEmitters(), 2, 'registerListener adds emitter2');

      emitter2.emit('update');
      QUnit.equal(listener.updatecount, 2, 'receiving events from emitter2');

      emitter.unregisterListener(listener);
      QUnit.equal(listener.numEmitters(), 1,
          'emitter.destroy() unregisters the listener');

      emitter.registerListener(listener);
      QUnit.equal(listener.numEmitters(), 2, 're-registering the emitter');

      emitter.destroy();
      QUnit.equal(listener.numEmitters(), 1,
          'emitter.destroy() unregisters the listener');

      listener.destroy();
      QUnit.equal(listener.numEmitters(), 0,
          'listener.destroy() unregisters all emitters');
      QUnit.equal(emitter2.numListeners(), 0,
          'listener.destroy() unregisters the listener from all emitters');

      /*
       * Listener.bind
       */
      emitter = new Emitter();
      ref = 0;
      Listener.bind(emitter, 'update', function() {
        ref += 1;
      });

      emitter.emit('update');
      emitter.emit('reset');
      QUnit.ok(emitter, 'bind-created listener works');

      emitter.destroy();
      emitter = new Emitter();
      ref = 0;
      Listener.bind(emitter, 'update,reset', function(e, evt, data) {
        ref += (data || 1);
      });

      emitter.emit('reset');
      emitter.emit('update', 123);

      QUnit.equal(ref, 124, 'bind-listening for multiple event types '
          + 'with data object');

      emitter.destroy();
      emitter = new Emitter();

      ref = undefined;
      Listener.bind(emitter, 'reset', function() {
        ref = this;
      }, emitter);

      emitter.emit('reset');

      QUnit.equal(ref, emitter, 'bind(): thisArg works');

      /*
       * testing memory leak due to invalid forEach call
       */
      emitter = new Emitter();
      emitter2 = new Emitter();
      listener = new Listener(emitter);
      emitter2.registerListener(listener);
      listener.destroy();

      QUnit.equal(emitter.listeners.length, 0,
          'memleak: first emitter was unregistered');
      QUnit.equal(emitter2.listeners.length, 0,
          'memleak: second emitter was unregistered');

      /**
       * double-listening test
       */
      emitter = new Emitter();
      listener = new Listener(emitter);
      emitter.registerListener(listener);
      QUnit.equal(listener.emitters.length, 1,
          'double registration of a listener is prevented');

      listener.resetcount = 0;
      listener.onreset = function() {
        this.resetcount += 1;
      };
      emitter.emit('reset');
      QUnit.equal(listener.resetcount, 1,
          'double invocation of a listener is prevented');
    });
  };
});

/**
 * Unit tests for ListModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/listmodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, DummyModel, extend;

    ListModel = getModule('core/listmodel');
    Model = getModule('core/model');
    extend = getModule('lib/extend');

    /*
     * dummy Model, which can be saved/restored for testing
     */
    DummyModel = function(optional) {
      if (optional) {
        this.data = 'asd' + optional;
      }

      this.save = function() {
        return {
          d: this.data.replace(/^asd/, '')
        };
      };
      this.restore = function(data) {
        this.data = 'asd' + data.d;
        return true;
      };
    };
    extend(DummyModel, Model);

    function DummyModelFactory(data) {
      if (data.d) {
        return new DummyModel();
      }
      return undefined;
    }

    QUnit.test('ListModel', function() {
      var list, obj, i, ret, res, listener, data;

      listener = {
        reset: function() {
          listener.length = 0;
          listener.insertions = 0;
          listener.removals = 0;
        },
        onresize: function(emitter) {
          listener.length = emitter.length;
        },
        oninsert: function() {
          listener.insertions += 1;
        },
        onremove: function() {
          listener.removals += 1;
        },
        emitters: []
      };
      listener.reset();

      list = new ListModel();
      list.registerListener(listener);

      QUnit.equal(list.length, 0, 'initial size is 0');
      QUnit.deepEqual(list.asArray(), [], 'asArray returns empty array');

      list.push(2);
      QUnit.deepEqual(list.asArray(), [2], 'first push');
      QUnit.equal(list.length, 1, 'size after first push is 1');
      QUnit.equal(listener.length, 1, 'resize event fired on push');
      QUnit.equal(listener.insertions, 1, 'insert event fired on push');

      list.push(4);
      QUnit.deepEqual(list.asArray(), [2, 4], 'second push');
      QUnit.equal(list.length, 2, 'size after second push is 2');
      QUnit.equal(listener.length, 2, 'resize event fired on push');

      list.insert(0, 1);
      QUnit.deepEqual(list.asArray(), [1, 2, 4], 'insert at front');
      QUnit.equal(list.length, 3, 'size after insert is 3');
      QUnit.equal(listener.length, 3, 'resize event fired on insert');
      QUnit.equal(listener.insertions, 3, 'insert event fired on insert');

      list.insert(3, 5);
      QUnit.deepEqual(list.asArray(), [1, 2, 4, 5], 'insert at end');

      list.insert(2, 3);
      QUnit.deepEqual(list.asArray(), [1, 2, 3, 4, 5], 'insert inbetween');

      QUnit.equal(list.length, 5, 'length after all inserts');
      QUnit.equal(listener.insertions, 5,
          'number of fired insert events matches number of insertions');

      QUnit.equal(list.get(0), 1, 'get 1');
      QUnit.equal(list.get(1), 2, 'get 2');
      QUnit.equal(list.get(2), 3, 'get 3');
      QUnit.equal(list.get(3), 4, 'get 4');
      QUnit.equal(list.get(4), 5, 'get 5');

      QUnit.equal(list.get(-1), undefined, 'get out of bounds (index -1)');
      QUnit.equal(list.get(5), undefined,
          'get slightly out of bounds (index 5)');
      QUnit.equal(list.get(1234567890), undefined,
          'get wildly out of bounds (index 1234567890)');

      QUnit.equal(list.indexOf(1), 0, 'indexOf: first element');
      QUnit.equal(list.indexOf(5), 4, 'indexOf: last element');
      QUnit.equal(list.indexOf('unavailable'), -1,
          'indexOf: unavailable element');

      QUnit.equal(list.includes(1), true, 'includes: first element');
      QUnit.equal(list.includes(3), true, 'includes: middle element');
      QUnit.equal(list.includes(5), true, 'includes: last element');
      QUnit.equal(list.includes(0), false, 'includes: unavailable');
      QUnit.equal(list.includes(-1), false, 'includes: another unavailable');

      QUnit.equal(list.remove(0), 1, 'remove returns the removed object');
      QUnit.deepEqual(list.asArray(), [2, 3, 4, 5], 'remove at front');
      QUnit.equal(list.length, 4, 'length after remove');
      QUnit.equal(listener.length, 4, 'resize event fired on remove');
      QUnit.equal(listener.removals, 1, 'remove event fired on remove');

      QUnit.equal(list.pop(3), 5, 'pop returns the removed object');
      QUnit.deepEqual(list.asArray(), [2, 3, 4], 'pop (remove at back)');
      QUnit.equal(list.length, 3, 'length after remove');
      QUnit.equal(listener.removals, 2, 'remove event fired on pop');

      QUnit.equal(list.remove(1), 3, 'remove returns the removed object');
      QUnit.deepEqual(list.asArray(), [2, 4], 'remove inbetween');
      QUnit.equal(list.length, 2, 'length after remove');

      QUnit.equal(list.remove(123), undefined,
          'remove out of bounds does nothing');
      QUnit.deepEqual(list.asArray(), [2, 4], 'remove out of bounds');
      QUnit.equal(list.length, 2, 'length after remove out of bounds');

      list.set(1, 123);
      QUnit.equal(list.length, 2, 'set does not change length');
      QUnit.deepEqual(list.asArray(), [2, 123],
          'list.set actually sets the value');
      QUnit.equal(listener.length, 2,
          'resize event balanced on set() (may have been fired twice)');

      listener.reset();

      QUnit.equal(list.set(123, 321), undefined,
          "set out of bounds doesn't to anything");
      QUnit.deepEqual(list.asArray(), [2, 123],
          "set out of bounds really doesn't to anything");
      QUnit.equal(listener.insertions, 0,
          "set out of bounds doesn't fire insert event");
      QUnit.equal(listener.removals, 0,
          "set out of bounds doesn't fire remove event");

      list.clear();
      QUnit.equal(list.length, 0, 'list length is 0 after clear');
      QUnit.equal(listener.length, 0, 'resize event fired on clear)');
      QUnit.equal(listener.removals, 2, 'clear fires remove events');

      list.push(4);
      list.push(3);
      list.push(2);
      list.push(1);

      i = 0;

      ret = list.map(function(num, index, thelist) {
        QUnit.equal(this, 5, 'map(): this === thisArg, ' + index);
        QUnit.equal(index, i, 'map(): iterating in ascending order, ' + index);
        QUnit.equal(num, list.length - index,
            'first argument is the list content' + index);
        QUnit.equal(thelist, list,
            'map(): third function argument is the list, ' + index);
        i += 1;
        return num * num;
      }, 5);

      res = [16, 9, 4, 1];
      QUnit.deepEqual(ret, res, 'map(): return value is preserved');

      list.clear();

      QUnit.equal(list.length, 0, 'cleared size is 0');
      QUnit.deepEqual(list.asArray(), [],
          'asArray returns empty array after clear');

      obj = {
        tmp: true,
        tmpLong: 'very much so'
      };

      list.push(obj);

      QUnit.equal(list.get(0), obj,
          'objects are directly referenced, not copied');
      QUnit.equal(list.pop(), obj, 'pop returns the popped object directly');

      QUnit.equal(list.length, 0, 'popped size is 0');
      QUnit.deepEqual(list.asArray(), [],
          'asArray returns empty array after pop');

      list = new ListModel();
      list.push(3);
      list.push(2);
      list.push(3);
      list.push(4);
      list.push(3);
      list.push('3');

      QUnit.equal(list.erase(3), 3, 'erase() returns number of removals');
      QUnit.equal(list.includes(3), false, 'erase removes all instances');
      QUnit.equal(list.indexOf(3), -1, 'erased element has no index anymore');
      QUnit.equal(list.length, 3, 'erase resizes the list');

      QUnit.equal(list.erase('notfound'), 0, 'erase() returns 0 if not found');

      list = new ListModel();
      list.makeReadonly();
      QUnit.equal(list.insert, undefined, 'makereadonly: insert() disabled');
      QUnit.equal(list.remove, undefined, 'makereadonly: remove() disabled');
      QUnit.equal(list.push, undefined, 'makereadonly: push() disabled');
      QUnit.equal(list.pop, undefined, 'makereadonly: pop() disabled');
      QUnit.equal(list.clear, undefined, 'makereadonly: clear() disabled');
      QUnit.equal(list.erase, undefined, 'makereadonly: erase() disabled');

      list = new ListModel();
      list.push(5);
      list.push(3);
      list.push(4);
      list.push(2);
      list.push(3);
      list.push(1);
      data = list.save();
      QUnit.ok(data, 'save() returns');
      QUnit.deepEqual(data, [5, 3, 4, 2, 3, 1],
          'save() uses a list representation for raw types');
      list = new ListModel();
      QUnit.ok(list.restore(data), 'restore() returns');
      QUnit.deepEqual(list.asArray(), [5, 3, 4, 2, 3, 1],
          'restore() restores the whole list');

      list.clear();
      list.push('Tuvero');
      list.push('is');
      list.push('awesome');
      data = list.save();
      QUnit.deepEqual(data, ['Tuvero', 'is', 'awesome'],
          'saved data object is just an array of strings');

      list.clear();
      list.push(new DummyModel(5));
      list.push(new DummyModel(3));
      list.push(new DummyModel(4));
      list.push(new DummyModel(2));
      list.push(new DummyModel(3));
      list.push(new DummyModel(1));
      data = list.save();
      QUnit.ok(data, 'save() calls save() recursively');
      QUnit.ok(data[0].d, 'save() really calls save() recursively');
      QUnit.ok(!data[0].save, 'save() really really calls save() recursively');

      list = new ListModel();
      QUnit.ok(list.restore(data, DummyModel),
          'restore() with Model Constructor returns');
      QUnit.equal(list.length, data.length, 'restore() restores the length');
      QUnit.equal(list.get(0).data, 'asd5', 'restore() constructs the object');
      QUnit.equal(list.get(1).data, 'asd3', 'restore() constructs the object');
      QUnit.equal(list.get(2).data, 'asd4', 'restore() constructs the object');
      QUnit.equal(list.get(3).data, 'asd2', 'restore() constructs the object');
      QUnit.equal(list.get(4).data, 'asd3', 'restore() constructs the object');
      QUnit.equal(list.get(5).data, 'asd1', 'restore() constructs the object');

      QUnit.ok(list.restore(data, DummyModel),
          'restore() with Model Factory returns');
      QUnit.equal(list.length, data.length, 'restore() restores the length');
      QUnit.equal(list.get(0).data, 'asd5', 'restore() constructs the object');
      QUnit.equal(list.get(1).data, 'asd3', 'restore() constructs the object');
      QUnit.equal(list.get(2).data, 'asd4', 'restore() constructs the object');
      QUnit.equal(list.get(3).data, 'asd2', 'restore() constructs the object');
      QUnit.equal(list.get(4).data, 'asd3', 'restore() constructs the object');
      QUnit.equal(list.get(5).data, 'asd1', 'restore() constructs the object');
    });
  };
});

/**
 * Unit tests for ListModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/listupdatelistener',[],function() {
  return function(QUnit, getModule) {
    var ListModel, ListUpdateListener;

    ListModel = getModule('core/listmodel');
    ListUpdateListener = getModule('core/listupdatelistener');

    QUnit.test('ListUpdateListener', function() {
      var list, listener, ref;

      list = new ListModel();
      list.push(1);

      /*
       * Test new-constructed instances
       */
      ref = 0;
      listener = new ListUpdateListener(list, function(data) {
        if (ref === 0) {
          QUnit.equal(this, list, 'callback "this" is the list');
        }
        ref += 1;
      });

      QUnit.ok(listener, 'construction via "new" works');
      QUnit.equal(ref, 0, 'callback is not called on construction');

      list.push(2);
      QUnit.equal(ref, 1, 'callback is called on push');
      list.insert(0, 3);
      QUnit.equal(ref, 2, 'callback is called on insert');
      list.pop();
      QUnit.equal(ref, 3, 'callback is called on pop');
      list.remove(0);
      QUnit.equal(ref, 4, 'callback is called on remove');
      list.erase(1);
      QUnit.equal(ref, 5, 'callback is called on erase');

      list.clear();
      QUnit.equal(ref, 6, 'callback is called on clear');

      listener.destroy();

      list.push(5);
      QUnit.equal(ref, 6, 'listener is unregistered on destroy');

      /*
       * Test bind()-constructed instances
       */
      ref = 0;
      ListUpdateListener.bind(list, function() {
        if (ref === 0) {
          QUnit.equal(this, list, 'callback "this" is the list');
        }
        ref += 1;
      });

      QUnit.ok(listener, 'construction via "bind()" works');
      QUnit.equal(ref, 0, 'callback is not called on bind-construction');

      list.push(2);
      QUnit.equal(ref, 1, 'callback is called on push');
      list.insert(0, 3);
      QUnit.equal(ref, 2, 'callback is called on insert');
      list.pop();
      QUnit.equal(ref, 3, 'callback is called on pop');
      list.remove(0);
      QUnit.equal(ref, 4, 'callback is called on remove');
      list.erase(5);
      QUnit.equal(ref, 5, 'callback is called on erase');

      list.clear();
      QUnit.equal(ref, 6, 'callback is called on clear');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/maplistmodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, MatchReferenceListModel, Listener;

    Listener = getModule('core/listener');
    ListModel = getModule('core/listmodel');
    MapListModel = getModule('core/maplistmodel');

    QUnit.test('MapListModel', function() {
      var teams, list, refs, listener, matchref;

      teams = new ListModel();
      teams.push(5);
      teams.push(4);
      teams.push(3);
      teams.push(2);
      teams.push(1);
      teams.push(0);

      indices = new ListModel();
      indices.push(1);
      indices.push(3);
      indices.push(5);

      refs = new MapListModel(indices, teams);

      QUnit.equal(refs.length, indices.length,
          'number of teams match after initialization');
      QUnit.deepEqual(refs.asArray(), [4, 2, 0], 'ids get translated');

      listener = new Listener(refs);
      listener = new Listener(refs);
      listener.success = false;
      listener.callcount = 0;
      listener.oninsert = function() {
        this.success = true;
        this.callcount += 1;
      };

      indices.push(2);

      QUnit.ok(listener.success, '"insert" event is re-emitted');
      QUnit.equal(listener.callcount, 1, '"insert" is emitted exactly once');
      QUnit.equal(refs.length, 4, 'new team gets added to the indices list');
      listener.destroy();

      QUnit.deepEqual(refs.asArray(), [4, 2, 0, 3], 'ids get translated');

      listener = new Listener(refs);
      listener.success = false;
      listener.callcount = 0;
      listener.onremove = function() {
        this.success = true;
        this.callcount += 1;
      };

      indices.remove(2);
      QUnit.equal(indices.length, 3, 'match has been removed from indices');
      QUnit.equal(refs.length, 3, 'match has been removed from refs');
      QUnit.ok(listener.success, '"remove" event propagates to the matchref');
      QUnit.equal(listener.callcount, 1, '"remove" is emitted exactly once');
      QUnit.deepEqual(refs.asArray(), [4, 2, 3], 'ids get translated');
    });
  };
});

/**
 * unit test
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/matchmodel',[],function() {
  return function(QUnit, getModule) {
    var MatchModel, MatchResult, Listener;

    MatchModel = getModule('core/matchmodel');
    MatchResult = getModule('core/matchresult');
    Listener = getModule('core/listener');

    QUnit.test('MatchModel', function() {
      var game, array, ref, listener, data;

      game = new MatchModel();
      QUnit.ok(game, 'empty initialization works');

      game = new MatchModel([15]);
      QUnit.ok(game, 'empty game id still instantiates the MatchModel.');
      QUnit.equal(game.getID(), -1, 'game id default to -1');

      game = new MatchModel([15], 0);
      QUnit.ok(game, 'empty group still instantiates the MatchModel');
      QUnit.equal(game.getGroup(), -1, 'group defaults to -1');

      game = new MatchModel([], 0, 0);
      QUnit.ok(game, 'empty teams array still works');

      game = new MatchModel([15], 51, 5);

      QUnit.equal(game.getID(), 51, 'id is correct');
      QUnit.equal(game.getGroup(), 5, 'group is correct');
      QUnit.equal(game.length, 1, 'game.length is correct');
      QUnit.equal(game.getTeamID(-123), undefined, 'getTeamID below 0');
      QUnit.equal(game.getTeamID(1), undefined, 'getTeamID at game.length');
      QUnit.equal(game.getTeamID(12), undefined, 'getTeamID outside of range');
      QUnit.equal(game.getTeamID(0), 15, 'getTeamID inside range');

      array = [1, 2, 3, 4, 5];
      game = new MatchModel(array, 2, 3);
      array[3] = 321;
      QUnit.equal(game.getTeamID(3), 4, 'MatchModel() copies the team array');

      game = new MatchModel([1, 2], 0, 0);
      ref = new MatchResult(game, [13, 7]);

      listener = new Listener();
      listener.finished = false;
      listener.onfinish = function() {
        this.finished = true;
      };
      game.registerListener(listener);

      QUnit.equal(game.finish(), undefined, 'game.finish() fails');
      QUnit.equal(game.finish([]), undefined, 'game.finish([]) fails');
      QUnit.equal(game.finish([3, 2, 1]), undefined,
          'game.finish([3,2,1]) fails');
      QUnit.equal(listener.finished, false, 'no "finish" event sent yet');
      QUnit.deepEqual(game.finish([13, 7]), ref, 'game.finish([13,7]) works');
      QUnit.equal(listener.finished, true, '"finish" event sent yet');

      game = new MatchModel([4, 1, 2], 2, 3);
      data = game.save();
      QUnit.ok(data, 'save() returns something');
      game = new MatchModel();
      QUnit.equal(game.restore(data), true, 'restore() works');
      QUnit.equal(game.length, 3, 'restore(): correct length');
      QUnit.equal(game.getID(), 2, 'restore(): correct id');
      QUnit.equal(game.getGroup(), 3, 'restore(): correct group');
      QUnit.equal(game.getTeamID(0), 4, 'restore(): correct team id 0');
      QUnit.equal(game.getTeamID(1), 1, 'restore(): correct team id 1');
      QUnit.equal(game.getTeamID(2), 2, 'restore(): correct team id 2');

      /*
       * isRunningMatch()
       */
      game = new MatchModel([0, 1], 0, 0);
      QUnit.ok(game.isRunningMatch(), 'isRunningMatch() of a typical match');

      game = new MatchModel([0, 0], 0, 0);
      QUnit.equal(game.isRunningMatch(), false,
          'isRunningMatch() of a match with duplicate teams');

      game = new MatchModel([0, undefined], 0, 0);
      QUnit.equal(game.isRunningMatch(), false,
          'isRunningMatch() of a match with an undefined team');

      /*
       * save() with an undefined team
       */
      data = game.save();
      QUnit.ok(data, 'save() with undefined team succeeds');
      game = new MatchModel();
      QUnit.equal(game.restore(data), true,
          'restore() with undefined team works');
      QUnit.equal(game.getTeamID(1), undefined,
          'second team still is undefined');
    });
  };
});

/**
 * unit test
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/matchreferencemodel',[],function() {
  return function(QUnit, getModule) {
    var MatchModel, MatchReferenceModel, ListModel;

    MatchModel = getModule('core/matchmodel');
    MatchReferenceModel = getModule('core/matchreferencemodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('MatchReferenceModel', function() {
      var game, gameref, teamlist;

      teamlist = new ListModel();
      teamlist.push(5);
      teamlist.push(7);
      teamlist.push(3);
      teamlist.push(9);

      game = new MatchModel([3, 2, 1, 0], 2, 5);
      QUnit.equal(game.getTeamID(0), 3, 'MatchModel: internal value');
      QUnit.equal(game.getTeamID(1), 2, 'MatchModel: internal value');
      QUnit.equal(game.getTeamID(2), 1, 'MatchModel: internal value');
      QUnit.equal(game.getTeamID(3), 0, 'MatchModel: internal value');

      gameref = new MatchReferenceModel(game, teamlist);

      QUnit.equal(gameref.getID(), game.getID(), 'identical game ids');
      QUnit.equal(gameref.getGroup(), game.getGroup(), 'identical game group');

      QUnit.equal(gameref.getTeamID(0), 9, 'global value');
      QUnit.equal(gameref.getTeamID(1), 3, 'global value');
      QUnit.equal(gameref.getTeamID(2), 7, 'global value');
      QUnit.equal(gameref.getTeamID(3), 5, 'global value');

      teamlist.set(1, 12);
      teamlist.remove(0);
      teamlist.push(53);
      teamlist.remove(2);

      // The time of reference is relevant, not the team list at a later
      // time
      QUnit.equal(gameref.getTeamID(0), 9, 'teamlist changes have no impact');
      QUnit.equal(gameref.getTeamID(1), 3, 'teamlist changes have no impact');
      QUnit.equal(gameref.getTeamID(2), 7, 'teamlist changes have no impact');
      QUnit.equal(gameref.getTeamID(3), 5, 'teamlist changes have no impact');

      listener = {
        finished: false,
        onfinish: function() {
          this.finished = true;
        },
        emitters: []
      };

      game = new MatchModel([1, 2], 0, 2);
      gameref = new MatchReferenceModel(game, teamlist);
      gameref.registerListener(listener);
      game.finish([3, 4]);
      QUnit.equal(listener.finished, true, '"finish" event cascades through');

      listener.finished = false;
      game = new MatchModel([1, 2], 0, 2);
      gameref = new MatchReferenceModel(game, teamlist);
      game.registerListener(listener);
      gameref.finish([3, 4]);
      QUnit.equal(listener.finished, true, 'finish() is forwarded properly');

      listener.finished = false;
      game = new MatchModel([1, 2], 0, 2);
      gameref = new MatchReferenceModel(game, teamlist);
      gameref.registerListener(listener);
      gameref.finish([3, 4]);
      QUnit.equal(listener.finished, true, 'finish() -> onfinish roundtrip');
    });
  };
});

/**
 * MatchResult tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/matchresult',[],function() {
  return function(QUnit, getModule) {
    var MatchModel, MatchResult;

    MatchModel = getModule('core/matchmodel');
    MatchResult = getModule('core/matchresult');

    QUnit.test('MatchResult', function() {
      var match, result, score, success, teams, data;

      match = new MatchModel([1, 2], 2, 5);
      result = undefined;

      try {
        result = new MatchResult();
        success = true;
      } catch (e) {
        success = false;
      }

      QUnit.ok(success, 'empty construction works');
      QUnit.equal(result.match, undefined, 'empty construction -> no match');
      QUnit.deepEqual(result.teams, [], 'empty construction -> empty teams');
      QUnit.deepEqual(result.score, [], 'empty construction -> empty score');
      QUnit.deepEqual(result.getID(), -1, 'empty construction -> id == -1');
      QUnit.deepEqual(result.getGroup(), -1,
          'empty construction -> group == -1');

      score = [13, 7];
      try {
        result = new MatchResult(match, score);
        success = true;
      } catch (e) {
        success = false;
      }
      QUnit.ok(success, 'passing match as first argument');
      QUnit.equal(result.match, undefined,
          'result.match got kicked out of the API');
      QUnit.deepEqual(result.teams, match.teams, 'match teams match');
      QUnit.ok(result.teams !== match.teams, 'match teams are only copies');
      QUnit.deepEqual(result.score, score, 'scores match');
      QUnit.ok(result.score !== score, 'scores are only copies of another');
      QUnit.deepEqual(result.getID(), 2, 'keeping the id');
      QUnit.deepEqual(result.getGroup(), 5, 'keeping the group id');
      QUnit.equal(result.isBye(), false, 'result is not a bye');

      /*
       * create MatchResult from another MatchResult
       */

      score = [8, 12];
      result = new MatchResult(result, score);
      QUnit.ok(success, 'passing match as first argument');
      QUnit.equal(result.match, undefined,
          'result.match got kicked out of the API');
      QUnit.deepEqual(result.teams, match.teams, 'match teams match');
      QUnit.ok(result.teams !== match.teams, 'match teams are only copies');
      QUnit.deepEqual(result.score, score, 'scores match');
      QUnit.ok(result.score !== score, 'scores are only copies of another');
      QUnit.deepEqual(result.getID(), 2, 'keeping the id');
      QUnit.deepEqual(result.getGroup(), 5, 'keeping the group id');
      QUnit.equal(result.isBye(), false, 'result is not a bye');

      /*
       * incompatible API changes
       */

      teams = [5, 1];
      score = [5, 11];
      try {
        result = new MatchResult(teams, score);
        success = false;
      } catch (e) {
        success = true;
      }
      QUnit.ok(success,
          'construction with a team array does not work anymore (API change)');

      /*
       * save/restore
       */

      result = new MatchResult(new MatchModel([5, 3], 8, 1), [13, 7]);
      data = result.save();
      QUnit.ok(data, 'save() finishes');

      teams = [5, 3];
      score = [13, 7];
      result = new MatchResult();
      QUnit.ok(result.restore(data), 'restore() finishes');
      QUnit.equal(result.match, undefined, 'restore(): match not restored');
      QUnit.deepEqual(result.teams, teams, 'restore(): teams restored');
      QUnit.deepEqual(result.score, score, 'restore(): scores restored');
      QUnit.deepEqual(result.getID(), 8, 'restore(): id restored');
      QUnit.deepEqual(result.getGroup(), 1, 'restore(): group id restored');
      QUnit.equal(result.isBye(), false, 'result is not a bye');

      /*
       * isRunningMatch()
       */
      QUnit.equal(result.isRunningMatch(), false,
          'results are not running matches');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/matrixmodel',[],function() {
  return function(QUnit, getModule) {
    var MatrixModel;

    MatrixModel = getModule('core/matrixmodel');
    VectorModel = getModule('core/vectormodel');

    QUnit.test('MatrixModel', function() {
      // constructor validation
      var a, v, v2, ref, savedata;

      a = new MatrixModel();
      QUnit.equal(a.length, 0, 'empty size initialization');
      QUnit.equal(a.get(0, 0), undefined, 'get(0,0): out of bounds');

      a = new MatrixModel(5);
      QUnit.equal(a.length, 5, 'prefixed size initialization');
      QUnit.equal(a.get(0, 0), 0, 'get(0,0) === 0 on size-initialized array');
      QUnit.equal(a.get(-1, 1), undefined, 'get(-1,1): out of bounds');
      QUnit.equal(a.get(1, -1), undefined, 'get(1,-1): out of bounds');
      QUnit.equal(a.get(1, 5), undefined, 'get(1,5): out of bounds');
      QUnit.equal(a.get(5, 1), undefined, 'get(5,1): out of bounds');

      // extend
      a.resize();
      QUnit.equal(a.length, 5, 'resize() aborts on missing argument');

      a.resize(3);
      QUnit.equal(a.length, 3, 'resize() can shrink the array');

      a.resize(10);
      QUnit.equal(a.length, 10, 'resize() can extend the array');

      QUnit.equal(a.set(11, 5, 3), undefined,
          'set() out of bounds returns undefined');
      QUnit.equal(a.set(4, 5, 3), a, 'set() inside bounds returns this');

      QUnit.equal(a.get(4, 5), 3, 'get() returns the set value');
      a.resize(6);
      QUnit.equal(a.get(4, 5), 3,
          'get() returns the set value after resize (still in bounds)');
      a.resize(5);
      QUnit.equal(a.get(4, 5), undefined,
          'get() returns the set value (now out of bounds)');

      QUnit.equal(a.set(0, 0, 5), a, 'set at 0,0 is a valid operation');
      QUnit.equal(a.get(0, 0), 5, 'set(0,0,...) actually sets the value');

      QUnit.equal(a.set(0, 0, 0), a, 'set(0,0,0) does not abort');
      QUnit.equal(a.get(0, 0), 0,
          'get(0,0) after setting to 0 does not return undefined');

      QUnit.equal(a.set(1, 2, 3), a, 'set(1,2) does not abort');
      QUnit.equal(a.get(1, 2), 3, 'get(1,2) is valid before remove()');
      QUnit.equal(a.remove(2), a, 'remove returns this');
      QUnit.equal(a.length, 4, 'remove reduces the size of the matrix');
      QUnit.equal(a.get(1, 2), 0,
          'get(1,2) after remove() now points to another element; returns 0');

      a = new MatrixModel(5);
      [0, 1, 2, 3, 4].map(function(row) {
        [0, 1, 2, 3, 4].map(function(col) {
          a.set(row, col, row * a.length + col);
        });
      });

      v = new VectorModel();
      ref = [0, 6, 12, 18, 24];

      QUnit.equal(a.diagonal(v), v, 'diagonal() returns the vector');
      QUnit.equal(v.length, 5, 'diagonal() resizes the vector');
      QUnit.deepEqual(v.asArray(), ref, 'diagonal has really been extracted');

      v2 = new VectorModel();
      v2.push(1);
      v2.push(2);
      v2.push(3);
      v2.push(4);
      v2.push(5);

      v.resize(0);
      ref = [40, 115, 190, 265, 340];

      QUnit.equal(a.multVector(v, v2), v, 'multVector() finished properly');
      QUnit.equal(v.length, 5, 'multVector resizes the output vector');
      QUnit.deepEqual(v.asArray(), ref, 'multVector performs flawlessly');

      v.resize(0);
      ref = [200, 215, 230, 245, 260];

      QUnit.equal(a.vectorMult(v, v2), v, 'vectorMult() finished properly');
      QUnit.equal(v.length, 5, 'vectorMult resizes the output vector');
      QUnit.deepEqual(v.asArray(), ref, 'vectorMult performs flawlessly');

      a = new MatrixModel(2);
      a.set(0, 0, 1);
      a.set(0, 1, 2);
      a.set(1, 0, 3);
      a.set(1, 1, 4);

      a.fill();
      QUnit.equal(a.get(0, 0), 0, 'fill() sets to 0');
      QUnit.equal(a.get(0, 1), 0, 'fill() sets to 0');
      QUnit.equal(a.get(1, 0), 0, 'fill() sets to 0');
      QUnit.equal(a.get(1, 1), 0, 'fill() sets to 0');

      a.fill(5);
      QUnit.equal(a.get(0, 0), 5, 'fill(5) sets to 5');
      QUnit.equal(a.get(0, 1), 5, 'fill(5) sets to 5');
      QUnit.equal(a.get(1, 0), 5, 'fill(5) sets to 5');
      QUnit.equal(a.get(1, 1), 5, 'fill(5) sets to 5');

      a = new MatrixModel(5);
      a.set(1, 2, 3);
      a.set(0, 0, 5);
      a.set(0, 4, -1);
      a.set(4, 1, 3);
      a.set(4, 4, 123);

      savedata = a.save();
      QUnit.ok(savedata, 'save() works');

      a = new MatrixModel(12345);
      QUnit.ok(a.restore(savedata), 'restore() works');
      QUnit.equal(a.length, 5, 'restore() restored the length');
      QUnit.equal(a.get(1, 2), 3, 'restore() restored individual numbers');
      QUnit.equal(a.get(0, 0), 5, 'restore() restored individual numbers');
      QUnit.equal(a.get(0, 4), -1, 'restore() restored individual numbers');
      QUnit.equal(a.get(4, 1), 3, 'restore() restored individual numbers');
      QUnit.equal(a.get(4, 4), 123, 'restore() restored individual numbers');

      a = new MatrixModel(3);
      savedata = a.save();
      QUnit.ok(savedata, 'save() with empty matrix');
      a = new MatrixModel(7);
      QUnit.ok(a.restore(savedata), 'restore() of an empty matrix');
      QUnit.equal(a.length, 3, 'restore(0 restored the length');
    });
  };
});

/**
 * Model class tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/model',[],function() {
  return function(QUnit, getModule) {
    var Model, Emitter, extend;

    Model = getModule('core/model');
    Emitter = getModule('core/emitter');
    extend = getModule('lib/extend');

    QUnit.test('Model', function() {
      var model, success;

      QUnit.ok(extend.isSubclass(Model, Emitter),
          'Model is an Emitter subclass');

      model = new Model();

      QUnit.deepEqual(model.save(), {}, 'Model.save() returns empty object');

      try {
        QUnit.equal(model.restore({}), true,
            'Model.restore() returns true on success');
        success = true;
      } catch (e) {
        success = false;
      }
      QUnit.ok(success, 'model.restore() exists and is a function');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/orderlistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, OrderListModel, ListModel;

    extend = getModule('lib/extend');
    OrderListModel = getModule('core/orderlistmodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('OrderListModel', function() {
      var list, order, ref;
      QUnit.ok(extend.isSubclass(OrderListModel, ListModel),
          'OrderListModel is subclass of ListModel');

      list = new OrderListModel();
      QUnit.equal(list.length, 0, 'initial length is 0');
      QUnit.deepEqual(list.asArray(), [], 'initial list is empty');

      ref = [4, 3, 1, 0, 2];
      list.enforceOrder(ref);
      QUnit.equal(list.length, 5, 'length gets adjusted automatically');
      QUnit.deepEqual(list.asArray(), ref,
          'elements get ordered properly');

      ref = [6, 3, 1, 5, 7, 2, 0, 4];
      list.enforceOrder(ref);
      QUnit.equal(list.length, 8, 'length gets adjusted automatically');
      QUnit.deepEqual(list.asArray(), ref,
          'elements get ordered properly');

      ref = [];
      list.enforceOrder(ref);
      QUnit.equal(list.length, 0, 'length gets reduced automatically');
      QUnit.deepEqual(list.asArray(), ref, 'elements get removed properly');

    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/positivematrix',[],function() {
  return function(QUnit, getModule) {
    var DelegateMatrix;

    PositiveMatrix = getModule('core/positivematrix');
    DelegateMatrix = getModule('core/delegatematrix');
    MatrixModel = getModule('core/matrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('PositiveMatrix', function() {
      // constructor validation
      var a, m;

      QUnit.ok(extend.isSubclass(PositiveMatrix, DelegateMatrix),
          'PositiveMatrix is a DelegateMatrix subclass');

      m = new MatrixModel(5);
      a = new PositiveMatrix(m);
      [0, 1, 2, 3, 4].forEach(function(row) {
        [0, 1, 2, 3, 4].forEach(function(col) {
          m.set(row, col, 12 - (row * a.length + col));
        });
      });

      QUnit.equal(a.get(0, 0), 12, 'get() returns the positive value');
      QUnit.equal(a.get(3, 2), 0, 'get() returns the positive value');
      QUnit.equal(a.get(1, 0), 7, 'get() returns the positive value');
      QUnit.equal(a.get(2, 2), 0, 'get() returns the positive value');
      QUnit.equal(a.get(4, 4), 0, 'get() returns the positive value');

      QUnit.equal(a.get(-1, 2), undefined, 'get() out of bounds (row low)');
      QUnit.equal(a.get(2, -9), undefined, 'get() out of bounds (col low)');
      QUnit.equal(a.get(5, 3), undefined, 'get() out of bounds (row high)');
      QUnit.equal(a.get(3, 7531), undefined, 'get() out of bounds (col high)');
    });
  };
});

/**
 * Model class tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/propertymodel',[],function() {
  return function(QUnit, getModule) {
    var PropertyModel;

    PropertyModel = getModule('core/propertymodel');

    QUnit.test('PropertyModel', function() {
      var prop, listener, ref, savedata;

      prop = new PropertyModel();
      QUnit.ok(prop !== undefined, 'empty initialization is allowed');
      QUnit.equal(prop.getProperty('someprop'), undefined,
          'access to undefined keys returns undefined');

      listener = {
        success: false,
        onupdate: function() {
          this.success = true;
        },
        emitters: []
      };

      prop.registerListener(listener);

      QUnit.equal(prop.setProperty('name', 'Some Name'), true,
          'setProperty() returns true');
      QUnit.equal(listener.success, true, 'setProperty() emits update event');
      QUnit.equal(prop.getProperty('name'), 'Some Name',
          'setProperty() actually stores values');

      listener.success = false;
      QUnit.equal(prop.setProperty('name', 'Another Name'), true,
          'setProperty() returns true');
      QUnit.equal(listener.success, true, 'setProperty() emits update event');
      QUnit.equal(prop.getProperty('name'), 'Another Name',
          'setProperty() actually changes values');

      listener.success = false;
      QUnit.equal(prop.setProperty('name', 'Another Name'), false,
          'setProperty() returns false on no-change');
      QUnit.equal(listener.success, false,
          'setProperty() emits no update on no-change');
      QUnit.equal(prop.getProperty('name'), 'Another Name',
          'setProperty() did not change any values');

      ref = {
        asd: 'dsa',
        i: 5
      };
      QUnit.equal(prop.setProperty('object', ref), false,
          'cannot store objects');
      QUnit.equal(prop.getProperty('object'), undefined,
          'object references are not stored');

      QUnit.equal(prop.setProperty('array', [1, 2, 3]), false,
          'cannot store arrays');
      QUnit.equal(prop.getProperty('array'), undefined,
          'array object references are not stored');

      ref = function() {
        //
      };

      QUnit.equal(prop.setProperty('function', ref), false,
          'cannot store functions');
      QUnit.equal(prop.getProperty('function'), undefined,
          'function references are not stored');

      QUnit.equal(prop.setProperty('date', new Date()), false,
          'cannot store dates');
      QUnit.equal(prop.getProperty('date'), undefined, 'dates are not stored');

      QUnit.equal(prop.setProperty('regex', /dsa/), false,
          'cannot store regular expressions');
      QUnit.equal(prop.getProperty('regex'), undefined,
          'regular expressions are not stored');

      /*
       * save()/restore()
       */
      prop = new PropertyModel();
      prop.setProperty('string', 'somevalue');
      prop.setProperty('int', 53241);
      prop.setProperty('float', 53.241);
      prop.setProperty('boolean', true);

      savedata = prop.save();
      QUnit.ok(savedata, 'save() works');

      prop = new PropertyModel();
      QUnit.equal(prop.restore(savedata), true, 'restore() works!');
      QUnit.equal(prop.getProperty('string'), 'somevalue', 'string restored');
      QUnit.equal(prop.getProperty('int'), 53241, 'int restored');
      QUnit.equal(prop.getProperty('float'), 53.241, 'float restored');
      QUnit.equal(prop.getProperty('boolean'), true, 'boolean restored');

      prop = new PropertyModel({
        bool: true,
        str: 'string',
        num: 123
      });

      QUnit.ok(prop, 'property model with default initialization');
      QUnit.equal(prop.getProperty('bool'), true, 'default bool property');
      QUnit.equal(prop.getProperty('str'), 'string', 'default str property');
      QUnit.equal(prop.getProperty('num'), 123, 'default num property');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/propertyvaluemodel',[],function() {
  return function(QUnit, getModule) {
    var extend, PropertyValueModel, ValueModel;

    extend = getModule('lib/extend');
    PropertyValueModel = getModule('core/propertyvaluemodel');
    PropertyModel = getModule('core/propertymodel');
    ValueModel = getModule('core/valuemodel');
    Listener = getModule('core/listener');

    QUnit.test('PropertyValueModel', function() {
      var model, value, listener;

      QUnit.ok(extend.isSubclass(PropertyValueModel, ValueModel),
          'PropertyValueModel is subclass of ValueModel');

      model = new PropertyModel({
        bool: true,
        num: 5,
        str: 'dapfen'
      });

      value = new PropertyValueModel(model, 'bool');

      QUnit.ok(value, 'bool value initialization');
      QUnit.equal(value.get(), true, 'value is initialized to current value');

      listener = new Listener(value);
      listener.updates = 0;
      listener.onupdate = function() {
        this.updates += 1;
      };

      model.setProperty('bool', false);
      QUnit.equal(listener.updates, 1, 'value: 1 propagate update');
      QUnit.equal(value.get(), false, 'value is propagated to value');

      listener.updates = 0;
      value.set(true);
      QUnit.equal(listener.updates, 1, 'value.set(): no event loop');
      QUnit.equal(value.get(), true, 'value is properly set');
      QUnit.equal(model.getProperty('bool'), true,
          'value is propagated to PropertyModel');

      listener.updates = 0;
      value.set(value.get());
      QUnit.equal(listener.updates, 0, 'value.set(value.get()): no-op');

      listener.updates = 0;
      model.setProperty('bool', model.getProperty('bool'));
      QUnit.equal(listener.updates, 0, 'setProp(getProp()): no-op');
    });
  };
});

/**
 * No Description
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Random Test
 */
define('core/test/random',[],function() {
  return function(QUnit, getModule) {
    var Random;

    Random = getModule('core/random');

    QUnit.test('Random', function() {
      var min, max, r, x, i, sum;

      r = new Random();

      min = max = r.nextDouble();
      sum = 0.0;

      for (i = 0; i < 10000; i += 1) {
        x = r.nextDouble();

        if (x < min) {
          min = x;
        }
        if (x > max) {
          max = x;
        }

        sum += x;
      }

      // approximate testing
      QUnit.equal(Math.abs(sum - 5000) < 100, true, 'double mean');
      QUnit.equal(min < 0.01, true, 'double min top');
      QUnit.equal(min >= 0.0, true, 'double min bottom');
      QUnit.equal(max > 0.99, true, 'double max top');
      QUnit.equal(max < 1.0, true, 'double max bottom');

      max = min = r.nextInt(64);

      for (i = 0; i < 10000; i += 1) {
        x = r.nextInt(64);

        if (x < min) {
          min = x;
        }
        if (x > max) {
          max = x;
        }
      }

      QUnit.equal(min, 0, 'int min');
      QUnit.equal(max, 63, 'int max');

      // TODO test pick() and pickAndRemove()
    });
  };
});

/**
 * RankingComponentIndex class tests
 *
 * @return RankingComponentIndex
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingcomponentindex',[],function() {
  return function(QUnit, getModule) {
    var RankingComponentIndex;

    RankingComponentIndex = getModule('core/rankingcomponentindex');
    Type = getModule('core/type');

    QUnit.test('RankingComponentIndex', function() {
      var chain, ranking, components, chainlength;

      ranking = {};
      components = [];

      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(chain, undefined, 'chain creation fails without components');

      components = ['id'];
      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(Type(chain), 'object', 'id: chain created');
      QUnit.deepEqual(chain.dependencies, [], 'id: no dependencies');

      components = ['points'];
      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(Type(chain), 'object', 'points: chain created');
      QUnit.deepEqual(chain.dependencies, ['points'], 'points dependency');

      components = ['wins'];
      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(Type(chain), 'object', 'wins: chain created');
      QUnit.deepEqual(chain.dependencies, ['wins'], 'wins dependency');

      // Note to self: There's no need to test every single component HERE.
      // There should be complete ranking tests for that

      components = 'numgames,wins,points'.split(',');
      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(Type(chain), 'object', 'multiple: chain created');
      QUnit.deepEqual(chain.dependencies, ['points', 'wins', 'numgames'],
          'multiple dependencies, correct order.');
      chainlength = 0;
      while (chain) {
        chainlength += 1;
        chain = chain.nextcomponent;
      }
      QUnit.equal(chainlength, components.length + 1,
          'chain has correct length (components.length + DUMMYCOMPONENT)');

      components = 'numgames,wtfisthis,points'.split(',');
      chain = RankingComponentIndex.createComponentChain(ranking, components);
      QUnit.equal(chain, undefined, 'create aborts on unknown component');
    });
  };
});

/**
 * RankingDataListenerIndex class tests
 *
 * @return RankingDataListenerIndex
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingdatalistenerindex',[],function() {
  return function(QUnit, getModule) {
    var RankingDataListenerIndex, Emitter, MatchResult, MatchModel;

    RankingDataListenerIndex = getModule('core/rankingdatalistenerindex');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    Emitter = getModule('core/emitter');

    QUnit.test('RankingDataListenerIndex', function() {
      var names, listeners, dummyRanking, result, ref;

      dummyRanking = new Emitter();
      dummyRanking.length = 5;
      dummyRanking.EVENTS = {
        'result': true
      };

      names = [];
      listeners = RankingDataListenerIndex.registerDataListeners(dummyRanking,
          names);
      QUnit.deepEqual(names, [], 'empty names: still valid input');
      QUnit.deepEqual(listeners, [], 'empty names: no listeners');

      names = ['points'];
      listeners = RankingDataListenerIndex.registerDataListeners(dummyRanking,
          names);
      QUnit.deepEqual(names, ['points'], 'flat dependencies: valid names out');
      QUnit.deepEqual(listeners.length, 1, 'flat dependencies: one listener');
      QUnit.ok(dummyRanking.points, 'listener creates points field');
      QUnit.equal(dummyRanking.points.length, dummyRanking.length,
          'listener initializes points field size');
      QUnit.equal(dummyRanking.points, listeners[0].points,
          'dummyRanking and listener share the reference');

      result = new MatchResult(new MatchModel([1, 4], 0, 0), [13, 7]);
      dummyRanking.emit('result', result);

      ref = [0, 13, 0, 0, 7];
      QUnit.deepEqual(dummyRanking.points.asArray(), ref,
          'single result accepted');

      result = new MatchResult(new MatchModel([0, 1], 0, 0), [5, 11]);
      dummyRanking.emit('result', result);
      result = new MatchResult(new MatchModel([3, 2], 0, 0), [13, 0]);
      dummyRanking.emit('result', result);

      ref = [5, 24, 0, 13, 7];
      QUnit.deepEqual(dummyRanking.points.asArray(), ref,
          'multiple results work');

      /*
       * Note to self: further input/result validation should be performed in
       * individual tests, for every dummyRanking component.
       */

      dummyRanking = new Emitter();
      dummyRanking.length = 5;
      names = ['saldo'];
      listeners = RankingDataListenerIndex.registerDataListeners(dummyRanking,
          names);
      QUnit.deepEqual(names, ['points', 'lostpoints', 'saldo'],
          'hidden dependencies: valid names and name order');
      QUnit.deepEqual(listeners.length, 3,
          'hidden dependencies: additional listeners');
      QUnit.ok(dummyRanking.points, 'listener creates points field');
      QUnit.ok(dummyRanking.lostpoints, 'listener creates lostpoints field');
      QUnit.ok(dummyRanking.saldo, 'listener creates saldo field');

      dummyRanking = new Emitter();
      dummyRanking.length = 5;
      names = ['points', 'lostpoints', 'points'];
      listeners = RankingDataListenerIndex.registerDataListeners(dummyRanking,
          names);
      QUnit.deepEqual(names, ['points', 'lostpoints'],
          'duplicate dependencies: removing duplicates');
      QUnit.deepEqual(listeners.length, 2,
          'hidden dependencies: additional listeners');

      dummyRanking = new Emitter();
      dummyRanking.length = 5;
      names = ['points', 'wtfisthis', 'saldo'];
      listeners = RankingDataListenerIndex.registerDataListeners(dummyRanking,
          names);
      QUnit.equal(listeners, undefined, 'undefined name -> abort');
      QUnit.deepEqual(names, ['wtfisthis'],
          'undefined name -> names array contains undefined entries');
    });
  };
});

/**
 * RankingModel class tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingheadtohead',[],function() {
  return function(QUnit, getModule) {
    var RankingModel, MatchResult, MatchModel;

    RankingModel = getModule('core/rankingmodel');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');

    QUnit.test('Head-to-Head Ranking', function() {
      var ranking, result, ret, ref;

      ranking = new RankingModel(['wins', 'headtohead'], 5);
      ref = {
        components: ['wins', 'headtohead'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4],
        wins: [0, 0, 0, 0, 0],
        headtohead: ['', '', '', '', '']
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'empty ranking: correct H2H-score');

      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [7, 13]));
      ranking.result(new MatchResult(new MatchModel([1, 0], 0, 0), [13, 9]));
      ref = {
        components: ['wins', 'headtohead'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 1, 2, 0, 2],
        displayOrder: [3, 1, 0, 2, 4],
        wins: [0, 1, 0, 1, 0],
        headtohead: ['', '', '', 1, '']
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'first ranking is correct');

      ranking.result(new MatchResult(new MatchModel([0, 3], 0, 0), [13, 11]));
      ref = {
        components: ['wins', 'headtohead'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 3, 0, 3],
        displayOrder: [0, 1, 3, 2, 4],
        wins: [1, 1, 0, 1, 0],
        headtohead: [1, 1, '', 1, '']
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'cyclic ranking finishes');

      /*
       * Test for 'ignoring subsequent components' bug, #204
       */

      ranking = new RankingModel(['wins', 'headtohead', 'points'], 6);
      ref = {
        components: ['wins', 'headtohead', 'points'],
        ids: [0, 1, 2, 3, 4, 5],
        ranks: [0, 0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4, 5],
        wins: [0, 0, 0, 0, 0, 0],
        headtohead: ['', '', '', '', '', ''],
        points: [0, 0, 0, 0, 0, 0]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, '');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/rankingmapper',[],function() {
  return function(QUnit, getModule) {
    var extend, RankingMapper, Model, RankingModel, MatchResult, MatchModel, ListModel, Listener;

    extend = getModule('lib/extend');
    ListModel = getModule('core/listmodel');
    RankingModel = getModule('core/rankingmodel');
    RankingMapper = getModule('core/rankingmapper');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    Model = getModule('core/model');
    Listener = getModule('core/listener');

    QUnit.test('RankingMapper', function(teams) {
      var internal, ranking, result, listener;

      QUnit.ok(extend.isSubclass(RankingMapper, Model),
          'RankingMapper is subclass of Model');

      teams = new ListModel();
      teams.push(5);
      teams.push(4);
      teams.push(3);
      teams.push(2);
      teams.push(1);

      internal = new RankingModel(['wins', 'saldo'], teams.length);
      ranking = new RankingMapper(internal, teams);

      ref = {
        components: ['wins', 'saldo'],
        ids: [5, 4, 3, 2, 1],
        ranks: [0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4],
        wins: [0, 0, 0, 0, 0],
        saldo: [0, 0, 0, 0, 0]
      };
      QUnit.deepEqual(ranking.get(), ref,
          'only the ids get re-mapped to external ids, not the displayOrder');

      internal.result(new MatchResult(new MatchModel([1, 2], 0, 0), [13, 7]));

      ref = {
        components: ['wins', 'saldo'],
        ids: [5, 4, 3, 2, 1],
        ranks: [1, 0, 4, 1, 1],
        displayOrder: [1, 0, 3, 4, 2],
        wins: [0, 1, 0, 0, 0],
        saldo: [0, 6, -6, 0, 0]
      };
      QUnit.deepEqual(ranking.get(), ref, 'ids remapped after first result');

      listener = new Listener(ranking);
      listener.onupdate = function(emitter) {
        var reference;

        this.success = true;

        reference = {
          components: ['wins', 'saldo'],
          ids: [5, 4, 3, 2, 1],
          ranks: [2, 0, 0, 2, 4],
          displayOrder: [1, 2, 0, 3, 4],
          wins: [0, 1, 1, 0, 0],
          saldo: [0, 6, 6, 0, -12]
        };
        QUnit.equal(emitter, ranking,
            'callback: emitter is ranking (safety check)');
        QUnit.deepEqual(emitter.get(), reference,
            'ids remapped after second result, inside callback');
      };

      internal.result(new MatchResult(new MatchModel([2, 4], 0, 0), [13, 1]));

      QUnit.ok(listener.success, 'RankingMapper emits update events');

      ref = {
        components: ['wins', 'saldo'],
        ids: [5, 4, 3, 2, 1],
        ranks: [2, 0, 0, 2, 4],
        displayOrder: [1, 2, 0, 3, 4],
        wins: [0, 1, 1, 0, 0],
        saldo: [0, 6, 6, 0, -12]
      };
      QUnit.deepEqual(ranking.get(), ref,
          'ids remapped after second result, outside of callback');

    });
  };
});

/**
 * RankingModel class tests
 *
 * @return test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingmodel',[],function() {
  return function(QUnit, getModule) {
    var RankingModel, Model, extend, MatchResult, MatchModel, Listener, Options, CorrectionModel;

    RankingModel = getModule('core/rankingmodel');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    Listener = getModule('core/listener');
    Model = getModule('core/model');
    Options = getModule('options');
    extend = getModule('lib/extend');
    CorrectionModel = getModule('core/correctionmodel');

    QUnit.test('RankingModel', function() {
      var ranking, result, rankingobject, ref, listener, savedata;

      QUnit.equal(Options.byepointswon, 13,
          'Options.byepointswon is set properly');
      QUnit.equal(Options.byepointslost, 7,
          'Options.byepointslost is set properly');

      listener = new Listener();
      listener.reset = function() {
        this.updated = 0;
        this.numreset = 0;
        this.resized = 0;
      };
      listener.onupdate = function() {
        this.updated += 1;
      };
      listener.onreset = function() {
        this.numreset += 1;
      };
      listener.onresize = function() {
        this.resized += 1;
      };

      QUnit.ok(extend.isSubclass(RankingModel, Model),
          'RankingModel is a subclass of Model and, hence, Emitter');

      ranking = new RankingModel();
      QUnit.ok(ranking, 'empty initialization produces a valid ranking');
      ref = {
        components: [],
        ids: [],
        displayOrder: [],
        ranks: []
      };
      QUnit.deepEqual(ranking.get(), ref,
          'empty initialization produces a valid ranking');

      ranking = new RankingModel([], 5);
      QUnit.ok(ranking, 'empty components produce empty ranking');
      QUnit.equal(ranking.length, 0, 'empty ranking has no length');

      ranking = new RankingModel([], 5, ['wins', 'points']);
      QUnit.deepEqual(ranking.extDeps, ['wins', 'points'],
          'empty ranking does not ignore extra dependencies');
      QUnit.ok(ranking.points, 'extradeps: wins are created and listening');
      QUnit.ok(ranking.wins, 'extradeps: points are created and listening');

      ranking = new RankingModel(['points'], 5);
      QUnit.ok(ranking, 'valid initialization');
      QUnit.equal(ranking.length, 5, 'valid ranking size');

      ranking = new RankingModel(['points']);
      QUnit.ok(ranking, 'sizeless ranking can be created');
      QUnit.equal(ranking.length, 0, 'ranking size defaults to 0');

      ranking = new RankingModel(['numgames', 'wins', 'saldo', 'points'], 5);
      QUnit.equal(ranking.dataListeners.numgames.isPrimary(), true,
          'numgames is primary');
      QUnit.equal(ranking.dataListeners.wins.isPrimary(), true,
          'wins is primary');
      QUnit.equal(ranking.dataListeners.saldo.isPrimary(), false,
          'saldo is secondary');
      QUnit.equal(ranking.dataListeners.points.isPrimary(), true,
          'points is primary');
      QUnit.equal(ranking.dataListeners.lostpoints.isPrimary(), true,
          'lostpoints is primary');

      ranking = new RankingModel(['numgames', 'wins'], 5, ['saldo']);
      QUnit.equal(ranking.dataListeners.saldo.isPrimary(), false,
          'extraDependency: saldo is secondary');
      QUnit.equal(ranking.dataListeners.points.isPrimary(), true,
          'extraDependency: points is primary');
      QUnit.equal(ranking.dataListeners.lostpoints.isPrimary(), true,
          'extraDependency: lostpoints is primary');

      ranking = new RankingModel(['numgames', 'wins', 'saldo', 'points'], 5);
      listener.reset();
      ranking.registerListener(listener);

      ref = {
        components: ['numgames', 'wins', 'saldo', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4],
        numgames: [0, 0, 0, 0, 0],
        wins: [0, 0, 0, 0, 0],
        saldo: [0, 0, 0, 0, 0],
        points: [0, 0, 0, 0, 0]
      };
      rankingobject = ranking.get();
      QUnit.ok(rankingobject, 'ranking.get works');
      QUnit.deepEqual(rankingobject, ref, 'empty ranking is not empty');

      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [13, 7]));
      ref = {
        components: ['numgames', 'wins', 'saldo', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 0, 2, 1, 2],
        displayOrder: [1, 3, 0, 2, 4],
        numgames: [0, 1, 0, 1, 0],
        wins: [0, 1, 0, 0, 0],
        saldo: [0, 6, 0, -6, 0],
        points: [0, 13, 0, 7, 0]
      };

      rankingobject = ranking.get();
      QUnit.ok(rankingobject, 'ranking.get works');
      QUnit.deepEqual(rankingobject, ref, 'ranking is correct');
      QUnit.equal(listener.updated, 1, 'result(): update event fired');

      ref = rankingobject;

      listener.reset();
      ranking.invalidate();
      rankingobject = ranking.get();
      QUnit.ok(rankingobject !== ref, 'invalidate() triggers a recalculation');
      QUnit.equal(listener.updated, 1, 'invalidate(): update event fired');

      listener.reset();
      ranking.result(new MatchResult(new MatchModel([0, 4], 0, 0), [0, 11]));
      rankingobject = ranking.get();

      ref = {
        components: ['numgames', 'wins', 'saldo', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [3, 1, 4, 2, 0],
        displayOrder: [4, 1, 3, 0, 2],
        numgames: [1, 1, 0, 1, 1],
        wins: [0, 1, 0, 0, 1],
        saldo: [-11, 6, 0, -6, 11],
        points: [0, 13, 0, 7, 11]
      };
      QUnit.deepEqual(rankingobject, ref, 'second ranking is correct');
      QUnit.equal(listener.updated, 1, 'result(): update event fired');

      ref = {
        components: ['wins', 'buchholz', 'finebuchholz', 'points'],
        ids: [0, 1, 2, 3, 4],
        displayOrder: [2, 4, 3, 0, 1],
        ranks: [3, 4, 0, 2, 1],
        wins: [0, 0, 2, 1, 1],
        buchholz: [2, 2, 1, 0, 2],
        finebuchholz: [2, 1, 4, 2, 3],
        points: [3, 5, 26, 13, 24]
      };

      ranking = new RankingModel(
          ['wins', 'buchholz', 'finebuchholz', 'points'], 5);

      QUnit.equal(ranking.dataListeners.buchholz.isPrimary(), false,
          'buchholz is secondary');
      QUnit.equal(ranking.dataListeners.finebuchholz.isPrimary(), false,
          'finebuchholz is secondary');
      QUnit.equal(ranking.dataListeners.gamematrix.isPrimary(), false,
          'gamematrix is secondary');
      QUnit.equal(ranking.dataListeners.points.isPrimary(), true,
          'points is primary');
      QUnit.equal(ranking.dataListeners.wins.isPrimary(), true,
          'wins is primary');
      QUnit.equal(ranking.dataListeners.winsmatrix.isPrimary(), true,
          'winsmatrix is primary');

      ranking.result(new MatchResult(new MatchModel([0, 4], 0, 0), [3, 13]));
      ranking.result(new MatchResult(new MatchModel([1, 2], 0, 0), [5, 13]));
      ranking.result(new MatchResult(new MatchModel([3, 0], 0, 0), [13, 0]));
      ranking.result(new MatchResult(new MatchModel([4, 2], 0, 0), [11, 13]));

      rankingobject = ranking.get();

      QUnit.deepEqual(rankingobject, ref, 'finebuchholz ranking is correct');

      ranking = new RankingModel(['numgames', 'wins'], 5);
      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [13, 0]));
      ranking.result(new MatchResult(new MatchModel([2, 4], 0, 0), [0, 13]));
      ref = {
        components: ['numgames', 'wins'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 0, 2, 2, 0],
        displayOrder: [1, 4, 2, 3, 0],
        numgames: [0, 1, 1, 1, 1],
        wins: [0, 1, 0, 0, 1]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref, 'ranks order is correct');

      /*
       * bye()
       */
      ranking = new RankingModel(['numgames', 'wins', 'points', 'lostpoints',
          'saldo', 'buchholz', 'finebuchholz'], 5);
      ranking.bye(2);
      ref = {
        components: ['numgames', 'wins', 'points', 'lostpoints', 'saldo',
            'buchholz', 'finebuchholz'],
        ids: [0, 1, 2, 3, 4],
        ranks: [1, 1, 0, 1, 1],
        displayOrder: [2, 0, 1, 3, 4],
        numgames: [0, 0, 1, 0, 0],
        wins: [0, 0, 1, 0, 0],
        points: [0, 0, 13, 0, 0],
        lostpoints: [0, 0, -7, 0, 0],
        saldo: [0, 0, 6, 0, 0],
        buchholz: [0, 0, 0, 0, 0],
        finebuchholz: [0, 0, 0, 0, 0]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'bye() is applied properly to all basic components');

      ranking.bye([0, 1, 3]);
      ref = {
        components: ['numgames', 'wins', 'points', 'lostpoints', 'saldo',
            'buchholz', 'finebuchholz'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 0, 0, 4],
        displayOrder: [0, 1, 2, 3, 4],
        numgames: [1, 1, 1, 1, 0],
        wins: [1, 1, 1, 1, 0],
        points: [13, 13, 13, 13, 0],
        lostpoints: [-7, -7, -7, -7, 0],
        saldo: [6, 6, 6, 6, 0],
        buchholz: [0, 0, 0, 0, 0],
        finebuchholz: [0, 0, 0, 0, 0]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'bye() with multiple teams works (all teams receive bye)');

      ranking.result(new MatchResult(new MatchModel([3, 1], 0, 0), [13, 7]));
      ref = {
        components: ['numgames', 'wins', 'points', 'lostpoints', 'saldo',
            'buchholz', 'finebuchholz'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 1, 2, 0, 4],
        displayOrder: [3, 1, 0, 2, 4],
        numgames: [1, 2, 1, 2, 0],
        wins: [1, 1, 1, 2, 0],
        points: [13, 20, 13, 26, 0],
        lostpoints: [-7, -20, -7, -14, 0],
        saldo: [6, 0, 6, 12, 0],
        buchholz: [0, 2, 0, 1, 0],
        finebuchholz: [0, 1, 0, 2, 0]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'buchholz and finebuchholz include bye-induced wins');

      /*
       * resize()
       */
      ranking.resize(6);
      ref = {
        components: ['numgames', 'wins', 'points', 'lostpoints', 'saldo',
            'buchholz', 'finebuchholz'],
        ids: [0, 1, 2, 3, 4, 5],
        ranks: [2, 1, 2, 0, 4, 4],
        displayOrder: [3, 1, 0, 2, 4, 5],
        numgames: [1, 2, 1, 2, 0, 0],
        wins: [1, 1, 1, 2, 0, 0],
        points: [13, 20, 13, 26, 0, 0],
        lostpoints: [-7, -20, -7, -14, 0, 0],
        saldo: [6, 0, 6, 12, 0, 0],
        buchholz: [0, 2, 0, 1, 0, 0],
        finebuchholz: [0, 1, 0, 2, 0, 0]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'resize() is able to append a team to the ranking');

      ranking.resize(3);
      ref = {
        components: ['numgames', 'wins', 'points', 'lostpoints', 'saldo',
            'buchholz', 'finebuchholz'],
        ids: [0, 1, 2],
        ranks: [1, 0, 1],
        displayOrder: [1, 0, 2],
        numgames: [1, 2, 1],
        wins: [1, 1, 1],
        points: [13, 20, 13],
        lostpoints: [-7, -20, -7],
        saldo: [6, 0, 6],
        buchholz: [0, 0, 0],
        finebuchholz: [0, 0, 0]
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'resize() shrinks without changing the actual values');

      /*
       * reset()
       */
      ranking.reset();
      ref = {
        components: [],
        ids: [],
        displayOrder: [],
        ranks: []
      };
      rankingobject = ranking.get();
      QUnit.deepEqual(rankingobject, ref,
          'reset() restores to an empty ranking');
      QUnit.deepEqual(ranking.length, 0, 'reset() resizes to 0');

      ranking = new RankingModel(['wins', 'saldo'], 5);
      ranking.bye(3);
      ranking.result(new MatchResult(new MatchModel([2, 0], 0, 0), [13, 8]));
      ranking.result(new MatchResult(new MatchModel([1, 4], 0, 0), [11, 9]));
      savedata = ranking.save();
      QUnit.ok(savedata, 'save() works');

      /*
       * restore
       */
      ranking = new RankingModel();
      QUnit.equal(ranking.restore(savedata), true, 'restore() succeeds');
      ret = ranking.get();
      ref = {
        components: ['wins', 'saldo'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 2, 1, 0, 3],
        displayOrder: [3, 2, 1, 4, 0],
        wins: [0, 1, 1, 1, 0],
        saldo: [-5, 2, 5, 6, -2]
      };
      QUnit.deepEqual(ret, ref, 'restore restores the proper stuff');

      /**
       * correct
       */
      ranking.correct(new CorrectionModel(//
      new MatchResult(new MatchModel([2, 0], 0, 0), [13, 8]),//
      new MatchResult(new MatchModel([2, 0], 0, 0), [8, 13]))//
      );
      ref = {
        components: ['wins', 'saldo'],
        ids: [0, 1, 2, 3, 4],
        ranks: [1, 2, 4, 0, 3],
        displayOrder: [3, 0, 1, 4, 2],
        wins: [1, 1, 0, 1, 0],
        saldo: [5, 2, -5, 6, -2]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'restore restores the proper stuff');

      /**
       * restore with a id-only ranking
       */
      ranking = new RankingModel(['id'], 5);
      savedata = ranking.save();
      ranking = new RankingModel();
      ranking.restore(savedata);
      QUnit.equal(ranking.length, 5,
          'restore() of an id-only ranking also restores the length');

      ref = {
        components: ['id'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 1, 2, 3, 4],
        displayOrder: [0, 1, 2, 3, 4],
        id: [0, 1, 2, 3, 4]
      };
      QUnit.deepEqual(ranking.get(), ref, 'id ranking is in correct order');

    });
  };
});

/**
 * RankingModel class tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingsonneborn',[],function() {
  return function(QUnit, getModule) {
    var RankingModel, MatchResult, MatchModel, CorrectionModel;

    RankingModel = getModule('core/rankingmodel');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    CorrectionModel = getModule('core/correctionmodel');

    QUnit.test('Sonneborn-Berger Ranking', function() {
      var ranking, result, ret, ref;

      ranking = new RankingModel(['wins', 'sonneborn'], 5);
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4],
        sonneborn: [0, 0, 0, 0, 0],
        wins: [0, 0, 0, 0, 0]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'empty ranking: correct SB-score');

      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [13, 7]));
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [1, 0, 1, 1, 1],
        displayOrder: [1, 0, 2, 3, 4],
        sonneborn: [0, 0, 0, 0, 0],
        wins: [0, 1, 0, 0, 0]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'first ranking is correct');

      ranking.result(new MatchResult(new MatchModel([0, 4], 0, 0), [0, 11]));
      ret = ranking.get();
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 0, 2, 2, 0],
        displayOrder: [1, 4, 0, 2, 3],
        sonneborn: [0, 0, 0, 0, 0],
        wins: [0, 1, 0, 0, 1]
      };
      QUnit.deepEqual(ret, ref, 'second ranking is correct');

      ranking.result(new MatchResult(new MatchModel([1, 4], 0, 0), [13, 12]));
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 0, 2, 2, 1],
        displayOrder: [1, 4, 0, 2, 3],
        sonneborn: [0, 1, 0, 0, 0],
        wins: [0, 2, 0, 0, 1]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'third ranking is correct');

      ranking.result(new MatchResult(new MatchModel([1, 2], 0, 0), [5, 13]));
      ranking.result(new MatchResult(new MatchModel([3, 0], 0, 0), [13, 0]));
      ranking.result(new MatchResult(new MatchModel([4, 2], 0, 0), [11, 13]));
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 1, 0, 2, 2],
        displayOrder: [2, 1, 3, 4, 0],
        sonneborn: [0, 2, 3, 0, 0],
        wins: [0, 2, 2, 1, 1]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'final ranking is correct');

      /*
       * correct
       */
      ranking.correct(new CorrectionModel(//
      new MatchResult(new MatchModel([3, 0], 0, 0), [13, 0]), //
      new MatchResult(new MatchModel([3, 0], 0, 0), [0, 13]))//
      );
      ref = {
        components: ['wins', 'sonneborn'],
        ids: [0, 1, 2, 3, 4],
        ranks: [3, 1, 0, 4, 2],
        displayOrder: [2, 1, 4, 0, 3],
        sonneborn: [0, 1, 3, 0, 1],
        wins: [1, 2, 2, 0, 1]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'correction is correct');
    });
  };
});

/**
 * Unit Tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

define('core/test/rankingtac',[],function() {
  return function(QUnit, getModule) {
    var RankingModel, MatchResult, MatchModel, Options, CorrectionModel;

    RankingModel = getModule('core/rankingmodel');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    CorrectionModel = getModule('core/correctionmodel');
    Options = getModule('options');

    QUnit.test('TAC Ranking', function() {
      var ranking, result, ret, ref, optionbak;

      /*
       * adjust options to fit typical TAC options
       */
      optionbak = {
        byepointswon: Options.byepointswon,
        byepointslost: Options.byepointslost,
        maxpoints: Options.maxpoints
      };
      Options.byepointswon = 8;
      Options.byepointslost = 6;
      Options.maxpoints = 8;

      ranking = new RankingModel(['tac', 'wins', 'points'], 5);

      QUnit.equal(ranking.dataListeners.tac.isPrimary(), true,
          'tac is a primary dataListener');

      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [0, 0, 0, 0, 0],
        displayOrder: [0, 1, 2, 3, 4],
        wins: [0, 0, 0, 0, 0],
        points: [0, 0, 0, 0, 0],
        tac: [0, 0, 0, 0, 0]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'empty ranking: correct TAC score');

      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [8, 7]));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [2, 0, 2, 1, 2],
        displayOrder: [1, 3, 0, 2, 4],
        wins: [0, 1, 0, 0, 0],
        points: [0, 8, 0, 7, 0],
        tac: [0, 13, 0, 7, 0]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'first ranking is correct');

      ranking.result(new MatchResult(new MatchModel([0, 4], 0, 0), [0, 8]));
      ret = ranking.get();
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [3, 1, 4, 2, 0],
        displayOrder: [4, 1, 3, 0, 2],
        wins: [0, 1, 0, 0, 1],
        points: [0, 8, 0, 7, 8],
        tac: [1, 13, 0, 7, 20]
      };
      QUnit.deepEqual(ret, ref, 'second ranking is correct (0 -> 1)');

      ranking.result(new MatchResult(new MatchModel([1, 4], 0, 0), [8, 5]));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [3, 0, 4, 2, 1],
        displayOrder: [1, 4, 3, 0, 2],
        wins: [0, 2, 0, 0, 1],
        points: [0, 16, 0, 7, 13],
        tac: [1, 28, 0, 7, 25]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'third ranking is correct');

      ranking.result(new MatchResult(new MatchModel([1, 2], 0, 0), [3, 8]));
      ranking.result(new MatchResult(new MatchModel([3, 0], 0, 0), [8, 0]));
      ranking.result(new MatchResult(new MatchModel([4, 2], 0, 0), [8, 6]));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 1, 3, 2, 0],
        displayOrder: [4, 1, 3, 2, 0],
        wins: [0, 2, 1, 1, 2],
        points: [0, 19, 14, 15, 21],
        tac: [2, 31, 23, 27, 39]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'final ranking is correct');

      ranking.result(new MatchResult(new MatchModel([0, 2], 0, 0), [7, 6]));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 1, 2, 3, 0],
        displayOrder: [4, 1, 2, 3, 0],
        wins: [1, 2, 1, 1, 2],
        points: [7, 19, 20, 15, 21],
        tac: [9, 31, 29, 27, 39]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'aborted game points are saldo only');

      ranking.result(new MatchResult(new MatchModel([1, 3], 0, 0), [5, 5]));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 1, 3, 2, 0],
        displayOrder: [4, 1, 3, 2, 0],
        wins: [1, 2, 1, 1, 2],
        points: [7, 24, 20, 20, 21],
        tac: [9, 36, 29, 32, 39]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'aborted game points, equal');

      /*
       * correct()
       */
      ranking.correct(new CorrectionModel(//
      new MatchResult(new MatchModel([0, 2], 0, 0), [7, 6]),//
      new MatchResult(new MatchModel([0, 2], 0, 0), [5, 8])//
      ));
      ref = {
        components: ['tac', 'wins', 'points'],
        ids: [0, 1, 2, 3, 4],
        ranks: [4, 2, 1, 3, 0],
        displayOrder: [4, 2, 1, 3, 0],
        wins: [0, 2, 2, 1, 2],
        points: [5, 24, 22, 20, 21],
        tac: [7, 36, 38, 32, 39]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'correct() works correctly with TAC');

      // undo a correct by correcting again. Should yield the same result.
      ranking = new RankingModel(['tac'], 2);
      ranking.result(new MatchResult(new MatchModel([0, 1], 0, 0), [8, 0]));
      ref = ranking.get();
      ranking.correct(new CorrectionModel(//
      new MatchResult(new MatchModel([0, 1], 0, 0), [8, 0]),//
      new MatchResult(new MatchModel([0, 1], 0, 0), [8, 7])//
      ));
      ranking.correct(new CorrectionModel(//
      new MatchResult(new MatchModel([0, 1], 0, 0), [8, 7]),//
      new MatchResult(new MatchModel([0, 1], 0, 0), [8, 0])//
      ));
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'undo a correction yields original result'
          + ' ("one point for 0:8" is undone correctly)');

      /*
       * bye
       */
      ranking = new RankingModel(['tac'], 2);
      ranking.bye(1);
      ref = {
        components: ['tac'],
        ids: [0, 1],
        ranks: [1, 0],
        displayOrder: [1, 0],
        tac: [0, Options.byepointswon - Options.byepointslost]
      };
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'tac accepts byes');

      ranking.bye(1);
      ref.tac[1] *= 2;
      ret = ranking.get();
      QUnit.deepEqual(ret, ref, 'tac accepts multiple byes');

      /*
       * restore original options
       */
      Options.byepointswon = optionbak.byepointswon;
      Options.byepointslost = optionbak.byepointslost;
      Options.maxpoints = optionbak.maxpoints;
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/readonlylistmodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, ReadonlyListModel;

    ListModel = getModule('core/listmodel');
    ReadonlyListModel = getModule('core/readonlylistmodel');

    QUnit.test('ReadonlyListModel', function() {
      var list, obj, i, ret, res, listener;

      listener = {
        reset: function() {
          listener.length = 0;
          listener.insertions = 0;
          listener.removals = 0;
        },
        onresize: function(emitter) {
          listener.length = emitter.length;
        },
        oninsert: function() {
          listener.insertions += 1;
        },
        onremove: function() {
          listener.removals += 1;
        },
        emitters: []
      };
      listener.reset();

      list = new ListModel();
      rolist = new ReadonlyListModel(list);
      rolist.registerListener(listener);

      QUnit.equal(rolist.push, undefined, 'ReadOnlyList.push: undefined');
      QUnit.equal(rolist.pop, undefined, 'ReadOnlyList.pop: undefined');
      QUnit.equal(rolist.insert, undefined, 'ReadOnlyList.insert: undefined');
      QUnit.equal(rolist.remove, undefined, 'ReadOnlyList.remove: undefined');
      QUnit.equal(rolist.set, undefined, 'ReadOnlyList.set: undefined');
      QUnit.equal(rolist.erase, undefined, 'ReadOnlyList.erase: undefined');
      QUnit.equal(rolist.clear, undefined, 'ReadOnlyList.clear: undefined');

      QUnit.equal(rolist.length, 0, 'initial size is 0');
      QUnit.deepEqual(rolist.asArray(), [], 'asArray returns empty array');

      list.push(2);
      QUnit.deepEqual(rolist.asArray(), [2], 'first push');
      QUnit.equal(rolist.length, 1, 'size after first push is 1');
      QUnit.equal(listener.length, 1, 'resize event fired on push');
      QUnit.equal(listener.insertions, 1, 'insert event fired on push');

      list.push(4);
      QUnit.deepEqual(rolist.asArray(), [2, 4], 'second push');
      QUnit.equal(rolist.length, 2, 'size after second push is 2');
      QUnit.equal(listener.length, 2, 'resize event fired on push');

      list.insert(0, 1);
      QUnit.deepEqual(rolist.asArray(), [1, 2, 4], 'insert at front');
      QUnit.equal(rolist.length, 3, 'size after insert is 3');
      QUnit.equal(listener.length, 3, 'resize event fired on insert');
      QUnit.equal(listener.insertions, 3, 'insert event fired on insert');

      list.insert(3, 5);
      QUnit.deepEqual(rolist.asArray(), [1, 2, 4, 5], 'insert at end');

      list.insert(2, 3);
      QUnit.deepEqual(rolist.asArray(), [1, 2, 3, 4, 5], 'insert inbetween');

      QUnit.equal(rolist.length, 5, 'length after all inserts');
      QUnit.equal(listener.insertions, 5,
          'number of fired insert events matches number of insertions');

      QUnit.equal(rolist.get(0), 1, 'get 1');
      QUnit.equal(rolist.get(1), 2, 'get 2');
      QUnit.equal(rolist.get(2), 3, 'get 3');
      QUnit.equal(rolist.get(3), 4, 'get 4');
      QUnit.equal(rolist.get(4), 5, 'get 5');

      QUnit.equal(rolist.get(-1), undefined, 'get out of bounds (index -1)');
      QUnit.equal(rolist.get(5), undefined,
          'get slightly out of bounds (index 5)');
      QUnit.equal(rolist.get(1234567890), undefined,
          'get wildly out of bounds (index 1234567890)');

      QUnit.equal(rolist.indexOf(1), 0, 'indexOf: first element');
      QUnit.equal(rolist.indexOf(5), 4, 'indexOf: last element');
      QUnit.equal(rolist.indexOf('unavailable'), -1,
          'indexOf: unavailable element');

      QUnit.equal(list.remove(0), 1, 'remove returns the removed object');
      QUnit.deepEqual(rolist.asArray(), [2, 3, 4, 5], 'remove at front');
      QUnit.equal(rolist.length, 4, 'length after remove');
      QUnit.equal(listener.length, 4, 'resize event fired on remove');
      QUnit.equal(listener.removals, 1, 'remove event fired on remove');

      QUnit.equal(list.pop(3), 5, 'pop returns the removed object');
      QUnit.deepEqual(rolist.asArray(), [2, 3, 4], 'pop (remove at back)');
      QUnit.equal(rolist.length, 3, 'length after remove');
      QUnit.equal(listener.removals, 2, 'remove event fired on pop');

      QUnit.equal(list.remove(1), 3, 'remove returns the removed object');
      QUnit.deepEqual(rolist.asArray(), [2, 4], 'remove inbetween');
      QUnit.equal(rolist.length, 2, 'length after remove');

      QUnit.equal(list.remove(123), undefined,
          'remove out of bounds does nothing');
      QUnit.deepEqual(rolist.asArray(), [2, 4], 'remove out of bounds');
      QUnit.equal(rolist.length, 2, 'length after remove out of bounds');

      list.set(1, 123);
      QUnit.equal(rolist.length, 2, 'set does not change length');
      QUnit.deepEqual(rolist.asArray(), [2, 123],
          'list.set actually sets the value');
      QUnit.equal(listener.length, 2,
          'resize event balanced on set() (may have been fired twice)');

      listener.reset();

      QUnit.equal(list.set(123, 321), undefined,
          "set out of bounds doesn't to anything");
      QUnit.deepEqual(rolist.asArray(), [2, 123],
          "set out of bounds really doesn't to anything");
      QUnit.equal(listener.insertions, 0,
          "set out of bounds doesn't fire insert event");
      QUnit.equal(listener.removals, 0,
          "set out of bounds doesn't fire remove event");

      list.clear();
      QUnit.equal(rolist.length, 0, 'list length is 0 after clear');
      QUnit.equal(listener.length, 0, 'resize event fired on clear)');
      QUnit.equal(listener.removals, 2, 'clear fires remove events');

      list.push(4);
      list.push(3);
      list.push(2);
      list.push(1);

      i = 0;

      ret = rolist.map(function(num, index, thelist) {
        QUnit.equal(this, 5, 'map(): this === thisArg, ' + index);
        QUnit.equal(index, i, 'map(): iterating in ascending order, ' + index);
        QUnit.equal(num, rolist.length - index,
            'first argument is the list content' + index);
        QUnit.equal(thelist, rolist,
            'map(): third function argument is the list, ' + index);
        i += 1;
        return num * num;
      }, 5);

      res = [16, 9, 4, 1];
      QUnit.deepEqual(ret, res, 'map(): return value is preserved');

      list.clear();

      QUnit.equal(rolist.length, 0, 'cleared size is 0');
      QUnit.deepEqual(rolist.asArray(), [],
          'asArray returns empty array after clear');

      obj = {
        tmp: true,
        tmpLong: 'very much so'
      };

      list.push(obj);

      QUnit.equal(rolist.get(0), obj,
          'objects are directly referenced, not copied');
      QUnit.equal(list.pop(), obj, 'pop returns the popped object directly');

      QUnit.equal(rolist.length, 0, 'popped size is 0');
      QUnit.deepEqual(rolist.asArray(), [],
          'asArray returns empty array after pop');
    });
  };
});

/**
 * Unit tests for ListModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/referencelistmodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, MatchModel, ReferenceListModel, MatchReferenceModel, Listener;

    Listener = getModule('core/listener');
    ListModel = getModule('core/listmodel');
    MatchModel = getModule('core/matchmodel');
    MatchReferenceModel = getModule('core/matchreferencemodel');
    ReferenceListModel = getModule('core/referencelistmodel');

    QUnit.test('ReferenceListModel', function() {
      var teams, matches, refs, listener, matchref;

      teams = new ListModel();
      teams.push('5');
      teams.push('4');
      teams.push('3');
      teams.push('2');
      teams.push('1');
      teams.push('0');

      matches = new ListModel();
      matches.push(new MatchModel([1, 2], 0, 0));
      matches.push(new MatchModel([0, 5], 1, 0));

      refs = new ReferenceListModel(matches, teams, MatchReferenceModel);

      QUnit.equal(refs.length, matches.length,
          'number of teams match after initialization');

      listener = new Listener(refs);
      listener.success = false;
      listener.callcount = 0;
      listener.oninsert = function() {
        this.success = true;
        this.callcount += 1;
      };

      matches.push(new MatchModel([4, 3], 2, 0));

      QUnit.ok(listener.success, '"insert" event is re-emitted');
      QUnit.equal(listener.callcount, 1, '"insert" is emitted exactly once');
      QUnit.equal(refs.length, 3, 'new team gets added to the matches list');
      listener.destroy();

      matchref = refs.get(0);
      QUnit.equal(matchref.getTeamID(0), 4, 'team id gets translated');
      QUnit.equal(matchref.getTeamID(1), 3, 'team id gets translated');
      matchref = refs.get(1);
      QUnit.equal(matchref.getTeamID(0), 5, 'team id gets translated');
      QUnit.equal(matchref.getTeamID(1), 0, 'team id gets translated');
      matchref = refs.get(2);
      QUnit.equal(matchref.getTeamID(0), 1, 'team id gets translated');
      QUnit.equal(matchref.getTeamID(1), 2, 'team id gets translated');

      listener = new Listener(matchref);
      listener.numEvents = 0;
      listener.onfinish = function() {
        this.numEvents += 1;
      };
      matches.get(2).registerListener(listener);

      matches.get(2).finish([13, 7]);
      QUnit.equal(listener.numEvents, 2,
          'both "finish" events propagate to the matchref');
      QUnit.equal(matches.length, 3, 'match has not been removed by finish()');

      listener.destroy();
      listener = new Listener(refs);
      listener.success = false;
      listener.callcount = 0;
      listener.onremove = function() {
        this.success = true;
        this.callcount += 1;
      };
      matches.remove(2);
      QUnit.equal(matches.length, 2, 'match has been removed from matches');
      QUnit.equal(refs.length, 2, 'match has been removed from refs');
      QUnit.ok(listener.success, '"remove" event propagates to the matchref');
      QUnit.equal(listener.callcount, 1, '"remove" is emitted exactly once');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/resultreferencemodel',[],function() {
  return function(QUnit, getModule) {
    var ResultReferenceModel, MatchModel, ListModel, MatchResult;

    ResultReferenceModel = getModule('core/resultreferencemodel');
    MatchResult = getModule('core/matchresult');
    MatchModel = getModule('core/matchmodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('ResultReferenceModel', function() {
      var game, result, ref, teamlist;

      teamlist = new ListModel();
      teamlist.push(5);
      teamlist.push(7);
      teamlist.push(3);
      teamlist.push(9);

      game = new MatchModel([3, 2, 1, 0], 2, 5);
      result = new MatchResult(game, [13, 7, 5, 2]);
      ref = new ResultReferenceModel(result, teamlist);

      QUnit.equal(ref.getID(), game.getID(), 'identical game ids');
      QUnit.equal(ref.getGroup(), game.getGroup(), 'identical game group');

      QUnit.deepEqual(ref.score, [13, 7, 5, 2], 'score is retained');
      QUnit.equal(ref.getTeamID(0), 9, 'global value');
      QUnit.equal(ref.getTeamID(1), 3, 'global value');
      QUnit.equal(ref.getTeamID(2), 7, 'global value');
      QUnit.equal(ref.getTeamID(3), 5, 'global value');

      teamlist.set(1, 12);
      teamlist.remove(0);
      teamlist.push(53);
      teamlist.remove(2);

      // The time of reference is relevant, not the team list at a later
      // time
      QUnit.equal(ref.getTeamID(0), 9, 'teamlist changes have no impact');
      QUnit.equal(ref.getTeamID(1), 3, 'teamlist changes have no impact');
      QUnit.equal(ref.getTeamID(2), 7, 'teamlist changes have no impact');
      QUnit.equal(ref.getTeamID(3), 5, 'teamlist changes have no impact');
    });
  };
});

/**
 * Unit Tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/rle',[],function() {
  return function(QUnit, getModule) {
    var RLE;

    RLE = getModule('core/rle');

    QUnit.test('RLE', function() {
      var success, data, exp;

      /*
       * encoding tests: static function
       */
      success = true;
      try {
        RLE.encode(undefined);
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with undefined');
      success = true;
      try {
        RLE.encode(null);
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with null');
      success = true;
      try {
        RLE.encode('');
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with ""');
      success = true;
      try {
        RLE.encode({});
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with {}');
      success = true;
      try {
        RLE.encode(/5/);
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with /5/');
      success = true;
      try {
        RLE.encode({
          a: 4
        });
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with {a:4}');
      success = true;
      try {
        RLE.encode('loremipsum');
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with "loremipsum"');

      success = true;
      try {
        RLE.encode('5');
        success = false;
      } catch (e) {
        //
      }
      QUnit.ok(success, 'RLE.encode() with "5"');

      QUnit.equal(RLE.encode([]), '', 'RLE.encode() with []');
      QUnit.equal(RLE.encode(0), '0', 'RLE.encode() with 0');
      QUnit.equal(RLE.encode(3), '3', 'RLE.encode() with 3');

      QUnit.equal(RLE.encode([0]), '[n1]', 'RLE.encode() with [0]');
      QUnit.equal(RLE.encode([1.3]), '[1.3]', 'RLE.encode() with [1.3]');
      QUnit.equal(RLE.encode([-1.3e2]), '[-130]', 'RLE.encode() with [1.3]');
      data = [];
      data[3] = 5;
      QUnit.equal(RLE.encode(data), '[n3,5]',
          'RLE.encode() with [null,null,null,5]');

      QUnit.equal(RLE.encode([[]]), '[n1]', 'RLE.encode() with [[]]');
      QUnit.equal(RLE.encode([[[]]]), '[n1]', 'RLE.encode() with [[[]]]');
      QUnit.equal(RLE.encode([{}]), '[undefined]', 'RLE.encode() with [{}]');
      QUnit.equal(RLE.encode([/5/]), '[undefined]', 'RLE.encode() with [/5/]');
      QUnit.equal(RLE.encode([undefined, null, 0]), '[n3]',
          'RLE.encode() with [undefined,null,0]');
      QUnit.equal(RLE.encode([undefined, null, 30]), '[n2,30]',
          'RLE.encode() with [undefined,null,30]');
      QUnit.equal(RLE.encode([1, undefined, null, 30]), '[1,n2,30]',
          'RLE.encode() with [undefined,null,30]');

      /*
       * Nesting Tests
       */

      data = [];
      data[3] = [1, 2, undefined, 4];

      QUnit.equal(RLE.encode(data), '[n3,[1,2,n,4]]',
          'RLE.encode() with singly nested data');
      data[3] = undefined;
      QUnit.equal(RLE.encode(data), '[n4]',
          'RLE.encode() with singly nested data, all nulled');

      /*
       * RLE.decode()
       */

      QUnit.deepEqual(RLE.decode(''), [], 'RLE decode test with empty string');

      QUnit.deepEqual(RLE.decode('[]'), [],
          'RLE decode test with an empty string');
      QUnit.deepEqual(RLE.decode('[1]'), [1],
          'RLE decode test with single entry');
      QUnit.deepEqual(RLE.decode('[n,1]'), [undefined, 1],
          'RLE decode test with single null entry');
      QUnit.deepEqual(RLE.decode('[n1,1]'), [undefined, 1],
          'RLE decode test with single null entry');
      exp = [];
      exp[3] = 1;
      QUnit.deepEqual(RLE.decode('[n3,1]'), exp,
          'RLE decode test with single null entry');
      QUnit.deepEqual(RLE.decode('[n3,1,n]'), exp,
          'RLE decode test with single null entry');
      QUnit.deepEqual(RLE.decode('[n12]'), [undefined, undefined, undefined,
          undefined, undefined, undefined, undefined, undefined, undefined,
          undefined, undefined, undefined],
          'RLE decode test with only null entries');
      QUnit.deepEqual(RLE.decode('[n5,n6]'), [undefined, undefined, undefined,
          undefined, undefined, undefined, undefined, undefined, undefined,
          undefined, undefined],
          'RLE decode test with only consecutive null entries');

      // Number variations
      QUnit.deepEqual(RLE.decode('[+3]'), [3], 'RLE decode test with [+3]');
      QUnit.deepEqual(RLE.decode('[-0]'), [0], 'RLE decode test with [-0]');
      QUnit.deepEqual(RLE.decode('[1.23]'), [1.23],
          'RLE decode test with [1.23]');
      QUnit.deepEqual(RLE.decode('[-1.23e+4]'), [-12300],
          'RLE decode test with [-1.23e+4]');

      QUnit.deepEqual(RLE.decode('[5,n2]'), [5, undefined, undefined],
          'RLE decode with trailing null values');

      QUnit.deepEqual(RLE.decode('[5,n2]').length, 3,
          'RLE decode with trailing null values');

      QUnit.deepEqual(RLE.decode('[n12]').length, 12,
          'RLE decode with only null values');

      // invalid numbers
      QUnit.deepEqual(RLE.decode('[.]'), undefined,
          'RLE decode test with [.] as input');
      QUnit.deepEqual(RLE.decode('[-]'), undefined,
          'RLE decode test with [-] as input');
      QUnit.deepEqual(RLE.decode('[+]'), undefined,
          'RLE decode test with [+] as input');
      QUnit.deepEqual(RLE.decode('[--6]'), undefined,
          'RLE decode test with [--6] as input');

      exp = [1, [2], [5, [6, undefined, undefined, undefined]], []];
      exp[1][4] = 4;
      exp[3][8] = 9;
      exp[3][9] = [10];
      QUnit.deepEqual(RLE.decode('[1,[2,n3,4],[5,[6,n3]],[n8,9,[10]]]'), exp,
          'RLE decode test with nested arrays');

      exp = [];
      exp[3] = [1, 2, undefined, 4];
      QUnit.deepEqual(RLE.decode('[n3,[1,2,n,4]]'), exp,
          'RLE decode test with nested arrays');

      /*
       * wrong input
       */

      QUnit.equal(RLE.decode(undefined), undefined,
          'RLE.decode() with undefined');
      QUnit.equal(RLE.decode(null), undefined, 'RLE.decode() with null');
      QUnit.equal(RLE.decode({}), undefined, 'RLE.decode() with {}');
      QUnit.equal(RLE.decode(/5/), undefined, 'RLE.decode() with /5/');
      QUnit.equal(RLE.decode({
        a: 4
      }), undefined, 'RLE.decode() with {a:4}');

      /*
       * malformatted data
       */

      QUnit.equal(RLE.decode('5'), undefined, 'RLE.decode() with "5"');
      QUnit.equal(RLE.decode('asd'), undefined, 'RLE.decode() with "asd"');
      QUnit.equal(RLE.decode('{}'), undefined, 'RLE.decode() with "{}"');
      QUnit.equal(RLE.decode('{asd:5}'), undefined,
          'RLE.decode() with "{asd:5}"');
      QUnit.equal(RLE.decode('[{asd:5}]'), undefined,
          'RLE.decode() with "[{asd:5}]"');

      /*
       * Self-Consistency and Stability tests
       */
      e = RLE.encode;
      d = RLE.decode;
      exp[123] = -123.433e-43;
      QUnit.deepEqual(d(e(d(e(d(e(d(e(d(e(d(e(exp)))))))))))), exp,
          'RLE re-encoding chain');

      QUnit.equal(RLE.encode([0, 1, 1, 1]), '[n,1,1,1]',
          'encoding leading null value');
      QUnit.deepEqual(RLE.decode('[n,1,1,1]'), [undefined, 1, 1, 1],
          'decoding leading null value');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/roundtournamentmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, RoundTournamentModel, TournamentModel, matches, byes, state;

    extend = getModule('lib/extend');
    RoundTournamentModel = getModule('core/roundtournamentmodel');
    TournamentModel = getModule('core/tournamentmodel');

    QUnit.test('RoundTournamentModel', function() {
      var tournament, ret, ref, data;

      QUnit.ok(extend.isSubclass(RoundTournamentModel, TournamentModel),
          'RoundTournamentModel is subclass of TournamentModel');

      tournament = new RoundTournamentModel(['wins', 'sonneborn', 'saldo']);
      QUnit.ok(tournament, 'proper construction works');
      matches = tournament.getMatches();
      byes = tournament.getVotes('bye');
      state = tournament.getState();

      tournament.addTeam(1);
      QUnit.ok(!tournament.run(),
          'too few teams prohibit running the tournament');
      tournament.addTeam(2);
      tournament.addTeam(3);
      tournament.addTeam(4);
      tournament.addTeam(5);
      QUnit.ok(tournament.run(), 'five teams work');
      QUnit.equal(matches.length, 2, 'two games for 5 teams');

      QUnit.ok(matches.get(0).getID() < matches.get(1).getID(),
          'match ids are sorted');

      ret = matches.map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        t: [1, 4],
        i: 0,
        g: 0
      }, {
        t: [2, 3],
        i: 1,
        g: 0
      }];
      QUnit.deepEqual(ret, ref, 'first round: correct teams in the matches');
      QUnit.deepEqual(byes.get(0), 5, 'first round: correct bye');

      matches.get(0).finish([13, 7]);
      matches.get(0).finish([11, 13]);
      QUnit.equal(state.get(), 'idle', 'idle after games finished');

      QUnit.equal(matches.length, 0,
          'second round does not start automatically');
      QUnit.ok(tournament.run(), 'second round starts manually');
      QUnit.equal(matches.length, 2, 'second round started');
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        t: [1, 3],
        i: 0,
        g: 1
      }, {
        t: [5, 2],
        i: 1,
        g: 1
      }];
      QUnit.deepEqual(ret, ref, 'second round: correct teams in the matches');
      QUnit.deepEqual(tournament.getVotes('bye').get(0), 4,
          'second round: correct bye');

      matches.get(0).finish([13, 4]);
      matches.get(0).finish([13, 8]);
      QUnit.equal(state.get(), 'idle', 'idle after games finished');

      QUnit.equal(matches.length, 0, 'third round does not run automatically');
      QUnit.ok(tournament.run(), 'third round started manually');
      QUnit.equal(matches.length, 2, 'third round started');
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        t: [1, 2],
        i: 0,
        g: 2
      }, {
        t: [4, 5],
        i: 1,
        g: 2
      }];
      QUnit.deepEqual(ret, ref, 'third round: correct teams in the matches');
      QUnit.deepEqual(tournament.getVotes('bye').get(0), 3,
          'third round: correct bye');

      matches.get(0).finish([11, 13]);
      matches.get(0).finish([10, 13]);
      QUnit.equal(state.get(), 'idle', 'idle after games finished');

      QUnit.equal(matches.length, 0,
          'fourth round does not start automatically');
      QUnit.ok(tournament.run(), 'fourth round started manually');
      QUnit.equal(matches.length, 2, 'fourth round started');
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        t: [1, 5],
        i: 0,
        g: 3
      }, {
        t: [3, 4],
        i: 1,
        g: 3
      }];
      QUnit.deepEqual(ret, ref, 'fourth round: correct teams in the matches');
      QUnit.deepEqual(tournament.getVotes('bye').get(0), 2,
          'fourth round: correct bye');

      matches.get(0).finish([13, 2]);
      matches.get(0).finish([13, 0]);
      QUnit.equal(state.get(), 'idle', 'idle after games finished');

      QUnit.equal(matches.length, 0, 'fifth round does not run automatically');
      QUnit.ok(tournament.run(), 'fifth round started manually');
      QUnit.equal(matches.length, 2, 'fifth round started');
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        t: [2, 5],
        i: 0,
        g: 4
      }, {
        t: [3, 4],
        i: 1,
        g: 4
      }];
      QUnit.deepEqual(ret, ref, 'fifth round: correct teams in the matches');
      QUnit.deepEqual(tournament.getVotes('bye').get(0), 1,
          'fifth round: correct bye');

      matches.get(0).finish([13, 5]);
      matches.get(0).finish([7, 13]);
      QUnit.equal(state.get(), 'finished',
          '5-team tournament finished after 5 rounds');

      ret = tournament.getRanking().get();
      ref = {
        components: ['wins', 'sonneborn', 'saldo'],
        ids: [1, 2, 3, 4, 5],
        displayOrder: [0, 1, 2, 4, 3],
        ranks: [0, 1, 2, 4, 3],
        saldo: [30, 9, 6, -10, -5],
        sonneborn: [8, 7, 5, 3, 5],
        wins: [4, 3, 3, 2, 3]
      };
      QUnit.deepEqual(ret, ref, 'final ranking is correct');

      data = tournament.save();
      QUnit.ok(data, 'save() works');

      tournament = new RoundTournamentModel();
      QUnit.ok(tournament, 'emptyconstruction works');
      matches = tournament.getMatches();
      byes = tournament.getVotes('bye');
      state = tournament.getState();

      QUnit.ok(tournament.restore(data), 'restore() works');
      ret = tournament.getRanking().get();
      QUnit.deepEqual(ret, ref, 'restored ranking is correct');

      /*
       * even number of teams
       */
      tournament = new RoundTournamentModel(['sonneborn']);
      tournament.addTeam(7);
      tournament.addTeam(5);
      tournament.addTeam(3);
      tournament.addTeam(2);

      QUnit.ok(tournament, 'round tournament with 4 teams');

      matches = tournament.getMatches();
      byes = tournament.getVotes('bye');
      state = tournament.getState();

      tournament.run();
      QUnit.equal(state.get(), 'running', 'tournament with 4 teams runs');
      QUnit.equal(byes.length, 0, 'no byes for 4 teams');
      QUnit.equal(matches.length, 2, 'two matches for 4 teams');

      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        g: 0,
        i: 0,
        t: [7, 2]
      }, {
        g: 0,
        i: 1,
        t: [5, 3]
      }];
      QUnit.deepEqual(ret, ref, 'round 1 for 4 teams has correct matches');

      matches.get(0).finish([13, 8]);
      matches.get(0).finish([10, 13]);

      tournament.run();
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        g: 1,
        i: 0,
        t: [7, 3]
      }, {
        g: 1,
        i: 1,
        t: [2, 5]
      }];
      QUnit.deepEqual(ret, ref, 'round 2 for 4 teams has correct matches');

      matches.get(0).finish([3, 13]);
      matches.get(0).finish([13, 9]);

      tournament.run();
      ret = tournament.getMatches().asArray().map(function(match) {
        return {
          t: match.teams,
          i: match.getID(),
          g: match.getGroup()
        };
      });
      ref = [{
        g: 2,
        i: 0,
        t: [7, 5]
      }, {
        g: 2,
        i: 1,
        t: [3, 2]
      }];
      QUnit.deepEqual(ret, ref, 'round 3 for 4 teams has correct matches');

      matches.get(0).finish([13, 4]);
      matches.get(0).finish([13, 9]);

      QUnit.equal(state.get(), 'finished',
          '4-team tournament is finished after 3 rounds');

    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/selectionvaluemodel',[],function() {
  return function(QUnit, getModule) {
    var SelectionValueModel, ListModel;

    SelectionValueModel = getModule('core/selectionvaluemodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('SelectionValueModel', function() {
      var model, allowed, defaultvalue;

      defaultvalue = 123;

      allowed = new ListModel();

      model = new SelectionValueModel(defaultvalue, allowed);
      QUnit.equal(model.get(), defaultvalue, 'defaultvalue respected');

      QUnit.equal(model.set(321), false, 'unallowed value');
      QUnit.equal(model.set(5), false, 'unallowed value');
      QUnit.equal(model.set('asd'), false, 'unallowed value');
      QUnit.equal(model.get(), defaultvalue, 'empty allowed-list');

      allowed.push(5);
      QUnit.equal(model.set(5), true, 'allowed value');
      QUnit.equal(model.set(5), true, 'allowed value, again');
      QUnit.equal(model.get(), 5, 'setting allowed value');

      allowed.push(4);
      allowed.push(3);
      allowed.push(2);
      allowed.push(1);
      allowed.push(10);
      allowed.push(551);

      QUnit.equal(model.get(), 5, 'retaining value on allowedlist-extension');

      QUnit.equal(model.set(10), true, 'allowed value');
      QUnit.equal(model.get(), 10, 'changing allowed value');

      allowed.remove(allowed.indexOf(10));
      QUnit.equal(model.get(), defaultvalue, 'value reverts to defaultValue');

      model.setDefault(321);
      QUnit.equal(model.get(), 321, 'default value changed, was not allowed');
    });
  };
});

/**
 * Unit tests
 *
 * TODO test emitted events
 *
 * TODO test whether the sorted lists are readonly
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/sortedreferencelistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, SortedReferenceListModel;

    extend = getModule('lib/extend');
    SortedReferenceListModel = getModule('core/sortedreferencelistmodel');
    ListModel = getModule('core/listmodel');

    QUnit.test('SortedReferenceListModel', function() {
      var list, sorted, sortfunc, success;

      QUnit.ok(extend.isSubclass(SortedReferenceListModel, ListModel),
          'SortedReferenceListModel is subclass of ReferenceListModel');

      list = new ListModel();

      success = false;
      try {
        sorted = new SortedListModel(list);
      } catch (e) {
        success = true;
      }

      QUnit.ok(success, 'empty construction fails');

      sorted = new SortedReferenceListModel(list);
      QUnit.ok(sorted, 'proper construction');
      QUnit.equal(sorted.length, 0, 'initial sorted list is empty');

      list.push(5);

      QUnit.equal(sorted.length, 1,
          'pushing to the original list is mirrored by sorted list');
      QUnit.deepEqual(sorted.asArray(), [5], 'element has been appended');

      list.push(2);
      list.push(1);
      list.push(4);
      QUnit.deepEqual(sorted.asArray(), [1, 2, 4, 5],
          'appended elements are inserted in sort order');

      list.remove(1);
      QUnit.deepEqual(sorted.asArray(), [1, 4, 5],
          'correct element is removed when removing from original list');

      list.insert(2, 3);
      QUnit.deepEqual(sorted.asArray(), [1, 3, 4, 5],
          'sorting arbitrary insertions into the original list ');

      list.clear();
      QUnit.equal(sorted.length, 0, 'clear() is mirrored');

      list = new ListModel([4, 1, 2, 6, 53]);
      sorted = new SortedReferenceListModel(list);
      QUnit.deepEqual(sorted.asArray(), [1, 2, 4, 6, 53],
          'pre-initialized list is sorted on construction');

      list = new ListModel(['Erik', 'Kai', 'Fabe']);
      sorted = new SortedReferenceListModel(list);
      QUnit.deepEqual(sorted.asArray(), ['Erik', 'Fabe', 'Kai'],
          'strings are sorted');

      sorted = new SortedReferenceListModel(list,
          SortedReferenceListModel.descending);
      QUnit.deepEqual(sorted.asArray(), ['Kai', 'Fabe', 'Erik'],
          'descending order works, too');

      // descending order, even first
      sortfunc = function(a, b) {
        return ((a % 2) - (b % 2)) || (b - a);
      };

      list = new ListModel();
      sorted = new SortedReferenceListModel(list, sortfunc);

      list.push(1);
      list.push(4);
      list.push(3);
      list.push(8);
      list.push(100);
      list.push(3);
      list.push(4);
      list.push(5);
      QUnit.deepEqual(sorted.asArray(), [100, 8, 4, 4, 5, 3, 3, 1],
          'arbitrary sort functions are accepyted');

      sortfunc = function() {
        return 0;
      };
      sorted = new SortedReferenceListModel(list, sortfunc);
      QUnit.deepEqual(sorted.asArray(), list.asArray(),
          'sortfunction with zeroing sortfunction: '
              + 'add element in list order on construction');

      list.insert(2, 13);
      QUnit.deepEqual(sorted.asArray(), [1, 4, 3, 8, 100, 3, 4, 5, 13],
          'zeroing sortfunction: '
              + 'insertion order is not the initial list order!');

      /*
       * 'unique' parameter
       */

      sorted = new SortedReferenceListModel(list, undefined, false);
      QUnit.deepEqual(sorted.asArray(), [1, 3, 3, 4, 4, 5, 8, 13, 100],
          'non-"unique" mode');

      sorted = new SortedReferenceListModel(list, undefined, true);
      QUnit.deepEqual(sorted.asArray(), [1, 3, 4, 5, 8, 13, 100],
          '"unique" mode');

      list.remove(3);
      QUnit.deepEqual(sorted.asArray(), [1, 4, 5, 8, 13, 100],
          'CAREFUL: remove() removes ALL references, not just the last one');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/statevaluemodel',[],function() {
  return function(QUnit, getModule) {
    var StateValueModel;

    StateValueModel = getModule('core/statevaluemodel');

    QUnit.test('StateValueModel', function() {
      var state, transitions;

      transitions = {
        a: ['b', 'c'],
        b: ['a'],
        c: []
      };

      state = new StateValueModel('a', transitions);

      QUnit.equal(state.get(), 'a', 'initial state is accepted');

      state.set(undefined);
      QUnit.equal(state.get(), 'a',
          'ignoring invalid state transition (undefined)');

      QUnit.equal(state.set('d'), false, 'unallowed transition ("d")');
      QUnit.equal(state.set('b'), true, 'valid state transition ("b")');
      QUnit.equal(state.get(), 'b', 'state actually transitioned');
      QUnit.equal(state.set('b'), true, 'transition to current state');
      QUnit.equal(state.set('c'), false, 'unallowed transition ("d")');
      QUnit.equal(state.set('a'), true, 'valid state transition ("a")');
      QUnit.equal(state.set('c'), true, 'valid state transition ("a")');

      QUnit.equal(state.forceState('invalidstate'), false,
          'forceState() cannot force a nonexistant state');
      QUnit.equal(state.get(), 'c', 'state is at "c"');
      QUnit.equal(state.set('a'), false, 'transition to state "a" is invalid');
      QUnit.equal(state.forceState('a'), true,
          'transition to state "a" can be enforced');
      QUnit.equal(state.get(), 'a', 'state was forced to be "a"');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/swisstournamentmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, SwissTournamentModel, TournamentModel;

    extend = getModule('lib/extend');
    SwissTournamentModel = getModule('core/swisstournamentmodel');
    TournamentModel = getModule('core/tournamentmodel');
    VectorModel = getModule('core/vectormodel');

    QUnit.test('SwissTournamentModel', function() {
      var groups, matches, votes, result, tournament;

      QUnit.ok(extend.isSubclass(SwissTournamentModel, TournamentModel),
          'SwissTournamentModel is subclass of TournamentModel');

      groups = [];
      votes = {};
      matches = [];
      tournament = new SwissTournamentModel();

      result = tournament.findSwissByesAndMatches(matches, votes, groups);
      QUnit.ok(result, 'findSwissByesAndMatches: empty groups array');

      tournament.addTeam(0);
      groups = [[0]];
      result = tournament.findSwissByesAndMatches(matches, votes, groups);
      QUnit.ok(result, 'findSwissByesAndMatches: single team');
      QUnit.deepEqual(votes.byes, [0], 'single team: correct bye');

      tournament.addTeam(1);
      tournament.addTeam(2);
      tournament.addTeam(3);
      tournament.addTeam(4);
      groups = [[1, 2, 3, 4]];
      votes = {};

      result = tournament.findSwissByesAndMatches(matches, votes, groups);
      QUnit.ok(result, 'findSwissByesAndMatches: four teams');
      QUnit.deepEqual(matches, [[1, 2], [3, 4]], 'four teams: matches');

      groups = [[0, 1, 2, 3]];
      votes = {};
      matches = [];
      tournament.ranking.resize(tournament.length);
      tournament.ranking.winsmatrix.set(2, 3, 1);
      result = tournament.findSwissByesAndMatches(matches, votes, groups);
      QUnit.ok(result, 'findSwissByesAndMatches: already played');
      QUnit.deepEqual(matches, [[0, 2], [1, 3]], 'already played: matches');

      /*
       * tournament playthroughs/starts
       */

      tournament = new SwissTournamentModel(['wins']);
      tournament.addTeam(5);
      tournament.addTeam(4);
      tournament.addTeam(3);
      tournament.addTeam(2);
      tournament.addTeam(1);
      tournament
          .setProperty('swissmode', SwissTournamentModel.MODES.individual);
      QUnit.ok(tournament.run(), 'default test tournament');

      QUnit.deepEqual(tournament.getVotes('bye').asArray(), [1], 'bye votes');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/symmetricmatrixmodel',[],function() {
  return function(QUnit, getModule) {
    var MatrixModel, SymmetricMatrixModel, extend;

    MatrixModel = getModule('core/matrixmodel');
    SymmetricMatrixModel = getModule('core/symmetricmatrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('SymmetricMatrixModel', function() {
      // constructor validation
      var a;

      QUnit.ok(extend.isSubclass(SymmetricMatrixModel, MatrixModel),
          'SymmetricMatrixModel is subclass of MatrixModel');

      a = new SymmetricMatrixModel(5);

      QUnit.equal(a.length, 5, 'length at initialization is accepted');

      QUnit.equal(a.set(0, 4, 5), a, 'set() above the main diagonal works');
      QUnit.equal(a.get(0, 4), 5, 'get() confirms the written value');
      QUnit.equal(a.get(4, 0), 5, 'get() confirms the symmetric mapping');

      QUnit.equal(a.set(2, 2, 5), a, 'set() on the main diagonal works');
      QUnit.equal(a.get(2, 2), 5, 'get() confirms the main diagonal value');

      QUnit.equal(a.set(4, 3, 3), a, 'set() below main diagonal works');
      QUnit.equal(a.get(4, 3), 3, 'get() confirms the value');
      QUnit.equal(a.get(3, 4), 3, 'get() confirms the symmetric value');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/tournamentindex',[],function() {
  return function(QUnit, getModule) {
    var TournamentIndex;

    TournamentIndex = getModule('core/tournamentindex');

    QUnit.test('TournamentIndex', function() {
      QUnit.equal(TournamentIndex.createTournament(), undefined,
          'empty construction fails');
      QUnit.equal(TournamentIndex.createTournament('undefined'), undefined,
          'undefined fails');
      QUnit.ok(TournamentIndex.createTournament('round'), 'round');
      QUnit.ok(TournamentIndex.createTournament('swiss'), 'swiss');
      QUnit.ok(TournamentIndex.createTournament('ko'), 'ko');
      QUnit.equal(TournamentIndex.createTournament('poule'), undefined,
          'poule fails');

      QUnit.equal(TournamentIndex.createTournament({}), undefined,
          'savedata-passing without "sys" property fails');
      QUnit.ok(TournamentIndex.createTournament({
        sys: 'round'
      }), 'round-tournament with savedata');
      QUnit.equal(TournamentIndex.createTournament({
        sys: 'poule'
      }), undefined, 'poule-tournament with savedata fails');

    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/tournamentlistmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, TournamentListModel, IndexedListModel, TournamentIndex;

    extend = getModule('lib/extend');
    TournamentListModel = getModule('core/tournamentlistmodel');
    TournamentIndex = getModule('core/tournamentindex');
    IndexedListModel = getModule('core/indexedlistmodel');

    QUnit.test('TournamentListModel', function() {
      var tournament, list, ref, savedata;
      QUnit.ok(extend.isSubclass(TournamentListModel, IndexedListModel),
          'TournamentListModel is subclass of IndexedListModel');

      list = new TournamentListModel();

      QUnit.ok(list, 'TournamentListModel construction works');
      QUnit.equal(list.length, 0, 'no initial entries');
      QUnit.deepEqual(list.tournamentIDsForEachTeam(), [],
          'no tournament ids yet');

      tournament = TournamentIndex.createTournament('round',
          ['sonneborn', 'id']);
      tournament.addTeam(0);
      tournament.addTeam(1);
      tournament.addTeam(2);
      tournament.addTeam(4);

      list.push(tournament);

      ref = [0, 0, 0, undefined, 0];
      QUnit.deepEqual(list.tournamentIDsForEachTeam(), ref,
          'tournament ids for single tournament are correct');

      tournament = TournamentIndex.createTournament('round',
          ['sonneborn', 'id']);
      tournament.addTeam(1);
      tournament.addTeam(3);
      tournament.addTeam(5);

      list.push(tournament);

      ref = [0, 1, 0, 1, 0, 1];
      QUnit.deepEqual(list.tournamentIDsForEachTeam(), ref,
          'tournament ids for two tournaments are correct');

      // HACK! DO NOT ACCESS DIRECTLY!
      list.get(0).state.forceState('finished');
      ref = [undefined, 1, undefined, 1, undefined, 1];
      QUnit.deepEqual(list.tournamentIDsForEachTeam(), ref,
          'ids of finished tournaments are ignored (undefined)');

      savedata = list.save();
      QUnit.ok(savedata, 'save() returns properly');

      list = new TournamentListModel();
      QUnit.ok(list.restore(savedata), 'restore() returns true');
      QUnit.deepEqual(list.tournamentIDsForEachTeam(), ref,
          'restore() restores the ids for all players');

      // TODO test getGlobalRanking()
      // TODO test closeTournament()
      // TODO test push, insert, pop, remove and erase
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/tournamentmodel',[],function() {
  return function(QUnit, getModule) {
    var extend, TournamentModel, PropertyModel;

    extend = getModule('lib/extend');
    TournamentModel = getModule('core/tournamentmodel');
    PropertyModel = getModule('core/propertymodel');

    QUnit.test('TournamentModel', function() {
      var tournament, state, teams, matches, byes, match, ranking, ref, data, //
      history, combinedHistory, corrections, result;

      QUnit.ok(extend.isSubclass(TournamentModel, PropertyModel),
          'TournamentModel is subclass of PropertyModel');

      tournament = new TournamentModel(['wins', 'saldo']);
      QUnit.ok(tournament, 'construction works');

      state = tournament.getState();
      teams = tournament.getTeams();
      matches = tournament.getMatches();
      history = tournament.getHistory();
      combinedHistory = tournament.getCombinedHistory();
      corrections = tournament.getCorrections();
      byes = tournament.getVotes('bye');
      ranking = tournament.getRanking();

      QUnit.ok(state, 'getState() returns');
      QUnit.ok(teams, 'getTeams() returns');
      QUnit.ok(matches, 'getMatches() returns');
      QUnit.ok(history, 'getHistory() returns');
      QUnit.ok(combinedHistory, 'getHistory() returns');
      QUnit.ok(corrections, 'getCorrections() returns');
      QUnit.ok(byes, 'getTeams() returns');
      QUnit.ok(ranking, 'getRanking() returns');

      QUnit.equal(state.get(), 'initial',
          'tournament is constructed in initial state');

      QUnit.equal(teams.length, 0, 'no teams registered initially');

      QUnit.equal(matches.length, 0, 'no matches in initial state');

      QUnit.equal(byes.length, 0, 'no byes in initial state');

      QUnit.equal(tournament.getVotes('unknownVoteType'), undefined,
          'undefined vote type returns undefined');

      /*************************************************************************
       * run
       ************************************************************************/

      QUnit.equal(tournament.run(), undefined,
          'run() aborts with insufficient teams');

      QUnit.equal(tournament.addTeam(5), true, 'addTeam works');
      QUnit.equal(tournament.addTeam(4), true, 'addTeam works');
      QUnit.equal(tournament.addTeam(3), true, 'addTeam works');
      QUnit.equal(tournament.addTeam(2), true, 'addTeam works');
      QUnit.equal(tournament.addTeam(1), true, 'addTeam works');

      QUnit.equal(teams.length, 5, 'teams: length gets updated');
      QUnit.equal(tournament.teams.length, 5, 'teams: length gets updated');

      QUnit.equal(tournament.getID(), -1, 'initial id is -1');
      tournament.setID(5);
      QUnit.equal(tournament.getID(), 5, 'id can be changed with setID()');

      /*************************************************************************
       * first round
       ************************************************************************/

      QUnit.equal(tournament.run(), true, 'run() works with sufficient teams');

      QUnit.equal(state.get(), 'running', 'state is set to "running"');

      QUnit.equal(matches.length, 1, 'matches have been generated');
      QUnit.equal(byes.length, 1, 'byes have been generated');

      match = matches.get(0);
      QUnit.equal(match.getTeamID(0), 5, 'global team id in match');
      QUnit.equal(match.getTeamID(1), 4, 'global team id in match');

      QUnit.equal(byes.get(0), 3, 'global team id in bye');

      QUnit.ok(match.finish([12345, -53]),
          'match.finish() with invalid score points');

      QUnit.equal(matches.length, 1, 'match has not been finished');

      QUnit.equal(history.length, 0, 'match has not been pushed to history');

      QUnit.equal(combinedHistory.length, 1,
          'combinedHistory contains an element');

      QUnit.equal(tournament.finish(), false,
          'tournament cannot be finished when there are open matches');

      QUnit.ok(match.finish([13, 7]), 'match.finish() with proper scores');

      QUnit.equal(matches.length, 0, 'match has been finished');

      QUnit.equal(history.length, 1, 'match has been pushed to history');

      result = history.get(0);
      QUnit.equal(result.length, 2, 'history: length of match matches');
      QUnit.equal(result.getTeamID(0), 5, 'history: global team id in match');
      QUnit.equal(result.getTeamID(1), 4, 'history: global team id in match');

      QUnit.equal(state.get(), 'idle',
          'auto-transition to idle state after last match');

      QUnit.equal(byes.length, 0,
          'votes are cleared before transition to idle state');

      ref = {
        components: ['wins', 'saldo'],
        ids: [5, 4, 3, 2, 1],
        ranks: [0, 4, 1, 1, 1],
        displayOrder: [0, 2, 3, 4, 1],
        wins: [1, 0, 0, 0, 0],
        saldo: [6, -6, 0, 0, 0]
      };
      QUnit.deepEqual(ranking.get(), ref, 'ranking validation');

      /*************************************************************************
       * second round
       ************************************************************************/

      QUnit.equal(tournament.run(), true, 'run() works with sufficient teams');

      QUnit.equal(state.get(), 'running', 'state is set to "running"');

      QUnit.equal(matches.length, 1, 'matches have been generated');
      QUnit.equal(byes.length, 1, 'byes have been generated');
      QUnit.equal(history.length, 1, 'history contains a match and a bye');
      QUnit.equal(combinedHistory.length, 2,
          'combined history contains a current match, '
              + 'a finished match and the current bye');

      match = matches.get(0);
      QUnit.equal(match.getTeamID(0), 4, 'global team id in match');
      QUnit.equal(match.getTeamID(1), 3, 'global team id in match');

      QUnit.equal(byes.get(0), 5, 'global team id in bye');

      QUnit.equal(matches.length, 1, 'match has not been finished');

      QUnit.ok(match.finish([13, 7]), 'match.finish() with proper scores');

      QUnit.equal(matches.length, 0, 'match has been finished');

      QUnit.equal(state.get(), 'idle',
          'auto-transition to idle state after last match');

      QUnit.equal(byes.length, 0,
          'votes are cleared before transition to idle state');

      ref = {
        components: ['wins', 'saldo'],
        ids: [5, 4, 3, 2, 1],
        ranks: [0, 1, 4, 2, 2],
        displayOrder: [0, 1, 3, 4, 2],
        wins: [1, 1, 0, 0, 0],
        saldo: [6, 0, -6, 0, 0]
      };
      QUnit.deepEqual(ranking.get(), ref, 'ranking validation');

      QUnit.equal(tournament.finish(), true, 'tournament is finished');

      QUnit.equal(tournament.run(), undefined,
          'tournament cannot be un-finished');

      QUnit.deepEqual(ranking.get(), ref, 'ranking validation');

      tournament = new TournamentModel(['wins', 'saldo']);
      tournament.addTeam(5);
      tournament.addTeam(3);
      tournament.addTeam(4);
      tournament.addTeam(2);
      tournament.addTeam(1);

      tournament.run();
      tournament.getMatches().get(0).finish([8, 13]);
      tournament.run();

      tournament.setID(3);

      data = tournament.save();
      QUnit.ok(data, 'save() finishes');
      ref = tournament;
      tournament = new TournamentModel();
      QUnit.ok(tournament.restore(data), 'restore() finishes');

      state = tournament.getState();
      teams = tournament.getTeams();
      matches = tournament.getMatches();
      history = tournament.getHistory();
      corrections = tournament.getCorrections();
      byes = tournament.getVotes('bye');
      ranking = tournament.getRanking();

      QUnit.equal(tournament.getID(), 3, 'restore() restored the id');
      QUnit.deepEqual(teams.asArray(), ref.getTeams().asArray(),
          'restore() restored the teams');
      QUnit.equal(state.get(), 'running',
          'restore() restored the "running" state');
      QUnit.equal(matches.length, 1, 'restore() restored matches.length');
      match = matches.get(0);
      QUnit.equal(match.getTeamID(0), 3, 'restore(): team id in match');
      QUnit.equal(match.getTeamID(1), 4, 'restore(): team id in match');
      QUnit.deepEqual(byes.asArray(), [5], 'restore() restored the byes');
      QUnit.deepEqual(ranking.get(), ref.getRanking().get(),
          'restore() restored the whole ranking');
      result = history.get(0);
      QUnit.equal(history.length, 1, 'restore(): history size');
      QUnit.equal(result.length, 2,
          'restore(): restored number of teams in history result');
      QUnit.equal(result.getTeamID(0), 5, 'restore() history team id 1');
      QUnit.equal(result.getTeamID(1), 3, 'restore() history team id 2');

      // FIXME test corrections
      // FIXME test history (default, after some tournaments, after
      // restore)
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/transposedifferencematrix',[],function() {
  return function(QUnit, getModule) {
    var DelegateMatrix;

    TransposeDifferenceMatrix = getModule('core/transposedifferencematrix');
    DelegateMatrix = getModule('core/delegatematrix');
    MatrixModel = getModule('core/matrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('TransposeDifferenceMatrix', function() {
      // constructor validation
      var a, m;

      QUnit.ok(extend.isSubclass(TransposeDifferenceMatrix, DelegateMatrix),
          'TransposeDifferenceMatrix is a DelegateMatrix subclass');

      m = new MatrixModel(5);
      a = new TransposeDifferenceMatrix(m);
      [0, 1, 2, 3, 4].forEach(function(row) {
        [0, 1, 2, 3, 4].forEach(function(col) {
          m.set(row, col, 12 - (row * a.length + col));
        });
      });

      QUnit.equal(a.get(0, 0), 0, 'get() on diagonal returns 0');
      QUnit.equal(a.get(3, 2), -4, 'get() returns the transpose-difference');
      QUnit.equal(a.get(0, 1), 4, 'get() returns the transpose-difference');
      QUnit.equal(a.get(2, 2), 0, 'get() on diagonal returns 0');
      QUnit.equal(a.get(4, 0), -16, 'get() returns the transpose-difference');
      QUnit.equal(a.get(0, 4), 16, 'get() is antisymmetric');

      QUnit.equal(a.get(-1, 2), undefined, 'get() out of bounds (row low)');
      QUnit.equal(a.get(2, -9), undefined, 'get() out of bounds (col low)');
      QUnit.equal(a.get(5, 3), undefined, 'get() out of bounds (row high)');
      QUnit.equal(a.get(3, 7531), undefined, 'get() out of bounds (col high)');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/transposesummatrix',[],function() {
  return function(QUnit, getModule) {
    var DelegateMatrix;

    TransposeSumMatrix = getModule('core/transposesummatrix');
    DelegateMatrix = getModule('core/delegatematrix');
    MatrixModel = getModule('core/matrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('TransposeSumMatrix', function() {
      // constructor validation
      var a, m;

      QUnit.ok(extend.isSubclass(TransposeSumMatrix, DelegateMatrix),
          'TransposeSumMatrix is a DelegateMatrix subclass');

      m = new MatrixModel(5);
      a = new TransposeSumMatrix(m);
      [0, 1, 2, 3, 4].forEach(function(row) {
        [0, 1, 2, 3, 4].forEach(function(col) {
          m.set(row, col, 12 - (row * a.length + col));
        });
      });

      QUnit.equal(a.get(0, 0), 24, 'get() on diagonal returns a twice value');
      QUnit.equal(a.get(3, 2), -6, 'get() returns the transpose-sum');
      QUnit.equal(a.get(1, 0), 18, 'get() returns the transpose-sum');
      QUnit.equal(a.get(2, 2), 0, 'get() returns the transpose-sum');
      QUnit.equal(a.get(4, 4), -24, 'get() returns the transpose-sum');

      QUnit.equal(a.get(-1, 2), undefined, 'get() out of bounds (row low)');
      QUnit.equal(a.get(2, -9), undefined, 'get() out of bounds (col low)');
      QUnit.equal(a.get(5, 3), undefined, 'get() out of bounds (row high)');
      QUnit.equal(a.get(3, 7531), undefined, 'get() out of bounds (col high)');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */

/*
 * Various Matrix Tests
 */
define('core/test/trianglematrixmodel',[],function() {
  return function(QUnit, getModule) {
    var MatrixModel, TriangleMatrixModel, extend;

    MatrixModel = getModule('core/matrixmodel');
    TriangleMatrixModel = getModule('core/trianglematrixmodel');
    extend = getModule('lib/extend');

    QUnit.test('TriangleMatrixModel', function() {
      // constructor validation
      var a;

      QUnit.ok(extend.isSubclass(TriangleMatrixModel, MatrixModel),
          'TriangleMatrixModel is subclass of MatrixModel');

      a = new TriangleMatrixModel(5);

      QUnit.equal(a.length, 5, 'length at initialization is accepted');

      QUnit.equal(a.set(0, 4, 5), undefined,
          'set() above the main diagonal aborts, leaving the value at 0');
      QUnit.equal(a.get(0, 4), 0, 'get() confirms the zero-value');

      QUnit.equal(a.set(2, 2, 5), a, 'set() on the main diagonal works');
      QUnit.equal(a.get(2, 2), 5, 'get() confirms the main diagonal value');

      QUnit.equal(a.set(4, 3, 3), a, 'set() below main diagonal works');
      QUnit.equal(a.get(4, 3), 3, 'get() confirms the value');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/type',[],function() {
  return function(QUnit, getModule) {
    var Type;

    Type = getModule('core/type');

    QUnit.test('Type', function() {
      var types, ref, functionnames, constructors;

      /*
       * Preparation
       */

      types = [];

      types.push(5);
      types.push({
        asd: 123
      });
      types.push('');
      types.push(undefined);
      types.push(null);
      types.push(new Date(1234567890123));
      types.push([1, 5, 'asd']);
      types.push(/arbitrary regex/);
      types.push(false);
      types.push(function() {
        return '3.1415';
      });

      ref = ['number', 'object', 'string', 'undefined', 'null', 'date',
          'array', 'regexp', 'boolean', 'function'];

      constructors = [Number, Object, String, undefined, null, Date, Array,
          RegExp, Boolean, Function];

      /*
       * Type()
       */

      ref.forEach(function(typename, index) {
        QUnit.equal(Type(types[index]), typename, 'Type ' + typename
            + ' detected');
      });

      functionnames = ref.map(function(typename) {
        return 'is' + [typename[0].toUpperCase() + typename.slice(1)];
      });

      /*
       * Type.is and Type.isType existance
       */

      QUnit.ok(Type.is, 'Type.is exists');
      QUnit.equal(Type(Type.is), 'function', 'Type.is() is a function');
      functionnames.forEach(function(functionname) {
        QUnit.ok(Type[functionname], 'Type.' + functionname + ' exists');
        QUnit.equal(Type(Type[functionname]), 'function', 'Type.'
            + functionname + '() is a function');
      });

      /*
       * Type.isType()
       */

      types.forEach(function(type, typeindex) {
        functionnames.forEach(function(functionname, functionindex) {
          var expected = functionindex === typeindex;
          QUnit.equal(Type[functionname](type), expected, 'Type.'
              + functionname + ' on a ' + Type(type) + ' is ' + expected);
        });
      });

      /*
       * Type.is()
       */

      types.forEach(function(type, typeindex) {
        ref.forEach(function(refname, functionindex) {
          var expected = functionindex === typeindex;
          QUnit.equal(Type.is(type, refname), expected, 'Type.is(obj, "'
              + refname + '") on a ' + Type(type) + ' is ' + expected);
        });
      });

      types.forEach(function(type, typeindex) {
        constructors.forEach(function(constructor, functionindex) {
          var expected = functionindex === typeindex;
          QUnit.equal(Type.is(type, constructor), expected, 'Type.is(obj, '
              + constructor + ') on a ' + Type(type) + ' is ' + expected);
        });
      });

    });
  };
});

/**
 * Unit tests for ListModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/uniquelistmodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, UniqueListModel, extend;

    ListModel = getModule('core/listmodel');
    UniqueListModel = getModule('core/uniquelistmodel');
    extend = getModule('lib/extend');

    QUnit.test('UniqueListModel', function() {
      var list;

      QUnit.ok(extend.isSubclass(UniqueListModel, ListModel),
          'UniqueListModel is subclass of ListModel');

      list = new UniqueListModel();

      QUnit.equal(list.push(1), 1, 'push works');
      QUnit.equal(list.push(2), 2, 'push works');
      QUnit.equal(list.push(1), undefined, 'push aborts');
      QUnit.equal(list.push(3), 3, 'push works');
      QUnit.equal(list.push(1), undefined, 'push aborts');
      QUnit.equal(list.push(5), 4, 'push works');
      QUnit.equal(list.push(1), undefined, 'push aborts');
      QUnit.deepEqual(list.asArray(), [1, 2, 3, 5], 'push() inserts once');

      QUnit.equal(list.set(2, 1), undefined, 'set aborts');
      QUnit.deepEqual(list.asArray(), [1, 2, 3, 5], 'set() does not remove');

      QUnit.equal(list.set(2, 4), 4, 'set works');
      QUnit.deepEqual(list.asArray(), [1, 2, 4, 5], 'set() still works');

      QUnit.equal(list.insert(2, 1), undefined, 'insert aborts');
      QUnit.deepEqual(list.asArray(), [1, 2, 4, 5], 'insert() doesnt insert');

      QUnit.equal(list.insert(2, 3), 3, 'insert still works');
      QUnit.deepEqual(list.asArray(), [1, 2, 3, 4, 5], 'insert() still works');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/valuemodel',[],function() {
  return function(QUnit, getModule) {
    var ValueModel;

    ValueModel = getModule('core/valuemodel');

    QUnit.test('ValueModel', function() {
      var model, listener, obj, model2;

      listener = {
        lastdata: undefined,
        updatecount: 0,
        onupdate: function(emitter, event, data) {
          listener.updatecount += 1;
          listener.lastdata = data;
        },
        emitters: []
      };

      model = new ValueModel();
      QUnit.equal(model.get(), undefined, 'default value: undefined');

      model = new ValueModel(5);
      QUnit.equal(model.get(), 5, 'accepting numeric default values');

      model = new ValueModel(0);
      QUnit.equal(model.get(), 0, 'accepting 0 as a default value');

      model.registerListener(listener);
      model.set(12345);
      QUnit.equal(model.get(), 12345, 'set() sets a new value');
      QUnit.equal(listener.updatecount, 1, 'set() fires an update event');

      model.set(12345);
      QUnit.equal(model.get(), 12345, 'set() retains the old value');
      QUnit.equal(listener.updatecount, 1,
          'set() does not update if values match');

      model.set('12345');
      QUnit.equal(model.get(), '12345', 'set() updates on type mismatch');
      QUnit.equal(listener.updatecount, 2, 'set() type mismatch: fire update');

      obj = {};
      model.set(obj);
      QUnit.equal(model.get(), obj, 'set(): objects are referenced directly');

      model2 = new ValueModel();
      model = new ValueModel();
      model.bind(model2);

      model2.set(5);
      QUnit.equal(model.get(), 5, 'bind(): works with numbers');

      obj = {};
      model2.set(obj);
      QUnit.equal(model.get(), obj, 'bind(): works with object references');

      model2.bind(model);
      model.set(11);
      QUnit.equal(model.get(), 11, 'cyclic bind(): model A');
      QUnit.equal(model2.get(), 11, 'cyclic bind(): model B');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('core/test/vectormodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, VectorModel, extend;

    extend = getModule('lib/extend');
    ListModel = getModule('core/listmodel');
    VectorModel = getModule('core/vectormodel');

    QUnit.test('VectorModel', function() {
      var vec, vec2, retvec, ref, success, data;

      QUnit.ok(extend.isSubclass(VectorModel, ListModel),
          'VectorModel is subclass of ListModel');

      vec = new VectorModel();

      QUnit.equal(vec.length, 0, 'empty initialization: length is 0');

      vec.resize(123);
      QUnit.equal(vec.length, 123, 'resize() expands to the wanted length');

      QUnit.equal(vec.get(0), 0, 'resize() fills with 0 (beg)');
      QUnit.equal(vec.get(55), 0, 'resize() fills with 0 (mid)');
      QUnit.equal(vec.get(122), 0, 'resize() fills with 0 (end)');

      vec.resize(5);
      QUnit.equal(vec.length, 5, 'resize() crops to the wanted length');
      QUnit.equal(vec.get(122), undefined,
          'get() reads removed elements as undefined');

      vec.resize(-5);
      QUnit.equal(vec.length, 0,
          'resize() to negative number crops to length 0');

      vec = new VectorModel(10);

      QUnit.equal(vec.sum(), 0, 'sum() of an empty/new vector is 0');

      vec.push(1);
      vec.push(2);
      vec.push(3);
      vec.push(4);
      vec.push(5);
      vec.push(6);
      vec.push(7);
      vec.push(8);

      QUnit.equal(vec.sum(), 36, 'sum() returns the correct sum');

      retvec = new VectorModel();
      vec2 = new VectorModel(vec.length);
      vec2.map(function(elem, index) {
        vec2.set(index, index);
      });

      QUnit.equal(retvec.mult(vec, vec2), retvec, 'mult does not fail');
      QUnit.equal(retvec.length, 18, 'mult resizes target');
      ref = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 22, 36, 52, 70, 90, 112, 136];
      QUnit.deepEqual(retvec.asArray(), ref,
          'mult calculates the vector product');

      QUnit.equal(retvec.mult(vec), retvec, 'mult with one argument');
      ref = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 44, 108, 208, 350, 540, 784,
          1088];
      QUnit.deepEqual(retvec.asArray(), ref,
          'mult calculates the vector product');

      QUnit.equal(vec.dot(vec2), 528, 'dot() calculates the dot product');

      retvec.resize(0);
      QUnit.equal(retvec.add(vec, vec2), retvec, 'add() returns the vector');
      QUnit.equal(retvec.length, 18, 'add() resizes the target vector');
      ref = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 17, 19, 21, 23, 25];
      QUnit.deepEqual(retvec.asArray(), ref, 'add calculates the element sum');

      // resize, so ref does not exceed the line length. This is pretty
      // stupid,
      // but this is not a stress test anyhow.
      vec2.resize(15);
      retvec.resize(15);

      QUnit.equal(retvec.add(vec2), retvec, 'add() returns the vector');
      ref = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 21, 24, 27, 30, 33];
      QUnit.deepEqual(retvec.asArray(), ref, 'add calculates element sum');

      retvec.fill();
      ref = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      QUnit.deepEqual(retvec.asArray(), ref, 'fill() resets the contents');

      retvec.fill(5);
      ref = [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      QUnit.deepEqual(retvec.asArray(), ref, 'fill(5) sets the contents');

      vec = new VectorModel(5);
      vec.set(0, 5);
      vec.set(1, 4);
      vec.set(2, 3);
      vec.set(3, 2);
      vec.set(4, 1);

      success = false;
      try {
        vec2.mult(vec, 5);
      } catch (e) {
        success = true;
      }
      QUnit.ok(success, 'mult(VectorModel, Number) aborts as intended');

      success = true;
      try {
        vec2.mult(5, vec);
      } catch (e2) {
        success = false;
      }
      QUnit.ok(success, 'mult(Number, VectorModel) aborts as intended');
      ref = [25, 20, 15, 10, 5];
      QUnit.deepEqual(vec2.asArray(), ref, 'mult(Number) works properly');

      success = true;
      try {
        vec.mult(5);
      } catch (e) {
        success = false;
      }
      QUnit.ok(success, 'mult(Number, VectorModel) aborts as intended');
      ref = [25, 20, 15, 10, 5];
      QUnit.deepEqual(vec.asArray(), ref, 'mult(Number) works properly');

      /*
       * save()/restore()
       */

      vec = new VectorModel();
      vec2 = new VectorModel(15);
      vec.push(5);
      vec.push(3);
      vec.push(4);
      vec.push(1);
      vec.push(2);
      data = vec.save();
      QUnit.ok(data, 'save() does seem to work');
      QUnit.equal(vec2.restore(data), true, 'restore() works');
      QUnit.deepEqual(vec2.asArray(), [5, 3, 4, 1, 2],
          'restored values are correct');

      vec = new VectorModel();
      vec.push(0);
      vec.push(0);
      vec.push(1);
      vec.push(0);
      vec.push(0);
      data = vec.save();
      vec = new VectorModel();
      vec.restore(data);
      QUnit.deepEqual(vec.asArray(), [0, 0, 1, 0, 0],
          'no undefined values in the array');
    });
  };
});

/**
 * Unit tests for KeyModel
 *
 * @return test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/test/keymodel',[],function() {
  return function(QUnit, getModule) {
    var extend, KeyModel, Model, Presets;

    extend = getModule('lib/extend');
    KeyModel = getModule('timemachine/keymodel');
    Model = getModule('core/model');
    Presets = getModule('presets');

    QUnit.test('KeyModel', function() {
      var key, key2, ref, date;

      QUnit.ok(extend.isSubclass(KeyModel, Model),
          'KeyModel is subclass of Model');

      /*
       * init-key
       */

      key = KeyModel.createRoot();
      QUnit.ok(key, 'empty initialization works (init-key)');
      QUnit.ok(key.toString(), 'init-key serialization works');
      QUnit.ok(key.startDate, 'init-key startDate is set');
      QUnit.ok(key.saveDate, 'init-key saveDate is set');
      QUnit.equal(key.startDate, key.saveDate, 'init-key dates match');
      QUnit.equal(key.target, Presets.target, 'init-key target matches');

      QUnit.equal(KeyModel.isValidKey(key.toString()), true,
          'serialized init-key is a valid key');
      QUnit.equal(key.isRoot(), true,
          'init-key is an init key');
      QUnit.equal(key.isRelated(key), true,
          'init-key is actually related to itself');
      QUnit.equal(key.isRelated(key.toString()), true,
          'key string is related to itself');

      QUnit.equal(key.isEqual(key), true, 'key is equal to itself');
      QUnit.equal(key.isEqual(key.toString()), true,
          'key string is equal to itself');

      date = new Date(key.startDate);
      QUnit.ok(date, 'startDate can be converted to an instance of Date');
      QUnit.equal(date.toISOString(), key.startDate,
          'Date conversion is fully reversible');

      /*
       * save-keys
       */

      key2 = KeyModel.createChild(key);

      QUnit.ok(key2, 'reference initialization works (save-key)');
      QUnit.ok(key2.toString(), 'save-key serialization works');
      QUnit.ok(key2.startDate, 'save-key startDate is set');
      QUnit.ok(key2.saveDate, 'save-key saveDate is set');
      QUnit.equal(key2.target, Presets.target,
          'save-key target matches current target');
      QUnit.notEqual(key2.startDate, key2.saveDate,
          'save-key dates are not equal');
      QUnit.equal(key2.startDate, key.startDate,
          'both keys have the same start date');

      date = new Date(key.saveDate);
      QUnit.ok(date, 'saveDate can be converted to an instance of Date');
      QUnit.equal(date.toISOString(), key.saveDate,
          'Date conversion is fully reversible');

      QUnit.equal(KeyModel.isValidKey(key2), true,
          'key2 is a valid key');
      QUnit.equal(key2.isRoot(), false,
          'save-key is no init key');

      QUnit.equal(key2.isEqual(key2), true, 'key2 is equal to itself');
      QUnit.equal(key2.isRelated(key2), true, 'key2 is related to itself');

      QUnit.equal(key.isRelated(key2), true, 'key is related to key2');
      QUnit.equal(key.isEqual(key2), false, 'key is not equal to key2');

      QUnit.equal(key.isRelated(key2), true, 'key is related to key2');
      QUnit.equal(key.isEqual(key2), false, 'key is not equal to key2');

      /*
       * string construction
       */

      ref = 'test_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z';
      QUnit.equal(KeyModel.isValidKey(ref), true,
          'ref is a valid key: ' + ref);
      key = KeyModel.fromString(ref);
      QUnit.ok(key, 'string-key construction works');
      QUnit.equal(key.toString(), ref, 'data is read and reconstructed as-is');
      QUnit.equal(key.isEqual(ref), true,
          'key is equal to its construction string');

      QUnit.equal(KeyModel.isValidKey(key), true,
          'string-constructed key is a valid key');
      QUnit.equal(key.isRoot(), false,
          'string-key is no init key');

      QUnit.equal(key.isEqual(key2), false, 'unrelated keys are unequal');
      QUnit.equal(key.isRelated(key2), false, 'unrelated keys are unrelated');

      /*
       * other targets
       */
      ref = 'boule_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z';
      QUnit.equal(KeyModel.isTuveroKey(ref), true,
          'cross-target key is a tuvero key: ' + ref);
      QUnit.equal(KeyModel.isValidKey(ref), false,
          'cross-target key is not valid: ' + ref);

      ref = 'basic_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z';
      QUnit.equal(KeyModel.isTuveroKey(ref), true,
          'cross-target key is a tuvero key: ' + ref);
      QUnit.equal(KeyModel.isValidKey(ref), false,
          'cross-target key is not valid: ' + ref);

      function testkey(keystring, keydescription) {
        var success = false;
        key = undefined;
        try {
          key = KeyModel.fromString(keystring);
        } catch (e) {
          success = true;
        }

        if (key || keystring === undefined) {
          success = false;
        }

        QUnit.equal(success, true, 'forbidden key is intercepted: '
            + keydescription);
      }

      QUnit.ok(Presets.target, 'test', 'Tuvero Test target is "test"');

      key = undefined;
      testkey('', 'empty key');
      testkey('test_2016-02-11T17:36:50Z_2016-02-11T18:23:02Z',
          'missing milliseconds');
      testkey('test_2016-02-11T17:36:50.012Z', 'only one date');
      testkey('test_2016-02-11T17:36:50.123_2016-02-11T18:23:02.543',
          'Z missing');
      testkey('test_20160211T17:36:50.123Z_20160211T18:23:02.543Z',
          'date delimiters missing');
      testkey('test_2016-02-11T173650.123Z_2016-02-11T182302.543Z',
          'time delimiters missing');
      testkey('test-2016-02-11T17:36:50.123Z-2016-02-11T18:23:02.543Z',
          'wrong key delimiters');
      testkey('test__2016-02-11T17:36:50.123Z__2016-02-11T18:23:02.543Z',
          'too many key delimiters');
      testkey('rotz_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z',
          'unallowed target');
      testkey('boule_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z',
          'wrong target');
      testkey('2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z',
          'target missing');
      testkey('test_2016-02-11-17:36:50.123Z_2016-02-11-18:23:02.543Z',
          'T missing');
      testkey('test-saves', 'key for another model');
      testkey('TEST_2016-02-11T17:36:50.123Z_2016-02-11T18:23:02.543Z',
          'wrong target case');
      testkey('test_2016-02-11T17:36:50.123z_2016-02-11T18:23:02.543z',
          'Z: wrong case');
      testkey('test_2016-02-11t17:36:50.123Z_2016-02-11t18:23:02.543Z',
          'T: wrong case');
    });
  };
});

/**
 * Unit tests for Query
 *
 * @return test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('timemachine/test/query',[],function() {
  return function(QUnit, getModule) {
    var Query, KeyModel, Type;

    Query = getModule('timemachine/query');
    KeyModel = getModule('timemachine/keymodel');
    Type = getModule('core/type');

    QUnit.test('Query', function() {
      var query, key, key2, key3, key4, key5, ref, date, res;

      query = new Query(Query.ALLKEYS);

      QUnit.ok(query, 'ALLKEYS construction successful');
      QUnit.ok(Type.isArray(query.filter()), 'filter() result is an array');

      query.filter().forEach(function(key) {
        var match = /test_/.test(key);
        QUnit.equal(match, true, 'saved key matches target: ' + key);
        if (match) {
          if (window.localStorage) {
            window.localStorage.removeItem(key);
          }
        }
      });

      QUnit.deepEqual(query.filter(), [],
          'ALL-query on cleared localStorage returns no results');

      ref = 'test_2016-02-12T12:10:11.591Z_2016-02-12T12:10:11.591Z';
      key = KeyModel.fromString(ref);
      key2 = KeyModel.createChild(key);

      ref = 'test_2015-06-01T19:55:12.512Z_2015-06-01T19:55:12.512Z';
      key3 = KeyModel.fromString(ref);
      ref = 'test_2015-06-01T19:55:12.512Z_2345-10-01T20:55:12.512Z';
      key4 = KeyModel.fromString(ref);

      if (window.localStorage) {
        window.localStorage.setItem(key, 'test');
        window.localStorage.setItem(key2, 'test');
        window.localStorage.setItem(key3, 'test');
        window.localStorage.setItem(key4, 'test');
      }

      ref = [key.toString(), key2.toString(), key3.toString(), key4.toString()]
          .sort();

      QUnit.deepEqual(query.filter(), ref, 'ALLKEYS returns all 4 test keys');

      query = new Query(Query.ROOTKEYS);
      QUnit.ok(query, 'ROOTKEYS construction successful');
      ref = [key.toString(), key3.toString()].sort();
      QUnit.deepEqual(query.filter(), ref, 'ROOTKEYS finds both init keys');

      query = new Query(Query.LASTKEYS);
      QUnit.ok(query, 'LASTKEYS construction successful');
      ref = [key2.toString(), key4.toString()].sort();
      QUnit.deepEqual(query.filter(), ref, 'LASTKEYS finds both last saves');

      query = new Query(//
      Query.LATESTSAVE);
      QUnit.ok(query, 'LATESTKEYS construction successful');
      ref = [key4.toString()].sort();
      QUnit.deepEqual(query.filter(), ref, 'LATESTSAVE finds the latest save');

      ref = [key.toString(), key2.toString()].sort();
      query = new Query(key);
      QUnit.ok(query, 'construction from key successful');
      QUnit.deepEqual(query.filter(), ref, 'successful related-keys query 1');
      query = new Query(key2);
      QUnit.ok(query, 'construction from key2 successful');
      QUnit.deepEqual(query.filter(), ref, 'successful related-keys query 2');

      ref = [key3.toString(), key4.toString()].sort();
      query = new Query(key3);
      QUnit.ok(query, 'construction from key3 successful');
      QUnit.deepEqual(query.filter(), ref, 'successful related-keys query 3');
      query = new Query(key4);
      QUnit.ok(query, 'construction from key4 successful');
      QUnit.deepEqual(query.filter(), ref, 'successful related-keys query 4');

      /*
       * cleanup
       */

      if (window.localStorage) {
        window.localStorage.removeItem(key);
        window.localStorage.removeItem(key2);
        window.localStorage.removeItem(key3);
        window.localStorage.removeItem(key4);
      }

      QUnit.deepEqual((new Query()).filter(), [],
          'ALL-query on post-test cleared localStorage returns no results');
    });
  };
});

/**
 * Unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/test/binarytreemodel',[],function() {
  return function(QUnit, getModule) {
    var extend, BinaryTreeModel, IndexedModel;

    extend = getModule('lib/extend');
    BinaryTreeModel = getModule('ui/binarytreemodel');
    IndexedModel = getModule('core/indexedmodel');

    QUnit.test('BinaryTreeModel', function() {
      var node;

      QUnit.ok(extend.isSubclass(BinaryTreeModel, IndexedModel),
          'BinaryTreeModel is subclass of IndexedModel');

      node = new BinaryTreeModel();
      QUnit.equal(node.getID(), 1, 'default ID === 1');
      QUnit.equal(node.getParentID(), 0, 'parent ID === 0');
      QUnit.equal(node.getLeftChildID(), 2, 'left child ID === 1');
      QUnit.equal(node.getRightChildID(), 3, 'right child ID === 1');
      QUnit.equal(node.getSiblingID(), 1, 'default ID === 1');
      QUnit.equal(node.getDepth(), 0, 'default depth === 0');

      node = new BinaryTreeModel(439);
      QUnit.equal(node.getID(), 439, 'ID(439) === 1');
      QUnit.equal(node.getParentID(), 219, 'parent ID(439) === 0');
      QUnit.equal(node.getLeftChildID(), 878, 'left child ID(439) === 1');
      QUnit.equal(node.getRightChildID(), 879, 'right child ID(439) === 1');
      QUnit.equal(node.getSiblingID(), 438, 'sibling ID(439) === 1');
      QUnit.equal(node.getDepth(), 8, 'Depth(439) === 0');

      node = new BinaryTreeModel(0);
      QUnit.equal(node.getID(), 0, 'default ID === 1');
      QUnit.equal(node.getParentID(), 0, 'parent ID === 0');
      QUnit.equal(node.getLeftChildID(), 1, 'left child ID === 1');
      QUnit.equal(node.getRightChildID(), 1, 'right child ID === 1');
      QUnit.equal(node.getSiblingID(), 0, 'default ID === 1');
      QUnit.equal(node.getDepth(), 0, 'default depth === 0');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/test/listcollectormodel',[],function() {
  return function(QUnit, getModule) {
    var ListModel, ListCollectorModel, ValueModel;

    ValueModel = getModule('core/valuemodel');
    ListModel = getModule('core/listmodel');
    ListCollectorModel = getModule('ui/listcollectormodel');

    QUnit.test('ListCollectorModel', function() {
      var model, list, listener, obj;

      listener = {
        updatecount: 0,
        onupdate: function() {
          listener.updatecount += 1;
        },
        emitters: []
      };

      list = new ListModel();
      model = new ListCollectorModel(list, ValueModel);
      model.registerListener(listener);

      QUnit.equal(model.emitters.length, 0, 'starting without any emitters');

      list.push(new ValueModel());

      QUnit.equal(model.emitters.length, 1, 'automatically adding emitters');

      list.get(0).set(5);
      QUnit.equal(listener.updatecount, 1,
          'recieving update events from inside the list');

      obj = list.pop();
      QUnit.equal(model.emitters.length, 0,
          'unregistering from emitters when they are removed from the list');
      return;

      listener.updatecount = 0;
      obj.set(8);
      QUnit.equal(listener.updatecount, 0,
          'removed emitters are unregistered from');

      list.push(obj);
      list.push(obj);
      list.push(obj);
      listener.updatecount = 0;
      obj.set(13);
      QUnit.equal(listener.updatecount, 1,
          'events of multiply inserted emitters are re-emitted exactly once');

      list.pop();
      listener.updatecount = 0;
      obj.set(20);
      QUnit.equal(listener.updatecount, 1,
          'not unregistering a multiply inserted element if removed once');
    });
  };
});

/**
 * Unit tests for PlayerModel
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/test/playermodel',[],function() {
  return function(QUnit, getModule) {
    var PlayerModel;

    PlayerModel = getModule('ui/playermodel');

    // TODO test the emitted events

    QUnit.test('PlayerModel', function() {
      var model, res, ref, listener;

      listener = {
        updatecount: 0,
        /**
         * Callback listener
         */
        onupdate: function() {
          listener.updatecount += 1;
        },
        /**
         * counter reset
         */
        reset: function() {
          listener.updatecount = 0;
        },
        emitters: []
      };

      model = new PlayerModel();
      model.registerListener(listener);

      ref = PlayerModel.NONAME;
      res = model.getName();
      QUnit.equal(res, ref, 'initialization without argument');

      model.setName('');
      ref = PlayerModel.NONAME;
      res = model.getName();
      QUnit.equal(res, ref, 'empty setName');
      QUnit.equal(listener.updatecount, 0, 'empty setName, no update event emitted');

      model.setName('asd');
      ref = 'asd';
      res = model.getName();
      QUnit.equal(res, ref, 'proper setName');
      QUnit.equal(listener.updatecount, 1, 'proper setName, update event emitted');

      listener.reset();
      model.setName('\r\n \tdsa \t\r\n');
      ref = 'dsa';
      res = model.getName();
      QUnit.equal(res, ref, 'setName, auto-removing trailing/leading whitespaces');
      QUnit.equal(listener.updatecount, 1, 'setName whitespace, update event emitted');

      listener.reset();
      model.setName(' dsa ');
      QUnit.equal(listener.updatecount, 0, 'setName whitespace, no update event emitted if contained text matches');

      listener.reset();
      model.setName('asd    \t\n\r\n\t   dsa');
      ref = 'asd dsa';
      res = model.getName();
      QUnit.equal(res, ref, 'setName, auto-removing multiple whitespaces inside the name');
      QUnit.equal(listener.updatecount, 1, 'setName multiple whitespace, update event emitted');

      model = new PlayerModel('\tlorem  ipsum\tdolor  sit \t\namet\r\n\t ');
      ref = 'lorem ipsum dolor sit amet';
      res = model.getName();
      QUnit.equal(res, ref, 'initialization with a lot of white spaces');

      model = new PlayerModel('\t  \t   \t\n\t\r\n\t ');
      ref = PlayerModel.NONAME;
      res = model.getName();
      QUnit.equal(res, ref, 'initialization with only white spaces');

      model.setName('asd dsa');
      res = model.getName();
      res[1] = 'W';
      res = model.getName();
      ref = 'asd dsa';
      QUnit.equal(res, ref, 'getName: returned value is a copy, not a reference');
    });
  };
});

/**
 * Unit tests for TeamModel
 *
 * @return test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/test/teammodel',[],function() {
  return function(QUnit, getModule) {
    var extend, TeamModel, PlayerModel, IndexedModel;

    extend = getModule('lib/extend');
    TeamModel = getModule('ui/teammodel');
    IndexedModel = getModule('core/indexedmodel');
    PlayerModel = getModule('ui/playermodel');

    QUnit.test('TeamModel', function() {
      var team, players, names, listener;

      QUnit.ok(extend.isSubclass(TeamModel, IndexedModel),
          'TeamModel is subclass of IndexedModel');

      listener = {
        updatecount: 0,
        /**
         * Callback listener
         */
        onupdate: function() {
          listener.updatecount += 1;
        },
        /**
         * counter reset
         */
        reset: function() {
          listener.updatecount = 0;
        },
        emitters: []
      };

      team = new TeamModel();
      QUnit.equal(team.length, 1,
          'empty initialization generates an empty team player');
      QUnit.equal(team.getPlayer(0).getName(), PlayerModel.NONAME,
          'empty initialization generates an default team player name');
      QUnit.equal(team.getID(), -1, 'empty initialization sets id to -1');

      QUnit.equal(team.getPlayer(-1), undefined,
          'getPlayer(-1) returns undefined');
      QUnit.equal(team.getPlayer(5), undefined,
          'out of bounds getPlayer returns undefined');

      names = ['Erik E. Lorenz', 'Fabian Böttcher', 'Detlef Schwede'];
      players = [new PlayerModel(names[0]), new PlayerModel(names[1]),
          new PlayerModel(names[2])];
      team = new TeamModel(players, 5);

      QUnit.equal(team.length, players.length,
          'proper initialization: team length');
      QUnit.equal(team.getID(), 5, 'proper initialization sets id');
      QUnit.equal(team.getPlayer(0).getName(), names[0], 'player name 1');
      QUnit.equal(team.getPlayer(1).getName(), names[1], 'player name 2');
      QUnit.equal(team.getPlayer(2).getName(), names[2], 'player name 3');

      team.registerListener(listener);

      listener.reset();
      players[0].setName('Generic Name');
      players[1].setName('Another Generic Name');
      players[2].setName('Third Generic Name');
      QUnit.equal(listener.updatecount, 3,
          'player name updates propagate through to TeamModel');
    });
  };
});

/**
 * unit tests
 *
 * @return a test function
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
define('ui/test/teamsfileloadcontroller',[],function() {
  return function(QUnit, getModule) {
    var TeamsFileLoadController, ValueModel;

    TeamsFileLoadController = getModule('ui/teamsfileloadcontroller');
    ValueModel = getModule('core/valuemodel');

    QUnit.test('TeamsFileLoadController', function() {
      var input, output, reference, teamsize;

      teamsize = new ValueModel(0);

      /*
       * Single Teams
       */
      input = '';
      reference = [];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'empty string');

      input = '\n';
      reference = [];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'empty line');

      input = 'Erik';
      reference = [['Erik']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'single line');

      input = '"Erik"';
      reference = [['Erik']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'quoted single line');

      input = '""';
      reference = [];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'quoted empty line');

      input = '"Erik ""Doublequote"" Lorenz"';
      reference = [['Erik "Doublequote" Lorenz']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'quoted double-quote');

      input = '"Lorenz, Erik E."';
      reference = [['Lorenz, Erik E.']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'quoted single line with a comma');

      input = '    Erik   ';
      reference = [['Erik']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'space-padded single line');

      input = 'Erik, Fabe';
      reference = [['Erik', 'Fabe']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'two players, one team');

      input = '"Erik, Fabe"';
      reference = [['Erik, Fabe']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'quoted two-player line, one name');

      input = '"Erik", "Fabe"';
      reference = [['Erik', 'Fabe']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'two quoted players');

      /*
       * Multiple Teams
       */
      input = 'Erik\nFabe';
      reference = [['Erik'], ['Fabe']];
      output = TeamsFileLoadController.parseCSVString(input);
      QUnit.deepEqual(output, reference, 'two lines');

      /*
       * Teamsizes
       */
      input = [];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 0,
          'no team -> error');

      input = [[]];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 0,
          'empty team -> error');

      input = [['asd'], []];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 0,
          'empty team among others -> error');

      input = [['asd'], ['dsa', 'sdf']];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 0,
          'different team sizes -> error');

      input = [['asd'], ['dsa'], ['sdf']];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 1,
          'teamsize == 1');

      input = [['asd', 'dsa'], ['sdf', 'fds'], ['fda', 'fad']];
      QUnit.equal(TeamsFileLoadController.readTeamsize(input), 2,
          'teamsize == 2');
    });
  };
});

/**
 * Run every available test
 *
 * This file is automatically created on build. Do not attempt manual changes
 *
 * @author Erik E. Lorenz <erik.e.lorenz@gmail.com>
 * @license MIT License
 * @see LICENSE
 */
require(['config'], function() {
  require(['core/config'], function() {
    require(['core/common', 'qunit',
  'core/test/absolutematrix',
  'core/test/antisymmetricmatrixmodel',
  'core/test/binningreferencelistmodel',
  'core/test/byeresult',
  'core/test/combinedreferencelistmodel',
  'core/test/correctionmodel',
  'core/test/correctionreferencemodel',
  'core/test/delegatematrix',
  'core/test/emitter',
  'core/test/indexedlistmodel',
  'core/test/indexedmodel',
  'core/test/kotournamentmodel',
  'core/test/lengthmodel',
  'core/test/listener',
  'core/test/listmodel',
  'core/test/listupdatelistener',
  'core/test/maplistmodel',
  'core/test/matchmodel',
  'core/test/matchreferencemodel',
  'core/test/matchresult',
  'core/test/matrixmodel',
  'core/test/model',
  'core/test/orderlistmodel',
  'core/test/positivematrix',
  'core/test/propertymodel',
  'core/test/propertyvaluemodel',
  'core/test/random',
  'core/test/rankingcomponentindex',
  'core/test/rankingdatalistenerindex',
  'core/test/rankingheadtohead',
  'core/test/rankingmapper',
  'core/test/rankingmodel',
  'core/test/rankingsonneborn',
  'core/test/rankingtac',
  'core/test/readonlylistmodel',
  'core/test/referencelistmodel',
  'core/test/resultreferencemodel',
  'core/test/rle',
  'core/test/roundtournamentmodel',
  'core/test/selectionvaluemodel',
  'core/test/sortedreferencelistmodel',
  'core/test/statevaluemodel',
  'core/test/swisstournamentmodel',
  'core/test/symmetricmatrixmodel',
  'core/test/tournamentindex',
  'core/test/tournamentlistmodel',
  'core/test/tournamentmodel',
  'core/test/transposedifferencematrix',
  'core/test/transposesummatrix',
  'core/test/trianglematrixmodel',
  'core/test/type',
  'core/test/uniquelistmodel',
  'core/test/valuemodel',
  'core/test/vectormodel',

  'timemachine/test/keymodel',
  'timemachine/test/query',
  'ui/test/binarytreemodel',
  'ui/test/listcollectormodel',
  'ui/test/playermodel',
  'ui/test/teammodel',
  'ui/test/teamsfileloadcontroller'
], function(Common, QUnit) {
          var i;
          for (i = 2; i < arguments.length; i += 1) {
            try {
              arguments[i](QUnit, Common);
            } catch (e) {
              QUnit.test('Loading Error', function() {
                var source = e.stack.split('\n')[2].replace(/^ *at */, '')
                  .replace(/\?bust=[0-9]*/, '');
                console.error(e.message);
                console.error(source);
                QUnit.ok(false, 'cannot load module ' +
                  e.message.match(/"[^"]+"/) + '. Possible typo?\n' +
                  source);
              });
            }
          }
          QUnit.load();
          QUnit.start();
        });
  });
});

define("test", function(){});

