<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - scripts/ui/tournaments.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>scripts/ui/tournaments.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">330</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">88.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">2.32</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * A list of all subtournaments, their teams, types, ids, rankings, and
 * relationships after splitting or merging
 *
 * @return Tournaments
 * @implements ../backend/blobber
 * @author Erik E. Lorenz &lt;erik.e.lorenz@gmail.com&gt;
 * @license MIT License
 * @see LICENSE
 */
define([&#039;../backend/swisstournament&#039;, &#039;../backend/kotournament&#039;, &#039;./team&#039;, &#039;./shared&#039;], function(Swisstournament, KOTournament, Team, Shared) {
  var Tournaments, tournaments, globalranking;

  Tournaments = {};
  tournaments = [];

  function createTournament(type, blob) {
    var tournament;

    tournament = undefined;
    if (!type) {
      return undefined;
    }

    switch (type) {
    case &#039;swiss&#039;:
      tournament = new Swisstournament();
      break;
    case &#039;ko&#039;:
      tournament = new KOTournament();
      break;
    default:
      console.error(&#039;undefined tournament type: &#039; + type);
      break;
    }

    if (blob) {
      tournament.fromBlob(blob);
    }

    return tournament;
  }

  Tournaments.getStartRank = function(tournamentid, countchildren) {
    var id, parentid, startteam;

    if (tournamentid == undefined) {
      startteam = 0;
      parentid = undefined;
    } else {
      if (tournaments[tournamentid] === undefined) {
        // must be an error or the root node
        console.error(&#039;tournamentid not defined: &#039; + tournamentid);
        return undefined;
      }

      if (countchildren) {
        parentid = tournamentid;
      } else {
        parentid = tournaments[tournamentid].parent;
      }
      if (parentid == undefined) {
        startteam = 0;
      } else {
        // recursive functions FTW!
        startteam = Tournaments.getStartRank(parentid);
      }
    }

    for (id in tournaments) {
      if (tournaments[id].parent == parentid &amp;&amp; (countchildren || tournamentid === undefined || id &lt; tournamentid)) {
        startteam += tournaments[id].teams.length;
      }
    }

    return startteam;
  };

  Tournaments.numTeamsLeft = function(tournamentid) {
    var numteams, id;

    if (tournamentid === undefined) {
      numteams = Team.count();
    } else {
      if (tournaments[tournamentid] === undefined) {
        // must be an error
        console.error(&#039;tournament id not defined: &#039; + tournamentid);
        return 0;
      }
      numteams = tournaments[tournamentid].teams.length;
    }

    for (id in tournaments) {
      if (tournaments[id].parent == tournamentid) {
        numteams -= tournaments[id].teams.length;
      }
    }

    return numteams;
  };

  Tournaments.addTournament = function(type, numteams, parent) {
    var newtournament, i, teams, startteam, globalranking;

    teams = [];

    newtournament = createTournament(type);

    if (!newtournament) {
      return undefined;
    }

    startteam = Tournaments.getStartRank(parent, true);

    if (numteams &gt; Tournaments.numTeamsLeft(parent)) {
      console.error(&#039;you want too many teams in your tournament&#039;);
      return undefined;
    }

    globalranking = Shared.GlobalRanking.get();

    console.log(startteam);

    for (i = 0; i &lt; numteams; i += 1) {
      teams.push(globalranking[i + startteam].teamid);
      newtournament.addPlayer(globalranking[i + startteam].teamid);
    }

    // TODO verify parent number type / undefined

    tournaments.push({
      name: type,
      type: type,
      tournament: newtournament,
      teams: teams,
      parent: parent,
      finalranking: undefined
    });

    return newtournament;
  };

  Tournaments.removeTournament = function(tournamentid) {
    var tournament;

    tournament = tournaments[tournamentid];
    if (!tournament || !tournament.tournament) {
      console.error(&#039;tournament already removed?&#039;);
      return undefined;
    }

    tournaments[tournamentid].finalranking = tournament.tournament.getRanking();
    tournaments[tournamentid].tournament = undefined;

    return true;
  };

  Tournaments.getParent = function(tournamentid) {
    return tournaments[tournamentid] &amp;&amp; tournaments[tournamentid].parent;
  };

  /**
   * performs an inefficient left-traversal of the tournament tree and returns
   * the ranking order (left-right-parent)
   *
   * @return an array with tournament ids, sorted by their logical global
   *          ranking order
   */
  Tournaments.getRankingOrder = function() {
    var queue, order, i, parent, children;

    queue = [undefined];

    while (queue.length) {
      parent = queue.shift();

      children = [];
      for (i = 0; i &lt; tournaments.length; i += 1) {
        if (tournaments[i].parent == parent) {

          if (queue.indexOf(i) &gt; -1) {
            console.error(&#039;already visited: &#039; + i);
          }

          children.push(i);
          queue.push(i);
        }
      }

      if (!order) {
        order = children;
      } else {
        i = order.indexOf(parent);
        if (i === -1) {
          console.error(&#039;parent id not found in index&#039;);
        }
        while (children.length) {
          order.splice(i, 0, children.pop());
        }
      }
    }

    return order;
  };

  Tournaments.numTournaments = function() {
    return tournaments.length;
  };

  Tournaments.setName = function(id, name) {
    tournaments[id].name = name;
  };

  Tournaments.getName = function(id) {
    return tournaments[id] &amp;&amp; tournaments[id].name;
  };

  Tournaments.getType = function(id) {
    return tournaments[id] &amp;&amp; tournaments[id].type;
  };

  Tournaments.getTeams = function(id) {
    return tournaments[id] &amp;&amp; tournaments[id].teams;
  };

  Tournaments.getRanking = function(tournamentid) {
    var tournament;

    tournament = tournaments[tournamentid];

    if (!tournament) {
      console.error(&#039;tournamentid doesnt exist: &#039; + tournamentid);
      return undefined;
    }

    return (tournament.tournament &amp;&amp; tournament.tournament.getRanking()) || tournament.finalranking;
  };

  Tournaments.getTournament = function(id) {
    if (!tournaments[id]) {
      return undefined;
    }
    return tournaments[id].tournament;
  };

  Tournaments.getTournamentID = function(Tournament) {
    var tournamentid;

    for (tournamentid = 0; tournamentid &lt; tournaments.length; tournamentid += 1) {
      if (tournaments[tournamentid].tournament &amp;&amp; tournaments[tournamentid].tournament == Tournament) {
        return tournamentid;
      }
    }

    return undefined;
  };

  Tournaments.isRunning = function(id) {
    return tournaments[id] &amp;&amp; tournaments[id].tournament != undefined;
  };

  /**
   * ends a tournament and removes its instance from this object
   *
   * @param id
   * @return true on success, undefined otherwise
   */
  Tournaments.endTournament = function(id) {
    // set the tournament to undefined, and it will be garbage collected.
    // the entry itself will remain
    var tournament, ranking;

    tournament = tournaments[id];

    if (!tournament.tournament) {
      console.error(&#039;cannot remove tournament #&#039; + id + &#039;: invalid index&#039;);
      return undefined;
    }

    if (tournament.tournament.getGames().length != 0) {
      console.error(&#039;cannot remove tournament #&#039; + id + &#039;: there are still open games&#039;);
      return undefined;
    }

    ranking = tournament.tournament.end();

    if (!ranking) {
      console.error(&#039;cannot remove tournament #&#039; + id + &#039;: tournament can not be ended&#039;);
      return undefined;
    }

    // finally: remove the tournament
    tournament.tournament = undefined;

    return true;
  };

  Tournaments.toBlob = function() {
    var ob, id, t;

    ob = [];

    for (id = 0; id &lt; tournaments.length; id += 1) {
      t = tournaments[id];
      ob[id] = [t.type, t.name, t.tournament &amp;&amp; t.tournament.toBlob(),
          t.teams, t.finalranking, t.parent];
    }

    return JSON.stringify(ob);
  };

  Tournaments.fromBlob = function(blob) {
    var ob, id, t;

    ob = JSON.parse(blob);

    Tournaments.reset();

    tournaments = [];

    for (id = 0; id &lt; ob.length; id += 1) {
      t = ob[id];
      tournaments.push({
        type: t[0],
        name: t[1],
        tournament: (t[2] &amp;&amp; createTournament(t[0], t[2])),
        teams: t[3],
        finalranking: t[4],
        parent: t[5]
      });
    }
  };

  Tournaments.reset = function() {
    tournaments = [];
  };

  Shared.Tournaments = Tournaments;
  return Tournaments;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
