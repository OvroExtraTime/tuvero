<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - legacy/scripts/timemachine/reflog.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>legacy/scripts/timemachine/reflog.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">66.61</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">496</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.95</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">3.04</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * RefLogModel: A reference log of storage keys.
 *
 * RefLogModel does not use ValueModel, ListModel and the like because it has to
 * be periodically synchronized between multiple instances, and because the
 * Model.save() mechanism isn&#039;t sophisticated enough for the data object due to
 * its usage of dynamic keys.
 *
 * Instead, a 2D data object is used, with the startdate as the outer key and
 * the savedate as the inner key. Inside the start-object, there&#039;s a &#039;name&#039;
 * property, too. The value inner savedate-objects are the name of their
 * previous key, e.g. another savedate-key or the startdate-key. This yields a
 * tree-like structure.
 *
 * @return RefLogModel
 * @author Erik E. Lorenz &lt;erik.e.lorenz@gmail.com&gt;
 * @license MIT License
 * @see LICENSE
 */
define([&#039;lib/extend&#039;, &#039;core/model&#039;, &#039;presets&#039;, &#039;timemachine/query&#039;,
    &#039;core/listmodel&#039;, &#039;core/listener&#039;, &#039;timemachine/keymodel&#039;], function(
    extend, Model, Presets, Query, ListModel, Listener, KeyModel) {
  var RefLog;

  /**
   * Constructor of the singleton. Don&#039;t expose.
   */
  function RefLogModel() {
    RefLogModel.superconstructor.call(this);

    this.source = undefined;
    this.data = {};
    this.storageKey = this.formatTargetKey(Presets.target);

    Listener.bind(this, &#039;error&#039;, function(event, emitter, message) {
      console.error(message);
    })

    this.refresh();
  }
  extend(RefLogModel, Model);

  RefLogModel.prototype.EVENTS = {
    &#039;error&#039;: true,
    &#039;rename&#039;: true,
    &#039;refresh&#039;: true,
    &#039;reset&#039;: true
  };

  /**
   * re-read the RefLog from localStorage.
   *
   * @return true on success, false otherwise
   */
  RefLogModel.prototype.refresh = function() {
    var newSource, newData;

    newSource = window.localStorage[this.storageKey];

    if (!newSource) {
      console.log(&#039;creating new reflog&#039;);
      newSource = &#039;{}&#039;;
    } else if (this.source === newSource || newSource === &#039;undefined&#039;) {
      return true;
    }

    try {
      newData = JSON.parse(newSource);
    } catch (e) {
      console.error(e.stack);
      this.emit(&#039;error&#039;, &#039;cannot JSON-parse reflog from localStorage.&#039;);
      return false;
    }

    if (!newData) {
      this.emit(&#039;error&#039;, &#039;RefLog from localStorage contains no data.&#039;);
      return false;
    }

    this.data = newData;
    this.source = newSource;

    this.store();
    this.emit(&#039;refresh&#039;);

    return true;
  };

  /**
   * save the current reflog to localStorage.
   *
   * FIXME REALLY enable multiple parallel tournaments by just changing the
   * currently opened tournament, not others.
   */
  RefLogModel.prototype.store = function() {
    var dataString;

    if (!this.isValid()) {
      this.emit(&#039;error&#039;, &#039;RefLogModel: this.data is not valid!&#039;);
      return false;
    }

    dataString = JSON.stringify(this.data);

    window.localStorage[this.storageKey] = dataString;

    return window.localStorage[this.storageKey] === dataString;
  };

  /**
   * @return true if the reflog data is valid, false otherwise
   */
  RefLogModel.prototype.isValid = function() {
    if (!this.data) {
      return false;
    }

    // TODO check format!
    return true;
  };

  /**
   * creates a new child key under the parent key and registers it in the reflog
   *
   * @param parentKey
   *          the parent key
   * @return the new key. Returns undefined on error.
   */
  RefLogModel.prototype.newSaveKey = function(parentKey) {
    var newKey, startDate, refDate, saveDate;

    if (!parentKey) {
      this.emit(&#039;error&#039;, &#039;newSaveKey: no parent key given&#039;);
      return undefined;
    }

    newKey = KeyModel.createChild(parentKey);

    if (!parentKey.isRelated(newKey)) {
      this.emit(&#039;error&#039;, &#039;unexpected error: newKey is unrelated to parentKey&#039;);
      return undefined;
    }

    startDate = parentKey.startDate;
    refDate = parentKey.saveDate;
    saveDate = newKey.saveDate;

    if (!this.contains(parentKey)) {
      this.emit(&#039;error&#039;, &#039;newSaveKey(): parentKey is not in reflog!&#039;);
      return undefined;
    }

    this.data[startDate][saveDate] = refDate;

    this.store();

    return newKey;
  };

  /**
   * @return a new root key which hasn&#039;t been in the reflog before
   */
  RefLogModel.prototype.newInitKey = function(name) {
    var newKey;

    /*
     * Creating keys within milliseconds of another can cause rootkey collision
     *
     * Reading the reflog takes care of that.
     */
    do {
      newKey = KeyModel.createRoot();
    } while (this.contains(newKey));

    this.data[newKey.startDate] = {
      name: name
    };

    this.store();

    return newKey;
  };

  /**
   * @param refKey
   *          a reference key
   * @return true if refKey is contained in the reflog, false otherwise
   */
  RefLogModel.prototype.contains = function(refKey) {
    this.refresh();

    if (!this.data) {
      this.emit(&#039;error&#039;, &#039;reflog contains no data!&#039;);
      return false;
    }

    if (!this.data[refKey.startDate]) {
      return false;
    }

    if (refKey.isRoot()) {
      return true;
    }

    if (!this.data[refKey.startDate][refKey.saveDate]) {
      return false;
    }

    return true;
  };

  /**
   * @return a list of start dates. returns an empty array if the reflog is
   *         empty
   */
  RefLogModel.prototype.listStartDates = function() {
    this.refresh();

    if (!this.data) {
      return [];
    }

    return Object.keys(this.data).filter(KeyModel.isValidDate);
  }

  /**
   * @param startDate
   *          the start date for which to list the save dates (excluding the
   *          start date itself)
   * @return a list of save dates under the start date. Excludes the start date
   *         itself.
   */
  RefLogModel.prototype.listSaveDates = function(startDate) {
    this.refresh();

    if (!this.data || !this.data[startDate]) {
      this.emit(&#039;error&#039;, &#039;reflog does not contain start Date &#039; + startDate);
      return [];
    }

    return Object.keys(this.data[startDate]).filter(KeyModel.isValidDate);
  };

  /**
   * retrieve the name of the whole tree
   *
   * @param key
   *          a KeyModel instance
   * @return the name of the root element of the tree
   */
  RefLogModel.prototype.getName = function(key) {
    if (!this.contains(key)) {
      key = new KeyModel(key.startDate, key.startDate);
      if (!this.contains(key)) {
        this.emit(&#039;error&#039;, &#039;reflog does not contain key for name query&#039;);
        return &#039;&#039;;
      }
    }

    return this.data[key.startDate].name || &#039;&#039;;
  };

  /**
   * @param key
   *          any key of the tree for which to change the name
   * @param name
   *          the new name
   * @return true if the tree now carries the new name, false otherwise
   */
  RefLogModel.prototype.setName = function(key, name) {
    if (!this.contains(key)) {
      key = new KeyModel(key.startDate, key.startDate);
      if (!this.contains(key)) {
        this.emit(&#039;error&#039;, &#039;RefLog does not contain key for name setting&#039;);
        return false;
      }
    }

    if (name === this.getName(key)) {
      return true;
    }

    this.data[key.startDate].name = name;
    if (!this.store()) {
      this.emit(&#039;error&#039;, &#039;RefLog: store() error during name change&#039;);
      return false;
    }
    this.emit(&#039;rename&#039;, key);
    return true;
  };

  /**
   * @param refKey
   *          a KeyModel instance
   * @return a KeyModel instance of the parent key. Returns undefined if the key
   *         is a root key (has no parent)
   */
  RefLogModel.prototype.getParent = function(refKey) {
    if (!this.contains(refKey)) {
      this.emit(&#039;error&#039;, &#039;reflog does not contain key for parent search!&#039;);
      return undefined;
    }

    if (refKey.isRoot()) {
      return undefined;
    }

    return new KeyModel(refKey.startDate,
        this.data[refKey.startDate][refKey.saveDate]);
  };

  /**
   * @param refKey
   *          a parent key
   * @return an array of children. Returns an empty array if the parent key is
   *         not in the reflog
   */
  RefLogModel.prototype.getChildren = function(refKey) {
    if (!this.contains(refKey)) {
      this.emit(&#039;error&#039;, &#039;reflog does not contain key for children search&#039;);
      return [];
    }

    return this.listSaveDates(refKey.startDate).filter(function(saveDate) {
      var parentDate = this.data[refKey.startDate][saveDate];
      return parentDate === refKey.saveDate;
    }, this).map(function(saveDate) {
      return new KeyModel(refKey.startDate, saveDate);
    });
  };

  /**
   * @return an array of all keys in the reflog.
   */
  RefLogModel.prototype.getAllKeys = function() {
    var keys;

    keys = this.getInitKeys();

    this.listStartDates().forEach(function(startDate) {
      this.listSaveDates(startDate).forEach(function(saveDate) {
        keys.push(new KeyModel(startDate, saveDate));
      });
    }, this);

    return keys.sort();
  }

  /**
   * @return an array of all root keys in the reflog
   */
  RefLogModel.prototype.getInitKeys = function() {
    return this.listStartDates().sort().map(function(startDate) {
      return new KeyModel(startDate, startDate);
    });
  };

  /**
   * @return the youngest key in the whole reflog. Should be the key of the
   *         latest save state
   */
  RefLogModel.prototype.getLatestGlobalKey = function() {
    var data, latestKey;

    latestKey = this.listStartDates().map(function(startDate) {
      var saveDate = this.listSaveDates(startDate).sort().pop() || startDate;
      return new KeyModel(startDate, saveDate);
    }, this).sort(KeyModel.sortFunction).pop();

    if (!latestKey) {
      // this.emit(&#039;error&#039;, &#039;no latest key found&#039;);
      return undefined;
    }

    return latestKey;
  };

  /**
   * @param refKey
   *          a key in a tree
   * @return the youngest key in the whole tree
   */
  RefLogModel.prototype.getLatestRelatedKey = function(refKey) {
    var startDate, saveDate, latestKey, rootKey;

    if (!KeyModel.isValidKey(refKey)) {
      this.emit(&#039;error&#039;, &#039;getLatestRelatedKey(): refKey is invalid&#039;)
      return undefined;
    }

    startDate = refKey.startDate;

    if (!this.contains(refKey)) {
      rootKey = new KeyModel(startDate, startDate);
      if (!this.contains(rootKey)) {
        this.emit(&#039;error&#039;, &#039;root key is missing in reflog&#039;);
        return undefined;
      }
    }

    saveDate = this.listSaveDates(startDate).sort().pop() || startDate;

    return new KeyModel(startDate, saveDate);
  };

  /**
   * if the reflog is not empty, it&#039;s reset to an empty object. Emits &#039;remove&#039;
   */
  RefLogModel.prototype.reset = function() {
    this.refresh();

    if (!this.data) {
      this.emit(&#039;error&#039;, &#039;RefLog.reset(): data is undefined&#039;);
      this.data = {};
      return;
    }

    if (this.listStartDates().length === 0) {
      // data is already empty. Nothing to do here. (Don&#039;t overwrite storage!)
      return;
    }

    this.data = {};

    this.emit(&#039;reset&#039;);

    this.store();
  };

  /**
   * Deletes the whole tree with the startDate of refKey
   *
   * @param refKey
   *          any key in the tree, not necessarily the root key
   */
  RefLogModel.prototype.deleteTree = function(refKey) {
    if (!this.contains(refKey)) {
      if (!this.contains(new KeyModel(refKey.startDate, refKey.startDate))) {
        // Nothing to do here. It&#039;s already deleted
        return;
      }
    }

    delete this.data[refKey.startDate];

    this.store();
  };

  /**
   * Deletes a single key and sets its children&#039;s parent to its parent
   *
   * @param refKey
   *          save key. root keys cannot be deleted.
   */
  RefLogModel.prototype.deleteKey = function(refKey) {
    var parentKey, children;

    if (refKey.isRoot()) {
      this.emit(&#039;error&#039;, &#039;cannot delete a single init key. &#039;
          + &#039;use deleteTree() instead&#039;);
      return;
    }

    if (!this.contains(refKey)) {
      // this.emit(&#039;error&#039;, &#039;deleteKey(): refKey is not in reflog!&#039;);
      return;
    }

    parentKey = this.getParent(refKey);
    if (!parentKey) {
      this.emit(&#039;error&#039;, &#039;deleteKey(): parent key is not in reflog!&#039;);
      return;
    }

    children = this.getChildren(refKey);
    if (children === undefined) {
      this.emit(&#039;error&#039;, &#039;deleteKey(): Children cannot be extracted!&#039;);
      return;
    }

    children.forEach(function(child) {
      this.data[refKey.startDate][child.saveDate] = parentKey.saveDate;
    }, this);

    delete this.data[refKey.startDate][refKey.saveDate];

    this.store();
  };

  /**
   * converts the whole reflog to a single JSON string.
   *
   * @return a serialized representation of the RefLog
   */
  RefLogModel.prototype.toString = function() {
    return JSON.stringify(this.data);
  };

  /**
   * @param target
   *          a target name, e.g &#039;basic&#039; or &#039;tac&#039;
   * @return the key of the target&#039;s reflog in the localStorage
   */
  RefLogModel.prototype.formatTargetKey = function(target) {
    return target + &#039;-reflog&#039;;
  };

  /*
   * RefLog is a singleton. Since we&#039;re dealing with localStorage, it wouldn&#039;t
   * make sense to use multiple of them, anyway
   */
  RefLog = new RefLogModel();

  return RefLog;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
