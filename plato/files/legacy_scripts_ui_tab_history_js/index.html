<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - legacy/scripts/ui/tab_history.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>legacy/scripts/ui/tab_history.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1113</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">117.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.06</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * No Description
 *
 * @author Erik E. Lorenz &lt;erik.e.lorenz@gmail.com&gt;
 * @license MIT License
 * @see LICENSE
 */

define(
    [&#039;./toast&#039;, &#039;./strings&#039;, &#039;./history&#039;, &#039;./tournaments&#039;, &#039;./tab_ranking&#039;,
        &#039;../backend/game&#039;, &#039;./storage&#039;, &#039;./tabshandle&#039;, &#039;./tab&#039;, &#039;./team&#039;,
        &#039;./state_new&#039;, &#039;./shared&#039;, &#039;./boxview&#039;, &#039;./koline&#039;, &#039;options&#039;],
    function(Toast, Strings, History, Tournaments, Tab_Ranking, Game, Storage,
        Tabshandle, Tab, Team, State, Shared, BoxView, KOLine, Options) {
      var Tab_History, $tab, template, $button, gamestable;

      $button = undefined;
      $tab = undefined;
      Tab_History = undefined;
      template = undefined;
      gamestable = true;

      function formatNamesHTML(teamid) {
        var names;

        names = Team.getNames(teamid);

        if (!names) {
          return undefined;
        }

        return names.join(&#039;&lt;br&gt;&#039;);
      }

      /**
       * creates a box for a game result
       *
       * @param result
       *          a result as returned by history.getGame()
       * @param $table
       *          the DOM element to append the game to
       */
      function createGame(result, $table) {
        // fill the fields
        template.game.$teamnos[0].text(result[0] + 1);
        template.game.$teamnos[1].text(result[1] + 1);
        template.game.$names[0].html(formatNamesHTML(result[0]));
        template.game.$names[1].html(formatNamesHTML(result[1]));
        template.game.$correct.text(result[2] + &#039;:&#039; + result[3]);

        // release the box to the DOM
        $table.append(template.game.$game.clone());
      }

      /**
       * creates a box for a bye within the current round. No round
       * verification.
       *
       * @param teamid
       *          id of the team receiving a bye
       * @param $table
       *          the DOM element to append the Bye to
       */
      function createBye(teamid, $table) {
        template.bye.$teamno.text(teamid + 1);
        template.bye.$names.html(formatNamesHTML(teamid));

        $table.append(template.bye.$bye.clone());
      }

      function isInt(n) {
        return n % 1 === 0;
      }

      function verify(p1, p2) {
        return isInt(p1) &amp;&amp; isInt(p2) &amp;&amp; !isNaN(p1) &amp;&amp; !isNaN(p2) &amp;&amp; p1 !== p2
            &amp;&amp; p1 &gt;= 0 &amp;&amp; p2 &gt;= 0;
      }

      function showCorrection() {
        var points;

        // TODO somehow store the actual game id!
        points = $button.text().split(&#039;:&#039;).map(function(str) {
          return Number(str);
        });

        template.chpoints.$inputs[0].val(points[0]);
        template.chpoints.$inputs[1].val(points[1]);

        $button.after(template.chpoints.$chpoints);
        $button.detach();

        template.chpoints.$inputs[0].focus();
      }

      function abortCorrection() {
        if ($button === undefined) {
          return undefined;
        }

        template.chpoints.$chpoints.after($button);
        template.chpoints.$chpoints.detach();
        $button = undefined;

        new Toast(Strings.pointchangeaborted);
      }

      function saveCorrection() {
        // TODO validate everything:
        // * point ranges * a-z * space
        var op1, op2, np1, np2, points, t1, t2, res, game, tmp, correction, $box, tournamentid, $teams;

        if ($button === undefined) {
          return undefined;
        }

        $box = template.chpoints.$chpoints.parents(&#039;.boxview&#039;);
        if (!$box.length) {
          console.error(&#039;$box not found&#039;);
          return undefined;
        }
        tournamentid = $box.data(&#039;tournamentid&#039;);
        if (tournamentid === undefined) {
          console.error(&#039;cannot find tournamentid of $box&#039;);
          return undefined;
        }
        // retrieve values
        // TODO find better solution!
        points = $button.text().split(&#039;:&#039;).map(function(str) {
          return Number(str);
        });

        op1 = points[0];
        op2 = points[1];

        np1 = Number(template.chpoints.$inputs[0].val());
        np2 = Number(template.chpoints.$inputs[1].val());

        // verify values
        if (!verify(op1, op2) || !verify(np1, np2)) {
          new Toast(Strings.invalidresult);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        // check for equality
        if (op1 === np1 &amp;&amp; op2 === np2) {
          abortCorrection();
          return undefined;
        }

        // retrieve team ids from displayed team number
        // TODO find better solution!
        if (template.chpoints.$chpoints.parents(&#039;.gamestable&#039;).length === 1
            || template.chpoints.$chpoints.parents(&#039;.kotree&#039;).length === 1) {
          $teams = template.chpoints.$chpoints.parents(&#039;.game&#039;).find(&#039;.number&#039;);
          t1 = Number($($teams[0]).text());
          t2 = Number($($teams[1]).text());
        } else if (template.chpoints.$chpoints.parents(&#039;.progresstable&#039;).length === 1) {
          $teams = template.chpoints.$chpoints.parents(&#039;.team&#039;).find(&#039;.number&#039;);
          t1 = Number($teams.text());
          t2 = Number(template.chpoints.$chpoints.prev().text());
        } else {
          console.log(&#039;unknown tournament system for corrections&#039;);
          new Toast(Strings.invalidresult);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        if (!isInt(t1) || !isInt(t2) || isNaN(t1) || isNaN(t2)) {
          new Toast(Strings.invalidresult);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        t1 -= 1;
        t2 -= 1;

        // find the game by team ids only
        res = History.findGames(tournamentid, t1, t2);

        if (res === undefined || res.length === 0) {
          console.error(&#039;History.findGames(): Game not found&#039;);
          new Toast(Strings.invalidresult);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        if (res.length !== 1) {
          console
              .error(&#039;History.findGames() result contains more than 1 match&#039;);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        res = res[0];

        // flip team order if necessary (shouldn&#039;t be, but let&#039;s be careful)
        if (t1 === res[1]) {
          tmp = np1;
          np1 = np2;
          np2 = tmp;

          tmp = op1;
          op1 = op2;
          op2 = tmp;
        }

        // compare original points with saved ones
        if (res[2] !== op1 || res[3] !== op2) {
          new Toast(Strings.invalidresult);
          abortCorrection();
          Tab_History.update();
          return undefined;
        }

        // create Game instance (old one is already destroyed, but the backend
        // is
        // designed to not mind
        game = new Game(res[0], res[1]);

        // FIXME read the rankings from History OR Tournament, not both
        if (Tournaments.isRunning(tournamentid)) {
          if (!Tournaments.getTournament(tournamentid).correct(game,
              [op1, op2], [np1, np2])) {
            console.error(&#039;could not apply correction&#039;);
            new Toast(Strings.invalidresult);
            return undefined;
          }
        } else {
          new Toast(Strings.toolatetournamentfinished, Toast.LONG);
        }

        correction = res.slice(0);

        // store correction in history
        correction[2] = np1;
        correction[3] = np2;
        History.addCorrection(tournamentid, res, correction);

        // show correction and recalc ranking
        Tab_Ranking.update();

        // apply values to interface
        $button.text(np1 + &#039;:&#039; + np2);

        template.chpoints.$chpoints.after($button);
        template.chpoints.$chpoints.detach();
        $button = undefined;

        // save changes
        Storage.changed();

        Tab_History.update();

        new Toast(Strings.pointchangeapplied);
      }

      function initOptions() {
        var $maxwidthbox, $shownamesbox, $gamelistsbox;

        // show or hide playernames
        $maxwidthbox = $tab.find(&#039;.options .maxwidth&#039;);
        function maxwidthtest() {
          if ($maxwidthbox.prop(&#039;checked&#039;)) {
            $tab.addClass(&#039;maxwidth&#039;);
          } else {
            $tab.removeClass(&#039;maxwidth&#039;);
          }
        }

        $maxwidthbox.click(maxwidthtest);
        maxwidthtest();

        // show or hide playernames
        $shownamesbox = $tab.find(&#039;.options .shownames&#039;);
        function shownamestest() {
          if ($shownamesbox.prop(&#039;checked&#039;)) {
            $tab.removeClass(&#039;hidenames&#039;);
            $maxwidthbox.removeAttr(&#039;disabled&#039;);
          } else {
            $tab.addClass(&#039;hidenames&#039;);
            $maxwidthbox.attr(&#039;disabled&#039;, &#039;disabled&#039;);
          }

          // CHEAPHACK this is entirely unnecessary...
          Tab_History.update();
        }

        $shownamesbox.click(shownamestest);
        shownamestest();

        // use progress layout
        $gamelistsbox = $tab.find(&#039;.options .gamelists&#039;);
        function gameliststest() {
          gamestable = $gamelistsbox.prop(&#039;checked&#039;);
        }

        $gamelistsbox.click(function() {
          gameliststest();
          Tab_History.update();
        });
        gameliststest();
      }

      function initCorrection() {
        $button = undefined;

        $tab.on(&#039;click&#039;, &#039;.correct&#039;, function() {
          // abort previous correction attempts
          abortCorrection();

          $button = $(this);

          // move to the actual button, if the user clicked the span
          showCorrection();

          return false;
        });

        template.chpoints.$chpoints.submit(function(e) {
          saveCorrection();
          e.preventDefault();
          return false;
        });

        template.chpoints.$chpoints.find(&#039;.points&#039;).keydown(function(e) {
          if (e.which === 13) {
            // Enter --&gt; submit
            template.chpoints.$chpoints.find(&#039;button.change&#039;).click();
            e.preventDefault();
            return false;
          } else if (e.which === 27) {
            // Escape --&gt; abort
            template.chpoints.$chpoints.find(&#039;button.abort&#039;).click();
            e.preventDefault();
            return false;
          }
        });

        template.chpoints.$chpoints.find(&#039;button.abort&#039;).click(function(e) {
          abortCorrection();

          e.preventDefault();
          return false;
        });
      }

      function initTemplates() {
        var i, tmp;

        if (template) {
          console.error(&#039;tab_history: template already exists:&#039;);
          console.error(template);
          return;
        }

        template = {};

        // round container template
        template.$container = $tab.find(&#039;.boxview.tpl&#039;);
        template.$container.detach();
        template.$container.removeClass(&#039;tpl&#039;);

        template.kotree = {};

        template.kotree.$container = template.$container.find(&#039;.kotree&#039;);
        template.kotree.$container.detach();

        template.kotree.$game = template.kotree.$container.find(&#039;.game&#039;);
        template.kotree.$game.detach();
        template.kotree.$label = template.kotree.$game.find(&#039;.label&#039;);
        template.kotree.$label.detach();
        template.kotree.$labeltext = template.kotree.$label.find(&#039;&gt;&#039;);
        template.kotree.$names = template.kotree.$game.find(&#039;.names&#039;);
        template.kotree.$teamno = template.kotree.$game.find(&#039;.number&#039;);
        template.kotree.$points = template.kotree.$game.find(&#039;.points&#039;);

        template.progresstable = {};

        template.progresstable.$container = template.$container
            .find(&#039;table.progresstable&#039;);
        template.progresstable.$container.detach();
        template.progresstable.$nameheader = template.progresstable.$container
            .find(&#039;th.names&#039;);

        template.progresstable.$gameheader = template.progresstable.$container
            .find(&#039;th.game&#039;);
        template.progresstable.$gameheader.detach();
        template.progresstable.$resultheader = template.progresstable.$container
            .find(&#039;th.result&#039;);
        template.progresstable.$resultheader.detach();

        template.progresstable.$team = template.progresstable.$container
            .find(&#039;.team&#039;);
        template.progresstable.$team.detach();
        template.progresstable.$teamno = template.progresstable.$team
            .find(&#039;.number&#039;);
        template.progresstable.$names = template.progresstable.$team
            .find(&#039;.names&#039;);

        template.progresstable.$game = template.progresstable.$team
            .find(&#039;td.game&#039;);
        template.progresstable.$game.detach();

        template.progresstable.$result = template.progresstable.$team
            .find(&#039;td.result&#039;);
        template.progresstable.$result.detach();

        // game template
        template.game = {};

        template.$gamescontainer = template.$container.find(&#039;table.gamestable&#039;);
        template.$gamescontainer.detach();

        template.game.$game = template.$gamescontainer.find(&#039;.game.tpl&#039;);
        template.game.$game.detach();
        template.game.$game.removeClass(&#039;tpl&#039;);

        template.game.$teamnos = [];
        tmp = template.game.$game.find(&#039;.number&#039;);
        for (i = 0; i &lt; tmp.length; i += 1) {
          template.game.$teamnos[i] = tmp.eq(i);
        }
        template.game.$names = [];
        tmp = template.game.$game.find(&#039;.names&#039;);
        for (i = 0; i &lt; tmp.length; i += 1) {
          template.game.$names[i] = tmp.eq(i);
        }
        template.game.$correct = template.game.$game.find(&#039;.correct&#039;);

        // points change template (actually not a template, but who cares?)
        template.chpoints = {};
        template.chpoints.$chpoints = template.game.$game.find(&#039;.chpoints&#039;);
        template.chpoints.$chpoints.detach();
        template.chpoints.$inputs = [];
        tmp = template.chpoints.$chpoints.find(&#039;input&#039;);
        tmp.attr(&#039;max&#039;, Options.maxpoints).attr(&#039;min&#039;, 0);
        tmp.val(0);
        for (i = 0; i &lt; tmp.length; i += 1) {
          template.chpoints.$inputs[i] = tmp.eq(i);
        }
        template.chpoints.$savebutton = template.chpoints.$chpoints
            .find(&#039;button&#039;);

        // bye template
        template.bye = {};
        template.bye.$bye = template.$gamescontainer.find(&#039;.bye.tpl&#039;);
        template.bye.$bye.detach();
        template.bye.$bye.removeClass(&#039;tpl&#039;);
        template.bye.$bye.find(&#039;.points&#039;).text(
            Options.byepointswon + &#039;:&#039; + Options.byepointslost);
        template.bye.$teamno = template.bye.$bye.find(&#039;.number&#039;);
        template.bye.$names = template.bye.$bye.find(&#039;.names&#039;);
      }

      function init() {
        if ($tab) {
          console.error(&#039;tab_history: $tab already exists:&#039;);
          console.error($tab);
          return;
        }

        $tab = $(&#039;#tabs &gt; [data-tab=&quot;history&quot;]&#039;);

        initTemplates();
        initCorrection();
        initOptions();
      }

      function createGamesTable(tournamentid) {
        var round, maxround, hidden, empty, votes, tournamentid, $box, $table;

        votes = History.getVotes(tournamentid);
        maxround = History.numRounds(tournamentid);
        empty = true;
        hidden = true;

        for (round = 0; round &lt; maxround; round += 1) {
          $box = template.$container.clone();
          $box.find(&#039;&gt;h3:first-child&#039;).text(
              Tournaments.getName(tournamentid) + &#039; - Runde &#039; + (round + 1));
          $table = template.$gamescontainer.clone();
          $box.append($table);

          // search the bye for this round
          // TODO preprocessing?
          votes.map(function(vote) {
            if (vote[0] == History.BYE &amp;&amp; vote[2] == round) {
              bye = vote[1];
              if (bye !== undefined) {
                createBye(bye, $table);
                empty = false;
              }
            }
          });

          History.getRound(tournamentid, round).map(function(game) {
            createGame(game, $table);
            empty = false;
          });

          if (!empty) {
            $tab.append($box);
            $box.data(&#039;tournamentid&#039;, tournamentid);
            if (!Tournaments.isRunning(tournamentid)) {
              $box.addClass(&#039;collapsed&#039;);
            }
            new BoxView($box);
            hidden = false;
          }
        }

        return !hidden;
      }

      /**
       * borrowed from jQuery
       *
       * @param obj
       *          the object to verify
       * @return true if obj is a number, false otherwise
       */
      function isNumeric(obj) {
        return !jQuery.isArray(obj) &amp;&amp; (obj - parseFloat(obj) + 1) &gt;= 0;
      }

      /**
       * creates a progress mapping, which, for every player, lists every game
       * in every round, with its result and
       *
       * @param tournamentid
       * @return the progress mapping
       */
      function getProgressMapping(tournamentid) {
        var teamgames, roundno, tournament;
        teamgames = [];

        function addGame(round, team, opponent, p1, p2) {
          if (!teamgames[team]) {
            teamgames[team] = [];
          }
          // increase opponent id by 1, since it&#039;s zero-indicated, but users
          // like to
          // start at 1
          if (isNumeric(opponent)) {
            opponent += 1;
          }
          teamgames[team][round] = {
            opponent: opponent,
            points: p1 + &#039;:&#039; + p2,
            won: (p1 == p2 ? undefined : p1 &gt; p2)
          };
        }

        if (History.getVotes(tournamentid)) {
          History.getVotes(tournamentid).map(
              function(vote) {
                if (vote[0] === History.BYE) {
                  addGame(vote[2], vote[1], Strings.byevote,
                      Options.byepointswon, Options.byepointslost);
                }
              });
        }

        if (History.getGames(tournamentid)) {
          History.getGames(tournamentid).map(function(game) {
            addGame(game[4], game[0], game[1], game[2], game[3]);
            addGame(game[4], game[1], game[0], game[3], game[2]);
          });
        }

        tournament = Tournaments.getTournament(tournamentid);
        if (tournament) {
          roundno = Tournaments.getRanking(tournamentid).round - 1;
          tournament.getGames().map(function(game) {
            addGame(roundno, game.teams[0][0], game.teams[1][0], &#039;&#039;, &#039;&#039;);
            addGame(roundno, game.teams[1][0], game.teams[0][0], &#039;&#039;, &#039;&#039;);
          });
        } else {
          // tournament has already been finished
          // console.warn(&#039;no tournament&#039;);
        }

        return teamgames;
      }

      function getTeamVotes(tournamentid) {
        var teamvotes;
        teamvotes = [];

        History.getVotes(tournamentid).map(function(vote) {
          var team;

          team = vote[1];
          if (!teamvotes[team]) {
            teamvotes[team] = &#039;&#039;;
          }

          switch (vote) {
          case History.BYE:
            teamvotes[team] += Strings.byevote;
            break;
          case History.UP:
            teamvotes[team] += Strings.upvote;
            break;
          case History.DOWN:
            teamvotes[team] += Strings.downvote;
            break;
          }
        });

        return teamvotes;
      }

      function getRankingMapping(tournamentid) {
        var ranking, mapping;
        mapping = [];

        ranking = Tournaments.getRanking(tournamentid);

        if (!ranking) {
          console.error(&#039;no ranking returned&#039;);
          return undefined;
        }

        ranking.ids.map(function(teamid, index) {
          mapping[teamid] = [ranking.wins[index], ranking.buchholz[index],
              ranking.finebuchholz[index], ranking.netto[index],
              ranking.place[index] + 1];
        });

        return mapping;
      }

      function createProgressTable(tournamentid) {
        var teamgames, teamid, team, maxround, $box, $table, $row, i, $game;

        maxround = Math.max(History.numRounds(tournamentid) || 0, Tournaments
            .getRanking(tournamentid).round || 0);

        // prepare table headers
        template.progresstable.$nameheader.removeClass(&#039;hidden&#039;);
        for (i = State.teamsize.get(); i &lt; 3; i += 1) {
          template.progresstable.$nameheader.eq(i).addClass(&#039;hidden&#039;);
        }

        $box = template.$container.clone();
        $box.find(&#039;&gt;h3:first-child&#039;).text(
            Tournaments.getName(tournamentid) + &#039; - Fortschrittstabelle&#039;);

        $table = template.progresstable.$container.clone();

        for (i = 0; i &lt; maxround; i += 1) {
          template.progresstable.$gameheader.find(&#039;.roundno&#039;).text(i + 1);
          $table.find(&#039;th:last-child&#039;).after(
              template.progresstable.$gameheader.clone());
        }
        $table.find(&#039;th:last-child&#039;).after(
            template.progresstable.$resultheader.clone());

        teamgames = getProgressMapping(tournamentid);
        teamranks = getRankingMapping(tournamentid);

        if (teamgames.length != teamranks.length) {
          console.error(&#039;teamgames.length != teamranks.length: &#039;
              + teamgames.length + &#039;!=&#039; + teamranks.length);
        }

        template.progresstable.$names.removeClass(&#039;hidden&#039;);

        teamranks.forEach(function(something, teamid) {
          team = Team.get(teamid);

          // add team-specific content
          template.progresstable.$teamno.text(teamid + 1);
          for (i = 0; i &lt; 3; i += 1) {
            if (team.getPlayer(i)) {
              template.progresstable.$names.eq(i).text(
                  team.getPlayer(i).getName());
            } else {
              template.progresstable.$names.eq(i).addClass(&#039;hidden&#039;);
            }
          }

          $row = template.progresstable.$team.clone();

          if (teamgames[teamid]) {
            teamgames[teamid].map(function(game) {
              var $game;
              $game = template.progresstable.$game.clone();
              $game.eq(0).text(game.opponent);
              $game.eq(1).text(game.points);
              if (game.opponent === Strings.byevote) {
                $game.eq(1).removeClass(&#039;correct editable&#039;);
              }
              $game.eq(2).text(Strings[&#039;winstatus&#039; + game.won]);
              $row.append($game);
            });
          }

          // append ranking
          teamranks[teamid].map(function(text, id) {
            template.progresstable.$result.eq(id).text(text);
          });
          $row.append(template.progresstable.$result.clone());

          $table.append($row);
        });
        $box.data(&#039;tournamentid&#039;, tournamentid);
        $box.append($table);
        $tab.append($box);
        if (!Tournaments.isRunning(tournamentid)) {
          $box.addClass(&#039;collapsed&#039;);
        }
        new BoxView($box);

        return maxround &gt; 0;
      }

      /**
       * Copied from kotournament.js
       *
       * @param id
       *          the game id
       * @return the level of the game id
       */
      function level(id) {
        return Math.floor(Math.log(id + 1) / Math.LN2);
      }

      /**
       * @param id
       *          the game id
       * @return the game id of the parent
       */
      function parent(id) {
        return Math.floor((id - 1) / 2);
      }

      /**
       * @param level
       *          the level
       * @return the lowest game id in the level
       */
      function lowestid(level) {
        return nodesbylevel(level) - 1;
      }

      /**
       * @param level
       *          the level
       * @return the number of games in this level
       */
      function nodesbylevel(level) {
        return 1 &lt;&lt; level;
      }

      /**
       * return the x coordinate of a game box
       *
       * @param gameid
       *          the game id
       * @param maxlevel
       *          the highest level
       * @return the x coordinate
       */
      function getGameTreeX(gameid, maxlevel) {
        var gamelevel, x0, width;

        x0 = 1;
        width = 15;
        if ($tab.hasClass(&#039;hidenames&#039;)) {
          width -= 8;
        }

        gamelevel = level(gameid);

        return x0 + (maxlevel - gamelevel) * width;
      }

      /**
       * return the y coordinate of a game box
       *
       * @param gameid
       *          the game id
       * @param maxlevel
       *          the highest level
       * @return the y coordinate
       */
      function getGameTreeY(gameid, maxlevel, thirdplace) {
        var gamelevel, y0, height;

        height = 5;
        y0 = 3 - height;

        gamelevel = level(gameid);
        firstid = lowestid(gamelevel);

        return y0 + height * Math.pow(2, maxlevel - gamelevel - 1) + height
            * Math.floor(Math.pow(2, maxlevel - gamelevel + 1) * 0.5)
            * (gameid - firstid) + (thirdplace ? height : 0);
      }

      function createGameTreeBox(game, maxid, thirdplace) {
        var x, y, maxlevel, $game;

        maxlevel = level(maxid);

        if (game.t1 === undefined &amp;&amp; game.t2 === undefined
            &amp;&amp; level(game.id) === maxlevel) {
          return undefined;
        }

        template.kotree.$teamno.eq(0).text(
            game.t1 === undefined ? &#039;&#039; : game.t1 + 1);
        template.kotree.$teamno.eq(1).text(
            game.t2 === undefined ? &#039;&#039; : game.t2 + 1);

        template.kotree.$names.text(&#039;&#039;);
        if (game.t1 !== undefined) {
          template.kotree.$names.eq(0).text(Team.getNames(game.t1).join(&#039;, &#039;));
        }
        if (game.t2 !== undefined) {
          template.kotree.$names.eq(1).text(Team.getNames(game.t2).join(&#039;, &#039;));
        }

        template.kotree.$points.text(game.p1 + &#039;:&#039; + game.p2);

        x = getGameTreeX(game.id, maxlevel);
        y = getGameTreeY(game.id, maxlevel, thirdplace);

        $game = template.kotree.$game.clone().css(&#039;left&#039;, x + &#039;em&#039;).css(&#039;top&#039;,
            y + &#039;em&#039;);

        if (game.id === 0) {
          template.kotree.$labeltext.text(thirdplace ? Strings.thirdplace
              : Strings.firstplace);
          $game.prepend(template.kotree.$label.clone());
        }

        return $game;
      }

      function createKOGameToParentConnector(game, maxid) {
        var x, y, x2, y2, maxlevel;

        maxlevel = level(maxid);

        x = getGameTreeX(game.id, maxlevel);
        y = getGameTreeY(game.id, maxlevel);

        if (game.id &gt; 0) {
          x2 = getGameTreeX(parent(game.id), maxlevel);
          y2 = getGameTreeY(parent(game.id), maxlevel);

          x += 13;
          if ($tab.hasClass(&#039;hidenames&#039;)) {
            x -= 8;
          }
          y += 1.5;

          x2 += 0;
          y2 += 1.5;

          return $((new KOLine([x, y], [x2, y2])).svg);
        }

        return undefined;
      }

      /**
       * create a KO tree box
       *
       * @param tournamentid
       *          the id of the tournament
       * @return true of a game tree tree has been added, false otherwise
       */
      function createKOTree(tournamentid) {
        var games, i, $box, g, $game, boxwidth, boxheight, $connector, thirdplacegame;

        thirdplacegame = undefined;
        games = [];

        // add finished games
        if (History.numRounds(tournamentid)) {
          History.getGames(tournamentid).forEach(function(game) {
            if (game[4] === 0) {
              games.push({
                id: game[5],
                t1: game[0],
                t2: game[1],
                p1: game[2],
                p2: game[3]
              });
            } else if (game[4] === 1) {
              thirdplacegame = {
                id: game[5],
                t1: game[0],
                t2: game[1],
                p1: game[2],
                p2: game[3]
              };
            }
          });
        }

        // add running games
        if (Tournaments.isRunning(tournamentid)) {
          Tournaments.getTournament(tournamentid).getGames().forEach(
              function(game) {
                if (game.roundid === 0) {
                  games.push({
                    id: game.id,
                    t1: game.teams[0][0],
                    t2: game.teams[1][0],
                    p1: &#039;&#039;,
                    p2: &#039;&#039;
                  });
                } else if (game.roundid === 1) {
                  thirdplacegame = {
                    id: game.id,
                    t1: game.teams[0][0],
                    t2: game.teams[1][0],
                    p1: &#039;&#039;,
                    p2: &#039;&#039;
                  };
                }
              });
        }

        // sort all the games
        games.sort(function(a, b) {
          return a.id - b.id;
        });

        // insert empty games where they&#039;re missing
        for (i = 0; i &lt; games.length; i += 1) {
          if (games[i].id &gt; i) {
            games.splice(i, 0, {
              id: i,
              t1: undefined,
              t2: undefined,
              p1: &#039;&#039;,
              p2: &#039;&#039;
            });

          }
        }

        // add byevotes through another cheap hack
        if (Tournaments.isRunning(tournamentid)) {
          Tournaments.getTournament(tournamentid).gameid
              .map(function(id, teamno) {
                if (Tournaments.getTournament(tournamentid).roundids[teamno] === 0) {
                  if (id &gt;= 0 &amp;&amp; games[id].t1 === undefined) {
                    games[id].t1 = Tournaments.getTournament(tournamentid).players
                        .at(teamno);
                  }
                }
              });
        }

        // bye for the third place
        if (!thirdplacegame &amp;&amp; Tournaments.isRunning(tournamentid)) {
          Tournaments.getTournament(tournamentid).gameid
              .forEach(function(id, teamno) {
                if (Tournaments.getTournament(tournamentid).roundids[teamno] === 1) {
                  if (id &gt;= 0) {
                    thirdplacegame = {
                      id: 0,
                      t1: Tournaments.getTournament(tournamentid).players
                          .at(teamno),
                      t2: undefined,
                      p1: &#039;&#039;,
                      p2: &#039;&#039;
                    };
                  }
                }
              });
        }

        //
        if (!thirdplacegame) {
          thirdplacegame = {
            id: 0,
            t1: undefined,
            t2: undefined,
            p1: &#039;&#039;,
            p2: &#039;&#039;
          };
        }

        if (!games.length) {
          return false;
        }

        // print the games

        $box = template.$container.clone();
        $box.find(&#039;&gt;h3:first-child&#039;).text(
            Tournaments.getName(tournamentid) + &#039; - KO-Baum&#039;);

        $tree = template.kotree.$container.clone();

        boxheight = 0;

        for (i = games.length - 1; i &gt;= 0; i -= 1) {
          g = games[i];
          $game = createGameTreeBox(g, games.length - 1);
          if ($game) {
            g.$box = $game;
            $connector = createKOGameToParentConnector(g, games.length - 1);
            if ($connector) {
              $tree.append($connector);
            }
            $tree.append($game);

            boxheight = Math.max(getGameTreeY(g.id, level(games.length - 1),
                false), boxheight);
          }
        }

        boxheight += 4;

        // render the third place
        $game = createGameTreeBox(thirdplacegame, games.length - 1, true);
        $tree.append($game);

        boxwidth = getGameTreeX(0, level(games.length - 1)) + 14.5;
        if ($tab.hasClass(&#039;hidenames&#039;)) {
          boxwidth -= 8;
        }

        $tree.css(&#039;width&#039;, boxwidth + &#039;em&#039;);
        $tree.css(&#039;height&#039;, boxheight + &#039;em&#039;);

        if (!Tournaments.isRunning(tournamentid)) {
          $box.addClass(&#039;collapsed&#039;);
        }
        new BoxView($box);

        $box.data(&#039;tournamentid&#039;, tournamentid);

        $box.append($tree);
        $tab.append($box);

        return games.length &gt; 0;
      }

      function showTournaments() {
        var hidden, tournamentid, displayfunc, numtournaments;

        hidden = true;

        numtournaments = Math.max(History.numTournaments() || 0, Tournaments
            .numTournaments() || 0);

        for (tournamentid = 0; tournamentid &lt; numtournaments; tournamentid += 1) {

          switch (Tournaments.getType(tournamentid)) {
          case &#039;swiss&#039;:
            displayfunc = createProgressTable;
            break;
          case &#039;ko&#039;:
            displayfunc = createKOTree;
            break;
          default:
            displayfunc = createGamesTable;
            break;
          }

          if (gamestable) {
            displayfunc = createGamesTable;
          }

          if (displayfunc(tournamentid)) {
            hidden = false;
          }
        }

        return !hidden;
      }

      /**
       * remove all evidence of any games ever (from the overview only)
       */
      function reset() {
        if (!$tab) {
          init();
        }

        abortCorrection();

        // remove containers
        $tab.find(&#039;.boxview&#039;).remove();
      }

      /**
       * removes and redraws all boxes from History
       */
      function update() {
        Tab_History.reset();

        if (showTournaments()) {
          Tabshandle.show(&#039;history&#039;);
        } else {
          Tabshandle.hide(&#039;history&#039;);
        }
      }

      Tab_History = Tab.createTab(&#039;history&#039;, reset, update);
      Shared.Tab_History = Tab_History;
      return Tab_History;
    });</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
